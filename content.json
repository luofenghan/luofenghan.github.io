{"meta":{"title":"心之所至、意之使然","subtitle":null,"description":null,"author":"落枫寒","url":"http://luofenghan.github.io"},"pages":[{"title":"关于","date":"2017-01-16T15:24:04.000Z","updated":"2017-01-16T15:24:29.826Z","comments":true,"path":"about/index.html","permalink":"http://luofenghan.github.io/about/index.html","excerpt":"","text":""},{"title":"文章","date":"2017-01-16T15:31:12.000Z","updated":"2017-04-29T02:19:33.383Z","comments":true,"path":"archives/index.html","permalink":"http://luofenghan.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-01-16T15:21:44.000Z","updated":"2017-01-16T15:22:19.052Z","comments":true,"path":"categories/index.html","permalink":"http://luofenghan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-01-16T15:22:46.000Z","updated":"2017-01-16T15:23:17.675Z","comments":true,"path":"tags/index.html","permalink":"http://luofenghan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android增量更新：服务器篇","slug":"Android增量更新：服务器篇","date":"2017-04-30T13:40:21.000Z","updated":"2017-04-30T23:08:03.147Z","comments":true,"path":"2017/04/30/Android增量更新：服务器篇/","link":"","permalink":"http://luofenghan.github.io/2017/04/30/Android增量更新：服务器篇/","excerpt":"增量更新的原理其实增量升级的原理很简单，即首先将应用的旧版本Apk与新版本Apk做差分，得到更新的部分的补丁，例如旧版本的APK有5M，新版的有8M，更新的部分则可能只有3M左右(这里需要说明的是，得到的差分包大小并不是简单的相减，因为其实需要包含一些上下文相关的东西——有时候旧版本10M，新版本8M，得到的差分包可能有5M)，使用差分升级的好处显而易见，那么你不需要下载完整的8M文件，只需要下载更新部分就可以，而更新部分可能只有3、4M，可以很大程度上减少流量的损失。 在用户下载了差分包之后，需要在手机端将他们组合起来。可以参考的做法是先将手机端的旧版本软件(多半在/data/下)，复制到SD卡或者cache中，将它们和之前的差分patch进行组合，得到一个新版本的apk应用，如果不出意外的话，这个生成的apk和你之前做差分的apk是一致的。","text":"增量更新的原理其实增量升级的原理很简单，即首先将应用的旧版本Apk与新版本Apk做差分，得到更新的部分的补丁，例如旧版本的APK有5M，新版的有8M，更新的部分则可能只有3M左右(这里需要说明的是，得到的差分包大小并不是简单的相减，因为其实需要包含一些上下文相关的东西——有时候旧版本10M，新版本8M，得到的差分包可能有5M)，使用差分升级的好处显而易见，那么你不需要下载完整的8M文件，只需要下载更新部分就可以，而更新部分可能只有3、4M，可以很大程度上减少流量的损失。 在用户下载了差分包之后，需要在手机端将他们组合起来。可以参考的做法是先将手机端的旧版本软件(多半在/data/下)，复制到SD卡或者cache中，将它们和之前的差分patch进行组合，得到一个新版本的apk应用，如果不出意外的话，这个生成的apk和你之前做差分的apk是一致的。 增量更新实现使用的工具使用开源的二进制比较工具bsdiff 及其依赖的bzip2 下载完后，得到这样的目录结构： 其中bsdiff.c用于在服务端生成差分包，bspatch.c用于在客户端把旧版本apk与服务端生成的差分包进行合成为新版本apk。 实现的步骤 在服务端，生成新旧版本的差分包 在客户端，使用已安装的旧版apk与这个差分包，合成为一个新版apk。 校验新合成的客户端文件是否完成，签名时候和已安装客户端一致，如一致，提示用户安装; 服务端生成差分包简介由于服务器的不同，因此我们需要将以上的c/c++文件，build输出为动态链接库，以供java调用，其中Window环境生成名为libApkPatchLibraryServer.dll文件，Unix/Linux环境生成名为libApkPatchLibraryServer.so，OSX下生成名为libApkPatchLibraryServer.dylib的文件。下面具体讲一下在Windows服务器上怎么生成libApkPatchLibraryServer.dll文件的 生成dll动态链接库 下载开源工具 如果我们要生成dll动态链接库，那我们就不能用刚才下的bsdiff-4.3了（具体原因下面再说），我们需要在这里bsdiff 下载一个针对win32版本的bsdiff文件，下载页面如图所示： 下载得到的文件如图所示： 里面已经包含了bsdiff.cpp，bspatch.cpp及其依赖的bzlip等文件。 改写bsdiff.cpp（生成差分包） 首先，在MyEclispe中声明一个native方法，如图所示： 接着，为了生成的方便，将该类及完整的所在包复制到桌面上，我们利用javac 和javap命令将该native方法生成c/c++中对应的.h头文件： 这时，我们可以看到在桌面上生成了一个com_cwc_smartupdate_util_DiffUtil.h的头文件。打开头文件，如下图所示： 以上代码需要说明一下，首先函数名的格式遵循如下规则：Java_包名_类名_方法名。其中，JNIEXPORT、JNICALL、JNIEnv和jobject都是JNI标准中定义的类型或者宏。 实现JNI方法 这里可以选用c或c++实现，我们这使用的是c++，因为在上文中下载win32版本的bsdiff中的bsdiff.cpp就是用c++实现的，接着我们打开该文件进行改写。（注意：我这以下的所有操作都是基于VS2013，因为涉及到很多c和h文件的引用，如果使用命令行的话，在连接阶段可能出现函数未定义的情况，为了简便本人直接使用了VS2013来生成dll文件）。 首先，利用vs2013新建一个dll项目，将bsdiff4.3-win32-src.zip解压得到的文件导入该项目中，并将bsdiff.cpp重新命名为com_cwc_smartupdate_util_DiffUtil.cpp，另外，这里还需要三个头文件，分别是jni.h、jni_md.h（在两个在ndk里面找，可以在该ndk根文件夹子下全文搜索一下）和刚才生成的com_cwc_smartupdate_util_DiffUtil.h，最终得到的目录结构如下： 接着我们打开com_cwc_smartupdate_util_DiffUtil.cpp文件，进行我们的改写操作，首先，引入头文件： 之后，把typedef long pid_t注释掉，并添加ftello和fseeko两个函数宏定义，如图所示： 接着，我们来实现com_cwc_smartupdate_util_DiffUtil.h中的函数，代码如下： 这段代码意思是将传入的三个字符串（新旧版本的文件路径和生成的差分包路径）分别放进一个char* 类型的指针数组里面，然后调用appDiff函数，生成差分包。那这个appDiff如何实现呢，我们找到该文件下的main方法，将该main方法重命名为appDiff： 接着，把该appDiff函数向下拖动，会看到这段代码，这段代码用于通过打开旧版本文件，将文件的数据读到名为old的内存当中，这段代码改写如下： 因为lseek，open等函数都是Linux里面的，如果在window下使用会出现打开文件失败的情况。改写的文件如下，其中stream是新定义的一个FILE* stream;文件类型指针： 通过这段代码可以将旧版本文件数据读取到u_char* old中。接着，我们改写读取新文件的这段代码，代码如下： 改写成： 到此为止，我们的所有操作就全部完成了，接下来我们生成dll文件，在生成的dll文件中也注意是32位的还是64位的，不然在java调用的时候会出现读取失败的情况。 在服务端调用dll文件 其中，DiffAppServer64就是刚才生成的dll文件，由于DiffAppServer64.dll需要依赖其他的dll文件，我这需要依赖msvcr100d和kernel32，所以在这里也必须将两个文件导入才行。最后，这三个文件放置的位置如图所示： 在tomcat根目录下的bin子目录下新建一个appdiff目录，然后把三个文件放到这里。当这些所有的操作完成之后，就可以在服务端生成差分包了。 运行效果展示apk文件上传页面面 旧版本文件上传 新版本文件上传 当上传新版本后，服务端后台就自动开始生成差分包的工作了 那么又涉及到另外一个问题，由于比较生成差分包在底层进行，并且非常的耗时，大概需要1分多钟，那么如何显示进度，生成差分包的工作进行到哪一步了？这就需要利用jni调用java方法，将底层的信息传到java代码层。 jni调用java方法，回传底层的进度信息 在声明genDiff 这个native方法的的类中java.cwc.smartupdate.util.DiffUtil声明一个静态的方法： 这个方法表示，在c底层进行调用该方法，传递整型state参数，通过对比不同的整型数据，找到底层对应的执行进度。 让我们返回到com_cwc_smartupdate_util_DiffUtil.cpp文件中，找到我们在上文中实现的本地方法对应的函数： 为了方便演示，在这个函数上面定义一个用于发布进度的函数： 这段函数的意思就是通过反射来调用DiffUtil类内的静态方法publishProgress，然后在appDiff函数内部，就可以在关键的地方调用该函数用来发布当前执行任务的状态了，（注意定义的函数需要在该文件头部声明，不然出现找不到函数的错误提示），另外还有一点需要注意，publishProgress需要调用不止一次，因此不可能每次都通过反射来创建DiffUtil的类对象(创建一次就够了)，因此，我们需要将上面的函数整理为以下格式： 服务端的java代码层 由于publishProgress传递的是整型数据，我们可以自定义一些整型常量来映射出对应的任务状态。还可以在该DiffUtil定义一个内部接口，这样其他类实现了该接口，就可以接收到底层返回的进度。 结论到此为止，整个增量更新的服务端是实现就结束了，总结一下： 我们首先在java中定义了一个本地native方法，通过javac和javap命令生成了对应的h头文件； 然后改写bsdiff.cpp文件，实现刚才生成的头文件中的函数，并针对windows服务器改写bsdiff.cpp的函数内部的细节； 最后进行将生成的dll文件放到了tomcat服务器中，利用System.loadLibrary函数加载dll文件，如果缺少依赖dll的话，就添加对应的dll文件； 最后为了实现进度的显示，我们又定义了publishProgress方法，并在底层实现了该函数，在java端的DiffUtil类中定义了一个接口，让其他实现该接口的类可以接收到底层发布的进度。","categories":[{"name":"Android","slug":"Android","permalink":"http://luofenghan.github.io/categories/Android/"}],"tags":[{"name":"增量更新","slug":"增量更新","permalink":"http://luofenghan.github.io/tags/增量更新/"},{"name":"android","slug":"android","permalink":"http://luofenghan.github.io/tags/android/"}]},{"title":"到底什么时候该使用MQ","slug":"到底什么时候该使用MQ","date":"2017-04-29T22:23:39.000Z","updated":"2017-04-30T23:08:29.954Z","comments":true,"path":"2017/04/30/到底什么时候该使用MQ/","link":"","permalink":"http://luofenghan.github.io/2017/04/30/到底什么时候该使用MQ/","excerpt":"MQ的用途消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。 在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，逻辑上和物理上都不用依赖其他服务。","text":"MQ的用途消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。 在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，逻辑上和物理上都不用依赖其他服务。 不使用MQ的情况MQ作为互联网分层架构中的解耦利器，那为什么不是所有通讯都使用MQ呢？因为，调用与被调用的关系，是无法被MQ取代的。调用方实时依赖执行结果的业务场景，请使用调用，而不是MQ。 MQ的缺陷 系统更复杂，多了一个MQ组件； 消息传递路径更长，延时增加； 消息可靠性和重复性互为矛盾，消息不丢不重难以同时保证； 上游无法知道下游的执行结果，这一点是很致命的。 什么时候使用MQ场景一：数据驱动的任务依赖 什么是任务依赖 互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，比如： task3需要使用task2的输出作为输入； task2需要使用task1的输出作为输入； 这样的话，tast1,task2,task3之间就有任务依赖关系，必须task1先执行，再task2执行，载task3执行。 使用cron人工排执行时间表 task1，0:00执行，经验执行时间为50分钟 task2，1:00执行（为task1预留10分钟buffer），经验执行时间也是50分钟 task3，2:00执行（为task2预留10分钟buffer） 使用cron的缺点 如果有一个任务执行时间超过了预留buffer的时间，将会得到错误的结果，因为后置任务不清楚前置任务是否执行成功，此时要手动重跑任务，还有可能要调整排班表。 总任务的执行时间很长，总是要预留很多buffer，如果前置任务提前完成，后置任务不会提前开始。 如果一个任务被多个任务依赖，这个任务将会称为关键路径，排班表很难体现依赖关系，容易出错。 如果有一个任务的执行时间要调整，将会有多个任务的执行时间要调整 采用MQ解耦方案 task1准时开始，结束后发一个“task1 done”的消息 task2订阅“task1 done”的消息，收到消息后第一时间启动执行，结束后发一个“task2done”的消息。 task3同理 采用MQ的优点 不需要预留buffer，上游任务执行完，下游任务总会在第一时间被执行。 依赖多个任务，被多个任务依赖都很好处理，只需要订阅相关消息即可 有任务执行时间变化，下游任务都不需要调整执行时间。 MQ使用注意 MQ只用来传递上游任务执行完成的消息，并不用于传递真正的输入输出数据。 典型场景二：上游不关心执行结果 58同城的很多下游需要关注“用户发布帖子”这个事件 比如招聘用户发布帖子后，招聘业务要奖励58豆，房产用户发布帖子后，房产业务要送2个置顶，二手用户发布帖子后，二手业务要修改用户统计数据。 采用调用关系解决 帖子发布服务执行完成之后，调用下游招聘业务、房产业务、二手业务，来完成消息的通知，但事实上，这个通知是否正常正确的执行，帖子发布服务根本不关注。 采用调用的缺陷 帖子发布流程的执行时间增加了 下游服务宕机，可能导致帖子发布服务受影响，上下游逻辑+物理依赖严重。 每当增加一个需要知道“帖子发布成功”信息的下游，修改代码的是帖子发布服务，这一点是最恶心的，属于架构设计中典型的依赖倒转，谁用过谁痛谁知道。 采用MQ解耦方案 帖子发布成功后，向MQ发一个消息 哪个下游关注“帖子发布成功”的消息，主动去MQ订阅 采用MQ的优点 上游执行时间短 上下游逻辑+物理解耦，除了与MQ有物理连接，模块之间都不相互依赖 新增一个下游消息关注方，上游不需要修改任何代码。 典型场景三：上游关注执行结果，但执行时间很长 微信支付 跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果，此时一般怎么玩呢？ 采用“回调网关+MQ”方案来解耦： 调用方直接跨公网调用微信接口 微信返回调用成功，此时并不代表返回成功 微信执行完成后，回调统一网关 网关将返回结果通知MQ 请求方收到结果通知 总结什么时候不使用MQ？上游实时关注执行结果 什么时候使用MQ？ 数据驱动的任务依赖 上游不关心多下游执行结果 异步返回执行时间长","categories":[{"name":"架构师","slug":"架构师","permalink":"http://luofenghan.github.io/categories/架构师/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://luofenghan.github.io/tags/架构/"},{"name":"消息队列","slug":"消息队列","permalink":"http://luofenghan.github.io/tags/消息队列/"}]},{"title":"Tomcat多实例单应用部署方案","slug":"Tomcat多实例单应用部署方案","date":"2017-04-29T02:20:53.000Z","updated":"2017-04-30T23:10:26.309Z","comments":true,"path":"2017/04/29/Tomcat多实例单应用部署方案/","link":"","permalink":"http://luofenghan.github.io/2017/04/29/Tomcat多实例单应用部署方案/","excerpt":"Tomcat部署的场景分析单实例单应用如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。","text":"Tomcat部署的场景分析单实例单应用如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。 单实例多应用是把多个应用程序的war包放在同一个tomcat的webapps目录，这样一来，关闭和启动tomcat会影响所有项目。 多实例单应用各个tomcat都运行同一个应用程序，对应地需要修改不同的监听端口，这种方式通常会和apache httpd或者nginx整合使用，做一些负载均衡的处理。 多实例多应用相当于第一种场景的复数形式，除了修改不同的监听端口，没有本质区别。 Windows服务器下多实例单应用设置流程分离目录 刚解压出来的tomcat目录结构 bin：主要存放脚本文件，例如比较常用的windows和linux系统中启动和关闭脚本 conf：主要存放配置文件，其中最重要的两个配置文件是server.xml和web.xml lib：主要存放tomcat运行所依赖的包 logs：主要存放运行时产生的日志文件，例如catalina.{date}.log等 temp：存放tomcat运行时产生的临时文件，例如开启了hibernate缓存的应用程序，会在该目录下生成一些文件 webapps：部署web应用程序的默认目录 work：主要存放由JSP文件生成的servlet（java文件以及最终编译生成的class文件） 将解压出来的tomcat文件拆分出的目录结构如下所示： 1234567891011121314151617181920F:/DevLibs/Tomcat├─applications│ ├─backend # 主要部署后端模块代码│ │ │ shutdown.bat│ │ │ startup.bat│ │ ├─conf│ │ ├─logs│ │ ├─temp│ │ ├─webapps │ │ └─work│ └─officals-website # 主要部署前端代码，如官方网站│ │ shutdown.bat│ │ startup.bat│ ├─conf│ ├─logs│ ├─temp│ ├─webapps│ └─work├─bin└─lib 修改环境变量 环境变量说明 CATALINA_HOME：即指向Tomcat安装路径的系统变量 CATALINA_BASE：即指向活跃配置路径的系统变量 通过设置这两个变量，就可以将tomcat的安装目录和工作目录分离，从而实现tomcat多实例的部署。 环境变量设置 新建变量名：CATALINA_HOME，变量值：F:/DevLibs/Tomcat 不需要增加CATALINA_BASE，该变量在脚本中动态设置。 打开PATH，添加变量值：%CATALINA_HOME%\\lib;%CATALINA_HOME%\\bin 修改server.xml 修改官方网站（officals-website）web应用的server.xml配置（端口号8081）。 将第22行的&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 修改为 &lt;Server port=&quot;8015&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 将第69行的&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 修改为 &lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; 将第91行的&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;修改为&lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 将第123行的&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;修改为&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt; 修改后端（backend）web应用的server.xml配置（端口号8082）。 将第22行的&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 修改为 &lt;Server port=&quot;8025&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 将第69行的&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 修改为 &lt;Connector port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot; 将第91行的&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;修改为&lt;Connector port=&quot;8029&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 将第123行的&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;修改为&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt; 修改启动和停止脚本 将初始tomcat的bin目录下的startup.bat 和shutdown.bat 这两个脚本分别拷贝到backend 和 offical-website 目录下 编辑startup.bat脚本，增加一行语句，用于设置CATALINA_BASE变量。（backend和offical-website需要同时修改） 1234567891011121314setlocalrem Guess CATALINA_HOME if not definedset &quot;CURRENT_DIR=%cd%&quot;## 在这里将CATALINA_BASE 设置为脚本所在目录set &quot;CATALINA_BASE=%cd%&quot; if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHomeset &quot;CATALINA_HOME=%CURRENT_DIR%&quot;if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHomecd ..set &quot;CATALINA_HOME=%cd%&quot;cd &quot;%CURRENT_DIR%&quot;:gotHome 编辑shutdown.bat脚本，增加一行语句，用于设置CATALINA_BASE变量。（backend和offical-website需要同时修改） 12345678910111213setlocalrem Guess CATALINA_HOME if not definedset &quot;CURRENT_DIR=%cd%&quot;## 在这里将CATALINA_BASE 设置为脚本所在目录set &quot;CATALINA_BASE=%cd%&quot;if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHomeset &quot;CATALINA_HOME=%CURRENT_DIR%&quot;if exist &quot;%CATALINA_HOME%\\bin\\catalina.bat&quot; goto okHomecd ..set &quot;CATALINA_HOME=%cd%&quot;cd &quot;%CURRENT_DIR%&quot;:gotHome 启动tomcats 分别在backend和officals-website目录，用Dos执行startup.bat脚本。 在浏览器输入loalhost:8081和loalhost:8082就可以访问tomcat管理页面了。 参考文章 Tomcat多实例单应用部署方案 一个tomcat部署多个应用实例总结","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://luofenghan.github.io/categories/Tomcat/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://luofenghan.github.io/tags/tomcat/"}]}]}