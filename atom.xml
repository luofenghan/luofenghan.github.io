<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唯有日月不灭</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.vibrancy.cn/"/>
  <updated>2017-07-05T05:13:12.832Z</updated>
  <id>http://www.vibrancy.cn/</id>
  
  <author>
    <name>落枫寒</name>
    <email>luofenghan_cwc@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AbstractQueuedSynchronizer源码分析</title>
    <link href="http://www.vibrancy.cn/repository/jdk8-abstractqueuedsynchronizer.html"/>
    <id>http://www.vibrancy.cn/repository/jdk8-abstractqueuedsynchronizer.html</id>
    <published>2017-07-05T05:03:21.000Z</published>
    <updated>2017-07-05T05:13:12.832Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:13:23 GMT+0800 (马来西亚半岛标准时间) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AQS实现锁机制并不是通过synchronized——给对象加锁实现的，事实上它仅仅是一个工具类！它没有使用更高级的机器指令，也不靠关键字，更不依靠JDK编译时的特殊处理，仅仅作为一个普普通通的类就完成了代码块的访问控制。</p><p>AQS使用<strong>标记位+队列</strong>的方式，记录获取锁、竞争锁、释放锁等一些类锁操作。但更准确的说，AQS并不关心<strong>什么是锁</strong>，对于AQS来说它只是实现了一系列的用于判断<strong>资源</strong>是否可以访问的API，并且封装了在<strong>访问资源受限</strong>时，将请求访问的线程加入队列、挂起、唤醒等操作。AQS关心的问题如下：</p><ol><li>资源不可访问时，怎么处理？</li><li>资源时可以被同时访问，还是在同一时间只能被一个线程访问？</li><li>如果有线程等不及资源了，怎么从AQS队列中退出？</li></ol><p>至于资源能否被访问的问题，则交给子类去实现。</p><p>站在使用者的角度，AQS的功能主要分为两类：<strong>独占锁</strong>和<strong>共享锁</strong>。在它的所有子类中，要么实现了它的独占功能的API，要么实现了共享功能的API，但不会同时使用两套API，即使是ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别使用两套API来实现的。</p><ul><li>当AQS的子类实现<strong>独占</strong>功能时，如ReentrantLock，<strong>资源是否可以被访问</strong>被定义为：只要AQS的state变量不为0，并且持有锁的线程不是当前线程，那么代表资源不可访问。</li><li>当AQS的子类实现<strong>共享</strong>功能时，如CountDownLatch，<strong>资源是否可以被访问</strong>被定义为：只要AQS的state变量不为0，那么代表资源不可以为访问。</li></ul><h2 id="类继承结构图"><a href="#类继承结构图" class="headerlink" title="类继承结构图"></a>类继承结构图</h2><p><img src="http://op87q3xru.bkt.clouddn.com/java/image/thread/AbstractQueuedSynchronizer.svg" alt="image"></p><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>ReentrantLock是AQS独占功能的一个实现，通常的使用方式如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reentrantLock.lock();</div><div class="line"><span class="comment">// do something</span></div><div class="line">reentrantLock.unlock();</div></pre></td></tr></table></figure><p></p><p>ReentrantLock会保证执行<code>do something</code>在同一时间有且只有一个线程获取到锁，其余线程全部挂起，直到该拥有锁的线程释放锁，被挂起的线程被唤醒重新开始竞争锁。</p><p>ReentrantLock的加锁全部委托给内部代理类完成，ReentrantLock只是封装了统一的一套API而已，而ReentrantLock又分为<strong>公平锁</strong>和<strong>非公平锁</strong>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</div></pre></td></tr></table></figure><p></p><ul><li><strong>公平锁</strong>：每个线程抢占锁的顺序为先后调用lock方法的顺序，并依此顺序获得锁，类似于排队吃饭；</li><li><strong>非公平锁</strong>：每个线程抢占锁的顺序不变，谁运气好，谁就获得锁，和调用lock方法的先后顺序无关，类似后插入。</li></ul><p>换句话说，公平锁和非公平锁的<strong>唯一的区别</strong>是在获取锁的时候是直接去获取锁，还是进入队列排队的问题。</p><h3 id="获取独占锁的流程"><a href="#获取独占锁的流程" class="headerlink" title="获取独占锁的流程"></a>获取独占锁的流程</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/image/thread/%E7%8B%AC%E5%8D%A0%E9%94%81%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.svg" alt="image"></p><ol><li><p>FairSync的<code>tryAcquire()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">/*获取当前线程*/</span></div><div class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">/*获取父类AQS中的标志位*/</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors()</div><div class="line">                <span class="comment">/*说明队列中没有其他线程：没有线程正在占有锁，那么修改一下状态位*/</span></div><div class="line">                <span class="comment">//注意：这里的acquires是在lock的时候传递来的，从上面的图中可以知道，这个值是写死的1</span></div><div class="line">                &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            <span class="comment">// 如果通过CAS操作将状态为更新成功则代表当前线程获取锁，</span></div><div class="line">            <span class="comment">// 因此，将当前线程设置到AQS的一个变量中，说明这个线程拿走了锁。</span></div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">/*返回true，说明已拿到锁*/</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="comment">/*如果当前state不为0，说明锁已经被拿走，那么判断是否是当前线程拿走了锁*/</span></div><div class="line">        <span class="comment">/*因为锁是可重入的，可以重复lock，unlock*/</span></div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果当前线程获取到锁，<code>tryAcquire()</code>返回true，否则返回false，这时会返回到AQS的<code>acquire()</code>方法。</p><p>如果没有获取到锁，那么应该将当前线程放到队列中去，只不过，在放之前，需要做些包装。</p></li><li><p>AQS的<code>addWaiter()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">/*将节点加入到队列尾部*/</span></div><div class="line">        node.prev = pred;</div><div class="line">        <span class="comment">/*尝试使用CAS方式修改尾节点，但是在【并发情况】下，可能修改失败*/</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*修改失败，说明有并发，那么进入enq，以自旋方式修改*/</span></div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用当前线程去构造一个Node对象，mode是一个表示Node类型的字段（独占的还是共享的）。构造好节点后，在队列不为空的时候，使用CAS的方式将新的节点加入队列尾部，如果修改失败，则进入<code>enq()</code>方法，使用自旋的方式修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将节点通过自旋的方式插入到队列尾部</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> node the node to insert</div><div class="line"> * <span class="doctag">@return</span> node's predecessor</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">        Node pred = tail;</div><div class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = pred;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">                pred.next = node;</div><div class="line">                <span class="keyword">return</span> pred;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将线程的节点接入到队里中后，当然还需要做一件事:将当前线程挂起！这个事，由<code>acquireQueued()</code>来做。</p></li><li><p>AQS的<code>acquireQueued()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">            <span class="comment">/*获得当前节点pred节点*/</span></div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="comment">/*如果当前节点正好是第二个节点，那么则再次尝试获取锁*/</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                <span class="comment">/*获取锁成功，*/</span></div><div class="line">                setHead(node); <span class="comment">/*将当前节点设置为头结点*/</span></div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/*当前节点不是第二个节点 或者 再次获取锁失败*/</span></div><div class="line">            <span class="comment">/*判断是否需要挂起，在挂起后，判断线程是否中断*/</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>判断此时是否能够安全的挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 当前节点已经被设置为等待唤醒的状态，可以安全的挂起了</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 当前节点node的前任节点被取消，那么【跳过】这些取消的节点，</div><div class="line">         * 当跳过之后，重新尝试获取锁</div><div class="line">         */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 通过前面的判断，waitStatus一定不是 SIGNAL 或 CANCELLED。</div><div class="line">         * 推断出一定是 0 or PROPAGATE</div><div class="line">         * 调用者需要再次尝试，在挂起之前能不能获取到锁，</div><div class="line">         * 因此，将当前pred的状态设为SIGNAL，再次尝试获取锁之后，如果还没有得到锁那么挂起</div><div class="line">         *</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>挂起线程，并判断此时线程是否被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">/*如果被中断，则返回true，interrupted()方法返回后，中断状态被取消，变为false*/</span></div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>到此为止，一个线程对于锁的一次竞争才告一段落，结果有两种</p><ul><li>要么成功获取到锁（不用进入到AQS队列中）；</li><li>要么获取失败，被挂起，等待下次唤醒后继续循环尝试获取锁。</li></ul><p>值得注意的是，AQS的队列为<strong>FIFO队列</strong>，所以，每次被CPU假唤醒，且当前线程<strong>不是处在头节点的位置</strong>，也是会被挂起的。AQS通过这样的方式，实现了竞争的排队策略。</p><h3 id="释放独占锁流程分析"><a href="#释放独占锁流程分析" class="headerlink" title="释放独占锁流程分析"></a>释放独占锁流程分析</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/image/thread/%E9%87%8A%E6%94%BE%E7%8B%AC%E5%8D%A0%E9%94%81%E6%B5%81%E7%A8%8B.svg" alt="image"></p><ol><li><p>AQS的<code>release()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            <span class="comment">/*将持有锁的头结点释放成功后</span></div><div class="line">            * 唤醒其后继节点</div><div class="line">            * */</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>尝试释放锁，如果释放成功，找到AQS的头节点，调用<code>unparkSuccessor()</code>唤醒FIFO队列中第一个等待锁的节点。</p></li><li><p>Sync的<code>tryRelease()</code>方法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    int c = getState() - releases;</div><div class="line">    //如果【释放的线程】和【获取锁的线程】不是同一个，抛出非法监视器状态异常。</div><div class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        throw new IllegalMonitorStateException();</div><div class="line"></div><div class="line">    boolean free = false;</div><div class="line">    // 因为是重入的关系，不是每次释放锁c都等于0，</div><div class="line">    // 直到最后一次释放锁时，才通知AQS不需要再记录哪个线程正在获取锁。</div><div class="line">    if (c == 0) &#123;</div><div class="line">        free = true;</div><div class="line">        setExclusiveOwnerThread(null);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    return free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>AQS的<code>unparkSuccessor()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*如果状态为负（SIGNAL、PROPAGATE），那么清除其状态</span></div><div class="line">        * 如果失败，或者状态被其他等待线程改变，也没有关系</div><div class="line">        * */</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 一般情况下唤醒的线程是【头结点】的【下一个节点】</div><div class="line">     * 但是如果该节点被取消或者为null，</div><div class="line">     * 那么需要【从后往前遍历】寻找一个【最早的】并且【没有被取消】的节点</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>当FIFO队列中等待锁的第一个节点被唤醒之后，会返回到到节点所在线程的<code>acquireQueued()</code>方法中，继续下一轮循环，这时当前节点正好时头节点的第一个后继节点，并且使用CAS修改状态持有锁成功，那么当前节点则晋升为头结点，并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">····</div><div class="line"></div><div class="line"><span class="keyword">for</span> (; ; ) &#123;</div><div class="line">    <span class="comment">/*获得当前节点pred节点*/</span></div><div class="line">    <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">    <span class="comment">/*如果当前节点正好是第二个节点，那么则再次尝试获取锁*/</span></div><div class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">        <span class="comment">/*获取锁成功，*/</span></div><div class="line">        setHead(node); <span class="comment">/*将当前节点设置为头结点*/</span></div><div class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">        failed = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> interrupted;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*当前节点不是第二个节点 或者 再次获取锁失败*/</span></div><div class="line">    <span class="comment">/*判断是否需要挂起，在挂起后，判断线程是否中断*/</span></div><div class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</div><div class="line">        interrupted = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">····</div></pre></td></tr></table></figure></li></ol><p>以上的分析是基于ReentrantLock内部的公平锁来分析的，并且其lcok和unlock已经基本分析完毕，唯独剩下一个非公平锁nonfairSync。其实，它和公平锁的唯一区别就是获取锁的方式不同，一个是按前后顺序一次获取锁，一个是抢占式的获取锁。</p><ul><li><strong>非公平锁的lock方法的处理方式</strong>：在lock的时候先直接CAS修改一次state变量（尝试获取锁），成功就返回，不成功再排队，从而达到不排队直接抢占的目的。</li><li><strong>而对于公平锁</strong>：则是老老实实的开始就走AQS的流程排队获取锁。如果前面有人调用过其lock方法，则排在队列中前面，也就更有机会更早的获取锁，从而达到“公平”的目的。</li></ul><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享功能的主要实现为CountDownLatch，CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的时间都已经发生。如果计数器值非零，那么await会一直阻塞直到计数器为零，或者等待线程中断，或者等待超时。</p><h3 id="等待获取共享锁的流程分析"><a href="#等待获取共享锁的流程分析" class="headerlink" title="等待获取共享锁的流程分析"></a>等待获取共享锁的流程分析</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/image/thread/CountDownLatch%E8%8E%B7%E5%8F%96%E5%85%B1%E4%BA%AB%E9%94%81%E6%B5%81%E7%A8%8B.svg" alt="image"></p><ol><li><p>CountDownLatch的<code>await()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>CountDownLatch的await()方法不会只在一个线程中调用，多个线程可以同时等待<code>await()</code>方法返回，所以CountDownLatch被设计成实现<code>tryAcquireShared()</code>方法，获取的是一个共享锁，锁在所有调用<code>await()</code>方法的线程间共享，所以叫做共享锁。</p></li><li><p>AQS的<code>acquireSharedInterruptibly()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="comment">/*用于响应线程中断，</span></div><div class="line">    * 在前两行会检查线程是否被打断</div><div class="line">    * */</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="comment">/*返回了-1，说明state不为0，也就是CountDownLatch的计数器还不为0*/</span></div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">/*尝试获取共享锁，如果小于0，表示获取失败*/</span></div><div class="line">        doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Sync的<code>tryAcquireShared()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>AQS的<code>doAcquireSharedInterruptibly()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="comment">/*将当前线程包装为一个共享节点*/</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="comment">//如果新建节点的前一个节点，就是Head，</span></div><div class="line">                <span class="comment">//说明当前节点是AQS队列中等待获取锁的第一个节点，</span></div><div class="line">                <span class="comment">//按照FIFO的原则，可以直接尝试获取锁。</span></div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">                    <span class="comment">/*如果获取成功，则需要将当前节点设置为AQS队列中的第一个节点*/</span></div><div class="line">                    <span class="comment">/*队列的头节点表示正在获取锁的节点*/</span></div><div class="line">                    setHeadAndPropagate(node, r);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//检查下是否需要将当前节点挂起</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="获得共享锁的流程分析"><a href="#获得共享锁的流程分析" class="headerlink" title="获得共享锁的流程分析"></a>获得共享锁的流程分析</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/image/thread/CountDownLatch%E9%87%8A%E6%94%BE%E5%85%B1%E4%BA%AB%E9%94%81%E6%B5%81%E7%A8%8B.svg" alt="image"></p><ol><li><p>AQS的<code>releaseShared()</code>方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">        doReleaseShared();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">        doReleaseShared();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">    <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>死循环更新state的值，实现state的减1操作，之所以用死循环是为了确保state值的更新成功。</p><p>从上文的分析中可知，如果state的值为0，在CountDownLatch中意味：所有的子线程已经执行完毕，这个时候可以唤醒调用<code>await()</code>方法的线程了，而这些线程正在AQS的队列中，并被挂起的，所以下一步应该去唤醒AQS队列中的头节点了（AQS的队列为FIFO队列），然后由头节点去依次唤醒AQS队列中的其他共享节点。</p></li><li><p>AQS的<code>doReleaseShared()</code>方法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void doReleaseShared() &#123;</div><div class="line">    for (; ; ) &#123;</div><div class="line">        Node h = head;</div><div class="line">        if (h != null &amp;&amp; h != tail) &#123;</div><div class="line">            int ws = h.waitStatus;</div><div class="line">            if (ws == Node.SIGNAL) &#123;</div><div class="line">                //如果当前节点是SIGNAL意味着，它正在等待一个信号。或者说，它在等待被唤醒，因此做两件事</div><div class="line">                /*重置waitStatus标志位，如果失败则重试*/</div><div class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div class="line">                    continue;            // loop to recheck cases</div><div class="line"></div><div class="line">                /*重置成功后,唤醒等待获取共享锁的第一个节点*/</div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div class="line">                //如果本身头节点的waitStatus是处于重置状态（waitStatus==0）的，将其设置为“传播”状态。</div><div class="line">                //意味着需要将状态向后一个节点传播。</div><div class="line">                continue;                // loop on failed CAS</div><div class="line">        &#125;</div><div class="line">        if (h == head)                   // loop if head changed</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>当FIFO队列中等待共享锁的第一个节点被头结点唤醒之后，会返回到到节点对应线程的<code>doAcquireSharedInterruptibly()</code>方法中，并继续循环，这时候当前节点的前驱节点正好时头结点，并且能够获得共享锁，这时会执行<code>setHeadAndPropagate()</code>方法，将当前节点设置为头结点，并继续唤醒下一个节点。</p></li><li><p>AQS的<code>setHeadAndPropagate()</code>方法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</div><div class="line">    Node h = head; // Record old head for check below</div><div class="line">    setHead(node);</div><div class="line"></div><div class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</div><div class="line">            (h = head) == null || h.waitStatus &lt; 0) &#123;</div><div class="line">        Node s = node.next;</div><div class="line">        if (s == null || s.isShared())</div><div class="line">            doReleaseShared();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先，使用CAS更换了头结点，然后，将当前节点的下一个节点取出来。如果下一个节点同样是shared类型，再做一个<code>releaseShared()</code>操作。这时可以回到第二步，依次唤醒AQS队列中其他共享节点。</p></li></ol><p>总而言之，<strong>AQS关于共享锁方面的实现方式</strong>：如果获取共享锁失败后，将请求共享锁的线程封装成Node对象放入AQS的队列中，并挂起Node对象对应的线程，实现请求锁线程的等待操作。待共享锁可以被获取后，从头节点开始，依次唤醒头节点及其以后的所有共享类型的节点。实现共享状态的传播。</p><h2 id="共享锁与独占锁的对比"><a href="#共享锁与独占锁的对比" class="headerlink" title="共享锁与独占锁的对比"></a>共享锁与独占锁的对比</h2><ol><li>与AQS的独占功能一样，共享锁是否可以被获取的<strong>判断为空方法</strong>，交由子类去实现。</li><li>与AQS的独占功能不同，当锁被头节点获取后，独占功能是只有头节点获取锁，其余节点的线程继续沉睡，等待锁被释放后，才会唤醒下一个节点的线程，而共享功能是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒AQS队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“<strong>向后传播</strong>”，从而实现共享功能。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="external">深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）</a></li><li><a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer" target="_blank" rel="external">深度解析Java 8：AbstractQueuedSynchronizer的实现分析（下）</a></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      通过其具体实现类ReentrantLock（独占锁）和CountDownLatch（共享锁）的原理来分析AQS内部实现。
    
    </summary>
    
      <category term="java" scheme="http://www.vibrancy.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.vibrancy.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="同步" scheme="http://www.vibrancy.cn/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="锁" scheme="http://www.vibrancy.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop中的远程过程调用</title>
    <link href="http://www.vibrancy.cn/repository/hadoop-rpc.html"/>
    <id>http://www.vibrancy.cn/repository/hadoop-rpc.html</id>
    <published>2017-06-19T05:03:50.000Z</published>
    <updated>2017-06-19T07:31:44.562Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="远程过程调用RPC"><a href="#远程过程调用RPC" class="headerlink" title="远程过程调用RPC"></a>远程过程调用RPC</h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC就是允许程序<strong>调用位于其它机器上的过程</strong>（或者同一台机器的不同进程），主要功能目标是让构建分布式计算（应用）更容易，使两个进程间能够基于<strong>传统过程调用中的控制流模型</strong>来进行交互，在提供强大的远程调用能力时不损失<strong>本地调用的语义简洁性</strong>。</p><h3 id="RPC的具体执行流程"><a href="#RPC的具体执行流程" class="headerlink" title="RPC的具体执行流程"></a>RPC的具体执行流程</h3><p><img src="http://image18-c.poco.cn/mypoco/myphoto/20170411/09/18510550620170411095052030_640.jpg?544x397_130" alt="image"></p><ol><li>当客户端调用<code>remoteF()</code>后，<strong>客户端存根</strong>只是简单的将参数打包成一个消息，并请求将此消息发送到服务器，然后<strong>客户端存根</strong>通过调用<code>receive()</code>方法，随即阻塞自己，直到收到响应消息。</li><li><strong>服务器骨架</strong>先调用<code>receive()</code>，然后阻塞，等待消息输入。</li><li><strong>服务器骨架</strong>收到消息后，先将<strong>参数</strong>从消息中提取出来，然后以常规的方式调用服务器上的相应方法<code>removeF()</code>。</li><li>服务器本地的<code>removeF()</code>执行完后，将结果返回到<strong>服务器骨架</strong>，由骨架打包成消息返回给<strong>客户端存根</strong>，接着<strong>服务器骨架</strong>再次调用<code>receive()</code>，等待下一条消息。</li><li><strong>客户端存根</strong>收到消息后，<strong>检查消息并解包返回参数</strong>，通过return将结果传递到客户端。</li><li>客户端调用者在<code>remoteF()</code>结束后重新获得控制权，它唯一知道的就是已经获得了结果数据，但并不清楚操作是本地方法进行的还是远程完成的。</li></ol><h3 id="RPC的优点"><a href="#RPC的优点" class="headerlink" title="RPC的优点"></a>RPC的优点</h3><p>客户端可以简单地忽略不需要关心的内容，只需要调用一个普通的、本地的过程，就可以访问远程服务，不需要<strong>调用send或receive这些底层操作</strong>，所有的消息传递细节都<strong>隐藏在RPC的库过程</strong>中，就如同传统库中隐藏了执行实际系统调用细节一样。</p><h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p>动态代理的用途是在不改变已有代码结构的情况下增强或控制对象的行为，也叫作<strong>横切面编程</strong>。</p><h3 id="Proxy类介绍"><a href="#Proxy类介绍" class="headerlink" title="Proxy类介绍"></a>Proxy类介绍</h3><p><code>java.lang.reflect.Proxy</code> 类提供用于创建<strong>动态代理类</strong>和实例的静态方法，她还是由这些方法创建的所有动态代理类的<strong>超类</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) <span class="keyword">throws</span> IllegalArgumentException&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;&#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li><code>getProxyClass()</code>方法用于获得<strong>代理类</strong>的<code>java.lang.Class</code>对象，该代理类将定义在指定的<strong>类加载器中</strong>，并实现参数<code>interfaces</code>所指定的所有接口。获得的代理类都包含一个构造函数，用于初始化<code>java.lang.reflect.InvocationHandler</code>实例；</li><li><code>newProxyInstance()</code>方法用于返回一个或多个指定接口的代理类实例，在该接口方法上的调用，将指派到调用处理器（InvocationHandler）上；</li><li><code>isProxyClass()</code>方法判断某个Class对象是否为代理类；</li><li><code>getInvocationHandler()</code>方法用于获取代理实例对应的调用处理器。</li></ol><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * <span class="doctag">@param</span> proxy 代理对象本身</div><div class="line">    * <span class="doctag">@param</span> method 用户调用的代理对象上的方法</div><div class="line">    * <span class="doctag">@param</span> args 传递给该方法的参数</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>InvocationHandler实例也叫<strong>调用句柄实例</strong>，它是一个接口，只有一个<code>invoke()</code>方法，当用户调用<code>newProxyInstance()</code>返回的代理对象上的方法时，代理对象将方法调用转发给调用句柄实例，即调用<code>InvocationHandler.invoke()</code>方法。</p><h3 id="典型的动态代理创建对象过程"><a href="#典型的动态代理创建对象过程" class="headerlink" title="典型的动态代理创建对象过程"></a>典型的动态代理创建对象过程</h3><ol><li><p>通过实现InvocationHandler接口创建自己的调用处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>通过为Proxy类指定ClassLoader对象和一组interfaces创建<strong>动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; subjectProxyClass = getProxyClass0(classLoader, interfaces);</div></pre></td></tr></table></figure></li><li><p>通过反射机制获取<strong>动态代理类</strong>的构造函数，其参数类型是<strong>调用处理器接口类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Constructor&lt;?&gt; cons = subjectProxyClass.getConstructor(<span class="keyword">new</span> Class[]&#123;InvocationHandler.class&#125;);</div></pre></td></tr></table></figure></li><li><p>通过构造函数创建<strong>代理类实例</strong>，此时需将调用处理器对象作为参数被传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Subject subject = (Subject)constructor.newInstance(<span class="keyword">new</span> Object[] &#123;subjectProxyHandler&#125;);</div></pre></td></tr></table></figure></li></ol><h3 id="动态代理调用过程时序图"><a href="#动态代理调用过程时序图" class="headerlink" title="动态代理调用过程时序图"></a>动态代理调用过程时序图</h3><p><img src="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/Dynamic%20Proxy%20invoke%20process.svg" alt=""></p><h3 id="典型动态代理简单实例"><a href="#典型动态代理简单实例" class="headerlink" title="典型动态代理简单实例"></a>典型动态代理简单实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"call doSomething()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject subject;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxyHandler</span><span class="params">(Subject subject)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subject = subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//在转调具体目标对象之前，可以执行一些功能处理</span></div><div class="line">        System.out.println(<span class="string">"前置通知"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//转调具体目标对象的方法</span></div><div class="line">        Object result = method.invoke(subject, args);</div><div class="line"></div><div class="line">        <span class="comment">//在转调具体目标对象之后，可以执行一些功能处理</span></div><div class="line">        System.out.println(<span class="string">"后置通知"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectDynamicProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createProxyClassFile</span><span class="params">()</span> </span>&#123;</div><div class="line">        String name = <span class="string">"ProxySubject"</span>;</div><div class="line">        <span class="keyword">byte</span>[] data = ProxyGenerator.generateProxyClass(name, <span class="keyword">new</span> Class[]&#123;Subject.class&#125;);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(name + <span class="string">".class"</span>);</div><div class="line">            out.write(data);</div><div class="line">            out.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxyInstance</span><span class="params">(Subject subject)</span> </span>&#123;</div><div class="line">        ClassLoader classLoader = subject.getClass().getClassLoader();</div><div class="line"></div><div class="line">        Class&lt;?&gt;[] interfaces = subject.getClass().getInterfaces();</div><div class="line"></div><div class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> SubjectProxyHandler(subject);</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Subject proxySubject = SubjectDynamicProxy.getProxyInstance(<span class="keyword">new</span> RealSubject());</div><div class="line">        proxySubject.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>非阻塞是NIO实现的重要功能之一，为了实现非阻塞，NIO引入了选择器（Selector）和通道（Channel）的概念。通道表示实体，如设备、文件等程序组件的开放连接。</p><h3 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h3><p>NIO中一个主要的特性是<code>java.nio.Bufer</code>，缓冲区（Buffer）提供了一个比流抽象的、更高效的和可预测的I/O。Buffer代表了一个有限容量的容器——本质是一个数组，通道Channel使用Buffer实例来传递数据。</p><p>流和通道的区别在于流是基于字节的，而通道是基于块的。</p><ol><li><p>Buffer索引介绍</p><ul><li><strong>capacity</strong>：缓冲区元素的总数，通过capacity()获取，该总数不可修改；</li><li><strong>position</strong>：缓冲区的位置，是下一个要读取或写入元素的索引，该位置可以由position()方法和position(int)方法获得。</li><li><strong>limit</strong>：缓冲区的限制，即第一个不应该读取或写入的元素的索引，limit()方法用于获取元素限制索引，limit(int)方法用于设置缓冲区的限制。</li><li><p><strong>mark</strong>：缓冲区的位置设置标记，通过mark()方法设置一个位置，然后利用reset()方法将position重置为mark()标记的位置。</p><p>以上四个索引遵循的不变式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</div></pre></td></tr></table></figure></li></ul></li><li><p>Buffer主要方法介绍</p><ul><li><strong>allocate()</strong>：用于直接创建缓冲区(position=0, limit=capacity)。</li><li><strong>wrap()</strong>：用于在某个字节数组上创建缓冲区，对该数组的修改，都将改变缓冲区的数据(position=offset, limit = offset+length)。</li><li><strong>get()/put()</strong>：返回基于目前缓冲区position位置的当前值，从下一个位置读取或存放数据，并为执行position++操作。</li><li><strong>get(int)/put(int)</strong>：基于绝对位置的，必须提供写入/读出的位置，该方式的读写操作不改变position的值。</li><li><strong>clear()</strong>：用于清空缓冲区，将position设为0，limit设置为capacity，但是buffer数组中的数据还存在。</li><li><strong>flip()</strong>：将<strong>写模式</strong>转为<strong>读模式</strong>，该方法将limit设置为position后，将position设为0。后续的<code>get()/write()</code>方法将从缓冲区的第一个元素开始传出数据，直到位于limit位置。</li><li><strong>compact()</strong>：将<strong>读模式</strong>转为<strong>写模式</strong>，当缓冲区还有未写出的数据时，为读入数据准备空间。在write()方法调用后和添加新数据的read()方法前调用compact()方法，将未写出的“剩余”数据移动到缓冲区前面，为后面的read()方法提供空间。</li><li><strong>rewind()</strong>：用于需要多次读取缓冲区里的数据，将position设为0，但不改变limit的值。</li><li>使用缓冲区读取数据的时候，必须先确认缓冲区的position、limit处于正确的位置。</li><li><p>clear()，flip()，rewind()，compact()方法对索引position、limit的影响：</p><p><img src="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/buffer%20%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="image"></p></li></ul></li></ol><h3 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h3><p>Channel实例代表一个和设备的连接，通过它可以进行输入输出操作。</p><p>Channel对于TCP协议来说，有ServerSocketChannel和SocketChannel，针对其他设备还有其他类型的Channel，如文件设备FileChannel。</p><ol><li><p>创建通道</p><p>ServerSocketChannel 和 SocketChannel 通过工厂方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><p>SocketChannel创建后，通过connect()连接到远程机器，通过close()关闭连接。</p></li><li><p>建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlocking</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><p>非阻塞式SocketChannel和阻塞时Channel有些不同，如非阻塞的SocketChannel的connect()方法会立即返回，用户必须通过isConnected()判断连接是否已经建立，或者通过finishConnect()方法在非阻塞套接字上<strong>阻塞等待</strong>连接成功；</p><p>非阻塞的read()，在Socket上没有数据的时候，立即返回（0），不会等待。</p><p>非阻塞的accept()，如果没有等待的连接，将返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></li><li><p>读写数据</p><p>SocketChannel 在读写数据的时候，使用Buffer作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dests)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span></span>;</div></pre></td></tr></table></figure></li></ol><pre><code>ServerSocketChannel提供了accept()方法、close()等方法，accept()方法返回一个SocketChannel对象。ServerSocketChannel不提供bind()方法，绑定socket到某端口需要使用底层的bind，即`serverChannel.socket().bind(port)`
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> ServerSocket <span class="title">socket</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
</code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>在任何时刻，服务器只有少量的请求需要处理，这就需要一种方法阻塞等待，直到至少一个Channel可以进行IO操作，并指出是哪个通道。NIO的选择器就是为这个功能设计的，一个Selector实例可以同时检查一组通道的IO状态。</p><ol><li><p>选择器的使用方法</p><ul><li><p>通过静态工厂方法创建Selector实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></li><li><p>通过Channel的注册方法，将Selector实例注册到想要监控的Channel上；</p></li><li>调用选择器的<code>select()</code>方法，该方法会阻塞等待，直到有一个或多个通道准备好IO操作或者超时。<code>select()</code>方法会返回可操作IO的数量。在一个单独的线程中，就可以检查多个通道是否可以进行IO操作，不需要为每一个通道准备一个线程。</li></ul></li><li><p>选择器与通道事件的关联</p><p>选择器与通道的关联是多对多的关联，关联信息保存在<code>java.nio.channels.SelectionKey</code>实例中。选择器注册标记SelectionKey维护了一个通道上感兴趣的事件类型信息，包括4种类型：</p><ul><li>OP_READ(通道上有数据可读)</li><li>OP_WRITE(通道已经可写)</li><li>OP_CONNECT(通道连接已建立)</li><li><p>OP_ACCEPT(通道上有连接请求)</p><p>以上类型都保存在SelectionKey实例中，通过interestOps()方法获取和设置这些标志位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interestOps</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Hadoop的远程过程调用"><a href="#Hadoop的远程过程调用" class="headerlink" title="Hadoop的远程过程调用"></a>Hadoop的远程过程调用</h2><p>Hadoop自己实现了一条独有的节点间通信机制，理由是和Hadoop使用Writabl形式的序列化机制有关，有效的IPC（Inter-Process Communication）对于Hadoop来书至关重要，Hadoop需要精确控制进程间通信中比如连接、超时、缓存等通信细节。</p><h3 id="基于Hadoop-RPC的简易图书查询"><a href="#基于Hadoop-RPC的简易图书查询" class="headerlink" title="基于Hadoop RPC的简易图书查询"></a>基于Hadoop RPC的简易图书查询</h3><ol><li><p>UML类图</p><p><img src="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/%E5%9F%BA%E4%BA%8EHadoop%20RPC%E7%9A%84%E5%9B%BE%E4%B9%A6%E6%9F%A5%E8%AF%A2.svg" alt=""></p><ul><li><strong>Library</strong>：定义了IPC服务器对外提供的功能，使用Book作为queryBook()方法的返回值。</li><li><strong>LibraryImpl</strong>：实现了接口中定义的功能，BookQueryServer利用LibraryImpl的实例，构造并运行IPC服务器。</li><li><strong>BookQueryClient</strong>：作为客户端，使用IPC访问服务器提供的 Library 查询书的功能。</li></ul></li><li><p>代码实现</p><ul><li><p>定义一个IPC协议接口 Library</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Library</span> <span class="keyword">extends</span> <span class="title">VersionedProtocol</span> </span>&#123;</div><div class="line">    <span class="function">Book <span class="title">queryBook</span><span class="params">(String bookName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Hadoop远程调用中，Hadoop IPC接口必须继承自<code>org.apache.hadoop.ipc.VersionedProtocol</code>，该接口输入参数是<strong>协议接口的类名</strong>和<strong>客户端的版本号</strong>，返回了服务器的协议接口版本号，用于验证客户端与服务器的版本是否一致。</p></li><li><p>IPC协议接口 Library实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LibraryImpl</span> <span class="keyword">implements</span> <span class="title">Library</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">queryBook</span><span class="params">(String bookName)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(bookName, <span class="string">"落枫寒"</span>, <span class="number">23</span>);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getProtocolVersion</span><span class="params">(String protocol, <span class="keyword">long</span> clientVersion)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            System.out.println(protocol);</div><div class="line">            <span class="keyword">return</span> BookQueryServer.IPC_VER;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ```  </div><div class="line"></div><div class="line">* 定义IPC接口的返回值类型，该返回值类型必须是Writable类型</div><div class="line">    ```java</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> Text author;</div><div class="line">        <span class="keyword">private</span> Text bookName;</div><div class="line">        <span class="keyword">private</span> IntWritable price;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</div><div class="line">            author = <span class="keyword">new</span> Text();</div><div class="line">            bookName = <span class="keyword">new</span> Text();</div><div class="line">            price = <span class="keyword">new</span> IntWritable();</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String bookName, String author, <span class="keyword">int</span> price)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.author = <span class="keyword">new</span> Text(author);</div><div class="line">            <span class="keyword">this</span>.bookName = <span class="keyword">new</span> Text(bookName);</div><div class="line">            <span class="keyword">this</span>.price = <span class="keyword">new</span> IntWritable(price);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(Text author)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.author = author;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> Text <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> bookName;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">            Book book = (Book) o;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (author != <span class="keyword">null</span> ? !author.equals(book.author) : book.author != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (bookName != <span class="keyword">null</span> ? !bookName.equals(book.bookName) : book.bookName != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> price != <span class="keyword">null</span> ? price.equals(book.price) : book.price == <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> result = author != <span class="keyword">null</span> ? author.hashCode() : <span class="number">0</span>;</div><div class="line">            result = <span class="number">31</span> * result + (bookName != <span class="keyword">null</span> ? bookName.hashCode() : <span class="number">0</span>);</div><div class="line">            result = <span class="number">31</span> * result + (price != <span class="keyword">null</span> ? price.hashCode() : <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</div><div class="line">                    <span class="string">"author="</span> + author +</div><div class="line">                    <span class="string">", bookName="</span> + bookName +</div><div class="line">                    <span class="string">", price="</span> + price +</div><div class="line">                    <span class="string">'&#125;'</span>;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            author.write(out);</div><div class="line">            bookName.write(out);</div><div class="line">            price.write(out);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            author.readFields(in);</div><div class="line">            bookName.readFields(in);</div><div class="line">            price.readFields(in);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ```    </div><div class="line"></div><div class="line">* 构建IPC服务器</div><div class="line"></div><div class="line">    ```java</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookQueryServer</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUERY_PORT = <span class="number">33121</span>;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> IPC_VER = <span class="number">5473L</span>;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Library library = <span class="keyword">new</span> LibraryImpl();</div><div class="line">    </div><div class="line">                Server server = RPC.getServer(library, <span class="string">"0.0.0.0"</span>, QUERY_PORT, <span class="keyword">new</span> Configuration());</div><div class="line">                server.start();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>    * 通过RPC静态方法getServer()，通过传入IPC接口的实例，监听地址、端口和配置类，就可以建立服务器。
    * &quot;0.0.0.0&quot;表示在所有的地址上监听。    

* 访问IPC服务器的客户端代码
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookQueryClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, BookQueryServer.QUERY_PORT);</div><div class="line">        Library query = (Library) RPC.getProxy(Library.class, BookQueryServer.IPC_VER, address, <span class="keyword">new</span> Configuration());</div><div class="line"></div><div class="line">        Book book = query.queryBook(<span class="string">"Hadoop权威指南"</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"查到的书为："</span> + book.toString());</div><div class="line"></div><div class="line">        RPC.stopProxy(query);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

    通过调用RPC.getProxy()获得一个IPC客户端接口的代理实例，通过这个实例对象进行远程过程调用，调用会转发到服务器执行。
</code></pre><h3 id="Hadoop-IPC的代码结构"><a href="#Hadoop-IPC的代码结构" class="headerlink" title="Hadoop IPC的代码结构"></a>Hadoop IPC的代码结构</h3><p>org.apache.hadoop.ipc包下的类介绍:</p><ol><li><strong>RemoteException</strong>：远程异常，应用于IPC客户端，表示远程过程调用中的错误。</li><li><strong>Status</strong>：是一个枚举类，定义了远程过程调用的返回结果状态，包括SUCCESS、ERROR和FATAL三种情况。</li><li><strong>VersionedProtocol</strong>：Hadoop IPC的远程接口都扩展自VersionedProtocol。</li><li><strong>ConnectionHeader</strong>：IPC客户端与服务器建立连接时发送的<strong>消息头</strong>。</li><li><strong>Client</strong>：是对IPC客户的抽象，它包含的内部类可分为，IPC连接相关的（Client.Connection和Client.ConnectionId），远程调用相关的（Client.Call、Client.ParallecCall）等。</li><li><strong>Server</strong>：实现了一个IPC服务器的抽象，它包含的内部类可分为，IPC连接相关的（Server.Connection和Server.Call），而对远程调用Call处理是由Listener、Handler和Responder配合完成，他们都继承自Thread，在各自的线程中完成。</li><li><strong>RPC</strong>：在Client和Server的基础上实现了Hadoop IPC，其功能主要分为两个部分：<ul><li>与客户端相关的功能包括RPC.ClientCache、RPC.Invocker和RPC.Invocation，其中RPC.Invocker继承自InvocationHandler。</li><li>与服务器相关的内部类只有RPC.Server，它是IPC服务器抽象类（Server）的一个子类。</li></ul></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      主要介绍了Hadoop RPC的实现，包括远程过程调用的基础知识、Java动态代理、NIO和Hadoop RPC的具体实现。
    
    </summary>
    
      <category term="hadoop" scheme="http://www.vibrancy.cn/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.vibrancy.cn/tags/hadoop/"/>
    
      <category term="rpc" scheme="http://www.vibrancy.cn/tags/rpc/"/>
    
      <category term="动态代理" scheme="http://www.vibrancy.cn/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="NIO" scheme="http://www.vibrancy.cn/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>多线程知识自查表——结构化并发应用程序</title>
    <link href="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-structured-concurrent-application.html"/>
    <id>http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-structured-concurrent-application.html</id>
    <published>2017-06-18T07:52:48.000Z</published>
    <updated>2017-06-18T09:03:27.129Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="为什么要创建线程"><a href="#为什么要创建线程" class="headerlink" title="为什么要创建线程"></a>为什么要创建线程</h2><p>例如在Web服务器中，在正常负载情况下，为每个任务分配一个线程，能够提升串行执行条件下的性能。只要请求的到达率不超出服务器的请求处理能力，那么这种方法可以同时带来<strong>更快的响应性</strong>和<strong>更高的吞吐率</strong>。</p><h2 id="为什么不能无限制创建线程"><a href="#为什么不能无限制创建线程" class="headerlink" title="为什么不能无限制创建线程"></a>为什么不能无限制创建线程</h2><ol><li><p>线程的生命周期的开销非常高</p><p>如果请求的到达速率非常高，且请求的处理过程是轻量级的，那么为每个请求创建一个新线程将消耗大量的计算资源。</p></li><li><p>资源消耗</p><p>如果可运行的线程数量<strong>多于可用处理器的数量</strong>，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。</p><p>如果已经有了足够多的线程，使所有CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。</p></li><li><p>稳定性</p><p>在可创建线程的<strong>数量上存在一个限制</strong>，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括<strong>JVM的启动参数</strong>、Thread构造函数中<strong>请求栈的大小</strong>，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出<strong>OutOfMemoryError异常</strong>。</p></li></ol><h2 id="简介Executor接口"><a href="#简介Executor接口" class="headerlink" title="简介Executor接口"></a>简介Executor接口</h2><p>Executor是一个简单的接口，它能够将<strong>任务提交</strong>与<strong>执行策略</strong>解耦开来，同时还支持多种不同类型的执行策略，并用Runnable来表示一个任务。通过将问题分解为多个独立的任务并发执行时，能够获得更高的<strong>CPU利用率</strong>和<strong>响应灵敏度</strong>。</p><p>Executor的实现还提供了生命周期的支持，以及统计信息的收集、应用程序管理机制和性能监视等机制。</p><p>Executor是基于<strong>生产者——消费者模式</strong>，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</p><h2 id="Executor的执行策略"><a href="#Executor的执行策略" class="headerlink" title="Executor的执行策略"></a>Executor的执行策略</h2><p>在执行策略中定义了任务执行的“What”、“Where”、“When”、“How”等方面，包括：</p><ol><li>在什么（What）线程中执行任务？</li><li>任务按照什么（What）顺序执行（FIFO、LIFO、优先级）？</li><li>有多少个（How Many）任务能够并发执行？</li><li>在队列中有多少个（How Many）任务在等待执行？</li><li>如果系统过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？</li><li>在执行一个任务之前或之后，应该进行哪些（What）动作？</li></ol><p>因此，各种执行策略都是一种资源管理工具，最佳策略取决于<strong>可用的计算资源</strong>以及<strong>对服务质量的需求</strong>。</p><p>通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源上竞争而严重影响性能。</p><p>通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。</p><p>因此，当看到如下代码时<code>new Thread(runnable).start();</code>时。如果希望获得一种更灵活的执行策略时，考虑使用Executor来代替Thread。</p><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>线程池，是指管理<strong>一组同构工作</strong>线程的资源池。线程池是与工作队列密切相关的，工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并执行下一个任务。</p><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ol><li>通过<strong>重用现有的线程</strong>而不是创建新线程，可以在处理多个请求时<strong>分摊</strong>在线程创建和销毁过程中产生的<strong>巨大开销</strong>。</li><li>当请求到达时，工作线程已经存在，因此不会由于等待创建线程而延迟任务的执行，从而<strong>提高了响应性</strong>。</li><li>通过适当调整线程池大小，可以创建足够多的线程以便使<strong>处理器保持忙碌状态</strong>，同时还可以<strong>防止</strong>过多线程相互竞争资源而使应用程序<strong>耗尽内存或失败</strong>。</li></ol><h2 id="创建线程池的方法"><a href="#创建线程池的方法" class="headerlink" title="创建线程池的方法"></a>创建线程池的方法</h2><ol><li><strong>newFixedThreadPool</strong>：用于创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池最大数量，这时线程数量不再变化。</li><li><strong>newCachedThreadPool</strong>：用于创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求，那么将<strong>回收空闲的线程</strong>，而当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。</li><li><strong>newSingleThreadExecutor</strong>：是一个单线程的Executor，可创建单个工作者线程来执行任务，如果这个线程异常结束，能够创建另一个线程来替代。并且能够确保任务在队列中的顺序串行执行（例如FIFO、LIFO、优先级）。</li><li><strong>newScheduledThreadPool</strong>：创建一个固定长度的线程池，而且以<strong>延迟或定时</strong>的方式来执行任务，类似于Timer。</li></ol><h2 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h2><p>Executor的实现通常会创建线程来执行任务，而JVM只有在所有（非守护）线程全部终止后才会退出。因此，如果无法正确的关闭Executor那么<strong>JVM将无法结束</strong>。</p><p>由于Executor以异步的方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他任务可能在队列中等待执行。因此，当关闭程序时，可能采用最<strong>平缓的</strong>关闭方式（完成所有已经启动的任务，并且不再接受新任务），也可能采用<strong>最粗暴</strong>的关闭形式（直接关掉机房的电源），以及其他各种可能的形式。</p><p>为了解决执行服务的生命周期问题，Executor扩展了<strong>ExecutorService接口</strong>，添加了生命周期管理的方法:</p><ul><li><strong>shutdown()方法</strong>用于执行平缓关闭的过程，不再继续接受新的任务，同时等待已经提交的任务执行完成——包括那些还未执行的任务。</li><li><strong>shutdownNow()方法</strong>将执行粗暴的关闭过程：尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</li></ul><p>在ExecutorService关闭后提交的任务将由“<strong>拒绝执行处理器</strong>”来处理，它将抛弃任务。或使得execute方法抛出一个未检查的RejectedExecutionException。等所有任务都执行完后，ExecutorService将进入<strong>终止状态</strong>。</p><p>可以调用<code>awaitTermination()</code>来等待ExecutorService到达终止状态，或者通过调用<code>isTerminated()</code>来轮询ExecutorService是否已经终止。通常在调用<code>shutdown()</code>后会立即调用<code>awaitTermination()</code>，从而产生同步关闭ExecutorService的效果。</p><h2 id="使用Timer实现延迟任务或周期任务的缺点"><a href="#使用Timer实现延迟任务或周期任务的缺点" class="headerlink" title="使用Timer实现延迟任务或周期任务的缺点"></a>使用Timer实现延迟任务或周期任务的缺点</h2><p>Timer类负责管理延迟任务以及周期任务，Timer在执行所有定时任务时只会创建一个线程，如果某个任务的执行时间过长，那么将破坏其他的TimeTask的定时精确性。</p><p>另一个问题，因为Timer线程不会捕获异常，那么当TimerTask抛出未检查的异常时将终止定时线程。Timer也不会恢复线程的执行，而是错误的认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度。</p><p>线程池能够弥补这个缺陷，因此应该考虑使用<strong>ScheduledThreadPoolExecutor</strong>的构造函数或者<strong>newScheduledThreadPool工厂方法</strong>来创建该类的对象，可以提供多个线程来执行<strong>延时任务</strong>和<strong>周期任务</strong>。</p><h2 id="谈谈对Callable与Future的理解"><a href="#谈谈对Callable与Future的理解" class="headerlink" title="谈谈对Callable与Future的理解"></a>谈谈对Callable与Future的理解</h2><p>Executor使用Runnable作为<strong>基本任务</strong>表示形式，但Runnable有一个很大的局限性，不能返回一个值或者抛出一个受检查的异常。而Callable是一个中更好的抽象，能够返回一个值，并可能抛出一个异常。</p><p>Runnable和Callable描述的都是抽象的计算任务，这些任务都是有范围的，都有一个明确的起点，并且最终会结束。</p><p>Future表示一个<strong>任务的生命周期</strong>，并提供相应的方法来判断是否<strong>已经完成</strong>或<strong>取消</strong>，以及<strong>获取任务的结果</strong>和<strong>取消任务</strong>等。可以通过许多种方法来创建一个Future来描述任务，ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的<strong>执行结果或取消任务</strong>。</p><p>Future.get()的行为<strong>取决于任务的状态</strong>（尚未开始、正在运行、已完成）</p><ul><li>如果任务已经完成，那么get会立即返回结果或抛出一个异常。</li><li>如果任务没有完成，那么get将阻塞并直到任务完成。</li><li>如果任务抛出异常，那么get将该异常封装为ExecutionException并重新抛出；</li><li>如果任务被取消，那么get将抛出CancellationException。</li><li>如果get抛出了ExecutionException，那么可以通过getCause来获得被封装的初始异常。</li></ul><p>另外，get方法拥有“<strong>状态依赖</strong>”的内在特性，因而调用者不需要知道任务的状态，此外在任务提交和获得结果中包含的安全发布属性也确保了这个方法是线程安全的.</p><h2 id="什么是任务取消，以及有哪些操作会取消任务"><a href="#什么是任务取消，以及有哪些操作会取消任务" class="headerlink" title="什么是任务取消，以及有哪些操作会取消任务"></a>什么是任务取消，以及有哪些操作会取消任务</h2><p>如果外部代码能在某个正常完成之前将其置入“完成”状态，那么这个操作就可以称为<strong>可取消的</strong>（Cancellable）,而取消一个操作的原因很多：</p><ol><li>用户请求取消；</li><li>有时间限制的操作；</li><li>应用程序事件；</li><li>错误；</li><li>关闭。</li></ol><h2 id="线程池中哪个阶段的任务可以取消"><a href="#线程池中哪个阶段的任务可以取消" class="headerlink" title="线程池中哪个阶段的任务可以取消"></a>线程池中哪个阶段的任务可以取消</h2><p>Executor执行的任务有4个生命周期阶段：创建、提交、开始和完成。Executor框架中，<strong>已提交但尚未开始</strong>的任务可以取消，但对于那些已经开始执行的任务，只有当他们能响应中断时，才能取消。已完成的任务不用取消。</p><h2 id="什么是任务取消策略"><a href="#什么是任务取消策略" class="headerlink" title="什么是任务取消策略"></a>什么是任务取消策略</h2><p>一个可取消的任务必须有<strong>取消策略</strong>（Cancellation Policy），在这个策略中将详细地定义取消操作的“How”、“When”和“What”，即</p><ul><li>其他代码<strong>如何</strong>（How）请求取消该任务；</li><li>任务在<strong>何时</strong>（When）检查是否已经请求了取消；</li><li>在响应取消请求时应该执行<strong>哪些</strong>（What）操作。</li></ul><h2 id="什么是线程中断，以及用途"><a href="#什么是线程中断，以及用途" class="headerlink" title="什么是线程中断，以及用途"></a>什么是线程中断，以及用途</h2><p>为某个任务设置<strong>已请求取消</strong>的标志，当任务下次检测到该标志后，从而使任务能够顺利的退出。然而，如果任务调用了一个<strong>阻塞方法</strong>，例如<code>BlockingQueue.put</code>，那么任务可能永远不会检查取消标志，因此永远不会结束。</p><p>Thread提供了一些<strong>中断线程</strong>以及<strong>查询线程中断状态</strong>的方法，每个线程都有一个boolean类型的中断状态。当需要中断线程时，调用<code>interrupt()</code>将这个线程的<strong>中断状态</strong>设置为true。然而，调用<code>interrupt()</code>并不意味着<strong>立即停止</strong>目标线程正在进行的工作，而只是传递了<strong>请求中断的消息</strong>，然后由线程在下一个合适的时刻中断自己。当他们收到中断请求后者在开始执行时发现某个已经被设置好的中断状态时，将抛出一个<strong>异常</strong>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 中断目标线程</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查询目标线程的中断状态</div><div class="line">     */    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清除线程的中断状态，并返回它之前的值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">iterrupted</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>阻塞库方法，例如<code>sleep()</code>、<code>wait()</code>和<code>join()</code>等，都会检查线程何时中断，并且在发现中断后<strong>提前返回</strong>。他们在响应中断时执行的操作：清除中断状态，抛出InterruptedException，<strong>表示阻塞操作由于中断而提前结束</strong>。</p><p>在使用静态的<code>interrupted()</code>时应该小心，因为它既可以得到上一次线程的中断标志值，又可以同时清除线程的中断标志。如果在调用interrupted过程中返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出InterruptedException，或者再次调用interrupt来恢复中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line">    </div><div class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</div><div class="line">        interrupt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当到达队列容量时，queue会阻塞，put内部会调用<code>LockSupport.park()</code>用来阻塞线程。当其他线程调用此线程的<code>interrupt()</code>方法时，会设置一个中断标志。当<code>LockSupport.part()</code>检测到这个标志时，会抛出InterruptedException，并清除线程的中断状态。因此，在InterruptedException的catch块，调用<code>Thread.currentThread().isInterrupted()</code>会返回false，因此可以在这里再次调用<code>Thread.currentThread().interrupt()</code>恢复中断状态。</p><h2 id="如何正确的处理InterruptedException"><a href="#如何正确的处理InterruptedException" class="headerlink" title="如何正确的处理InterruptedException"></a>如何正确的处理InterruptedException</h2><ol><li><strong>传递异常</strong>：在执行某个特定任务的<strong>清除操作之后</strong>，从而使你的方法也成为可中断的阻塞方法。</li><li><p><strong>恢复中断状态</strong>，从而使调用栈中的上层代码能够对其进行处理。</p><p>因此，只有实现了线程中断策略的代码才可以屏蔽中断请求，在常规的任务和库代码中都不应该屏蔽中断请求。</p><p>但是对于一些<strong>不支持取消</strong>但仍可以调用可中断阻塞方法的操作，他们必须在<em>循环中调用这些方法，并在发现中断后重新尝试</em>。在这种情况下，他们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获InterruptedException时恢复状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">return</span> queue.take();</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        <span class="keyword">if</span>(interrupted)&#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果<strong>过早的</strong>设置中断状态，可能引起<strong>无限循环</strong>，因为大多数可中断的阻塞方法都会在入口处检查中断状态，并且当发现该状态已被设置时会立即抛出InterruptedException。</p></li><li><p>如果代码<strong>不会调用可中断的阻塞方法</strong>，那么仍然可通过任务代码中轮询当前线程的中断状态来响应中断。要选择合适的轮询频率，就需要在效率和响应性之间进行权衡。如果响应性要求较高，那么不应该调用哪些执行时间较长并且不响应中断的方法。</p></li></ol><h2 id="如何处理非正常的线程终止"><a href="#如何处理非正常的线程终止" class="headerlink" title="如何处理非正常的线程终止"></a>如何处理非正常的线程终止</h2><p>导致线程提前死亡的原因是RuntimeException，由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此他们通常不会捕获。他们不会在调用栈中逐层传递，而是默认地在控制台中输出栈追踪信息，并终止线程。</p><ol><li><p>主动解决未检查异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void run()&#123;</div><div class="line">    Throwable thrown = null;</div><div class="line">    try&#123;</div><div class="line">        while(!isInterrupted())&#123;</div><div class="line">            runTask(getTaskFromWorkQueue());</div><div class="line">        &#125;</div><div class="line">    &#125; catch(Throwable e) &#123;</div><div class="line">        threadExited(this, thrown);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用UncaughtExceptionHandler</p><p>Thread API中提供了UncaughtExceptionHandler，能够检测出某个线程由于未捕获的异常而终结的情况。</p><p>当一个线程由于未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler异常处理器。如果没有提供任何异常处理器时，通过默认的异常处理器，将栈追踪信息输出到System.err中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GlobalUEHLogger implements Thread.UncaughtExceptionHandler &#123;</div><div class="line">    @Override</div><div class="line">    public void uncaughtException(Thread t, Throwable e) &#123;</div><div class="line">        Logger logger = Logger.getAnonymousLogger();</div><div class="line">        logger.log(Level.WARNING, &quot;Thread terminated with exception: &quot; + t.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在运行时间较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。</p><p>只有通过<strong>execute提交</strong>的任务，才能将它抛出的异常交给未捕获异常处理器，而通过<strong>submit提交的任务</strong>，无论是抛出的未检查异常还是已检查异常，都将被认为是任务返回状态的一部分。如果一个由submit提交的任务由于抛出异常而结束，那么这个异常将别Future.get封装在ExecutionException中重新抛出。</p></li></ol><h2 id="什么是关闭钩子"><a href="#什么是关闭钩子" class="headerlink" title="什么是关闭钩子"></a>什么是关闭钩子</h2><p>关闭钩子是指通过<code>Runtime.addShutdownHook()</code>注册的但尚未开始的线程。</p><ol><li><p>用途</p><ul><li>关闭钩子能够实现服务或应用程序的清理工作，例如删除临时文件夹，或清除无法由操作系统自动清除的资源。</li></ul></li><li><p>特点</p><ul><li>JVM不能保证关闭钩子的调用顺序，在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。</li><li>当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true，那么JVM将运行终结器，然后再停止。</li><li>关闭钩子应该是线程安全的，在访问共享数据时必须使用同步机制，并且小心地避免死锁。因此，关闭钩子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务，实现这种功能的方式是<strong>对所有服务使用同一个关闭钩子</strong>，并且在该关闭钩子中执行一系列的关闭操作。确保了关闭操作在单个线程中串行执行，从而避免了在关闭操作之间出现竞态条件或者死锁等问题。</li><li>关闭钩子应该<strong>尽快退出</strong>，因为会延迟JVM的结束时间。</li></ul></li></ol><h2 id="普通进程与守护线程之间的差异"><a href="#普通进程与守护线程之间的差异" class="headerlink" title="普通进程与守护线程之间的差异"></a>普通进程与守护线程之间的差异</h2><p>普通进程与守护线程之间的差异仅在于当<strong>线程退出时发生的操作</strong>。</p><p>当一个线程退出时，JVM或检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。</p><p>因此，应该尽可能少使用守护线程，如果在守护线程中执行可能包含IO操作的任务，那么将是一种危险行为。守护线程最好用于执行内部任务，例如周期性地从内存的缓存中移除逾期的数据。</p><h2 id="异构任务并行中存在哪些局限性"><a href="#异构任务并行中存在哪些局限性" class="headerlink" title="异构任务并行中存在哪些局限性"></a>异构任务并行中存在哪些局限性</h2><ol><li>很难找出任务之间细粒度的并行性，异构任务的并发带来的好处将减少；</li><li>各个<strong>任务的大小</strong>可能完全不同，那么任务执行的最长时间取决于任务最大的那个，可能从中获得的并发性十分有限；</li><li>需要一定的<strong>任务协调开销</strong>，为了使任务分解能够提高性能，这种开销不能高于并行实现的性能提升；</li></ol><p>因此，只有当大量<strong>相互独立且同构的任务</strong>可以并发进行处理，才能体现出将程序的工作负责分配到多个任务中带来的真正性能提升。</p><h2 id="CompletionService的作用"><a href="#CompletionService的作用" class="headerlink" title="CompletionService的作用"></a>CompletionService的作用</h2><p>如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后遍历get方法，从而通过轮询判断任务是否完成。这种方法虽然可行，但是繁琐。</p><p>CompletionService将Executor和BlockingQueue的功能融合到了一块，可以将Callable任务提交给Executor执行，然后使用类似于队列操作的take和poll等方法，从BlockingQueue获得已完成的结果，而这些结果会在完成时将被封装为Future。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Renderer</span><span class="params">(ExecutorService executor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span></span>&#123;</div><div class="line">        List&lt;ImageInfo&gt; imageInfos =scanForImageInfo(source);</div><div class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">final</span> ImageInfo imageInfo:imageInfos)&#123;</div><div class="line">            completionService.submit(imageInfo::downloadImage);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        renderText(source);</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">           <span class="keyword">for</span>(ImageInfo info:imageInfos)&#123;</div><div class="line">               Future&lt;ImageData&gt; imageDataFuture = completionService.take();</div><div class="line">               ImageData imageData = imageDataFuture.get();</div><div class="line">               renderImage(imageData);</div><div class="line">           &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个Executor的ExecutorCompletionService。因此，ExecutorCompletionService相当于一组计算的句柄，代表了一组计算的分类，这与单个Future作为单个句柄是非常类似的。</p><p>另外，通过<strong>记录</strong>提交给CompletionService的任务数量，并计算已经获得的<strong>已完成的结果</strong>的数量，即使使用一个共享的Executor，也能知道已经获得了所有任务结果的时间。</p><h2 id="如何为任务设置时限"><a href="#如何为任务设置时限" class="headerlink" title="如何为任务设置时限"></a>如何为任务设置时限</h2><p>如果某个任务没有在指定时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。<code>Future.get</code>支持这种需求：当结果可用时，它将立即返回，如果在指定的时间内没有计算出结果，那么将抛出TimeoutException。</p><p>在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">long</span> endNanos = System.nanoTime() + <span class="number">2000</span>;</div><div class="line">    Future&lt;Ad&gt; f = executor.submit(<span class="keyword">new</span> FetchAdTask());</div><div class="line">    Page page = renderPageBody();</div><div class="line">    Ad ad;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</div><div class="line">        ad = f.get(timeLeft,TimeUnit.NANOSECONDS);</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">        f.cancel(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    page.addAd(ad);</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="如何提交向线程池中提交一组计算任务"><a href="#如何提交向线程池中提交一组计算任务" class="headerlink" title="如何提交向线程池中提交一组计算任务"></a>如何提交向线程池中提交一组计算任务</h2><blockquote><p><strong>预订时间</strong>方法可以很容易扩展到任意数量的任务上。考虑这样一个门户网站：用户输入旅行的日期和其他要求，门户网站获取并显示来自多条航线、旅店或汽车租赁公司的报价。在获取不同公司报价的过程中，可能会调用Web服务、访问数据库、执行一个EDI事务或其他机制。在这种情况下，不宜让页面的响应时间受制于最慢的响应时间，而应该只显示在指定时间内收到的信息。</p><p>从一个公司获得报价的过程与其他公司获得报价的过程无关，因此可以将获取报价的过程当成一个任务，从而使获得报价的过程能够并发执行。</p></blockquote><p>可以通过ExecutorService的<code>invokeAll()</code>方法，用于将多个任务提交到一个ExecutorService并获得结果。invokeAll方法的参数为一组任务，返回一组Future。当所有的任务都执行完毕时，或者调用线程被中断，又或者超过指定时限时，invokeAll将返回。当超过指定时限时，任何还未完成的任务都将会取消。当invokeAll返回后，每个任务要么正常地完成，要么被取消，而客户端可以调用get或isCancelled来判断究竟是什么情况。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelQuoteService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ExecutorService executor;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany travelCompany;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QuoteTask</span><span class="params">(TravelCompany travelCompany, TravelInfo travelInfo)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.travelCompany = travelCompany;</div><div class="line">            <span class="keyword">this</span>.travelInfo = travelInfo;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> travelCompany.solicitQuote(travelInfo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuote</span><span class="params">(TravelInfo travelInfo,</span></span></div><div class="line">                                                  Set&lt;TravelCompany&gt; companies,</div><div class="line">                                                  Comparator&lt;TravelQuote&gt; ranking,</div><div class="line">                                                  <span class="keyword">long</span> time,</div><div class="line">                                                  TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (TravelCompany company : companies) &#123;</div><div class="line">            tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo));</div><div class="line">        &#125;</div><div class="line">        List&lt;Future&lt;TravelQuote&gt;&gt; futures = executor.invokeAll(tasks, time, unit);</div><div class="line"></div><div class="line">        List&lt;TravelQuote&gt; quotes = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks.size());</div><div class="line">        Iterator&lt;QuoteTask&gt; iter = tasks.iterator();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Future&lt;TravelQuote&gt; future : futures) &#123;</div><div class="line"></div><div class="line">            QuoteTask task = iter.next();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                quotes.add(future.get());</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                quotes.add(task.getFailureQuote(e.getCause()));</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                quotes.add(task.getTimeoutQuote(e));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        quotes.sort(ranking);</div><div class="line">        <span class="keyword">return</span> quotes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="有些哪些类型的任务需要明确地指定执行策略"><a href="#有些哪些类型的任务需要明确地指定执行策略" class="headerlink" title="有些哪些类型的任务需要明确地指定执行策略"></a>有些哪些类型的任务需要明确地指定执行策略</h2><p>Executor框架可以将任务的<strong>提交</strong>与任务的<strong>执行策略</strong>解耦开来。虽然Executor框架为制定和修改执行策略都提供了相当大的灵活性，但并非所有的任务都能适用所有的执行策略，因此，有些类型的任务需要明确地指定执行策略：</p><ol><li><strong>依赖性任务</strong>：大多数行为正确的任务都是独立的，他们不依赖于其他任务的执行时序、执行结果和其他效果。如果提交给线程池的任务需要依赖其他的任务，那么就隐含地给执行策略带来了约束，此时必须小心地维持这些执行策略以避免产生活跃性问题。</li><li><strong>使用线程封闭机制的任务</strong>：单线程的Executor能够确保任务不会并发执行，对象可以封闭在任务线程中，使得在线程中执行的任务在访问对象时不需要同步，即使这些线程不是线程安全的也没问题。这种情形下，在任务与执行策略之间形成了隐式的耦合——任务要求其执行所在的Executor是单线程的。</li><li><strong>对响应时间敏感的任务</strong>：如果将一个运行时间较长的任务提交到单线程的Executor中，或者将多个运行时间较长的任务提交到一个只包含少量线程的线程池中，那么将降低由该Executor管理的服务的响应性。</li><li><strong>使用ThreadLocal的任务</strong>：在线程池的线程中不应该使用ThreadLocal在任务之间传递值。</li></ol><p>只有当任务都是<strong>同类型</strong>的并且<strong>相互独立</strong>时，线程池的性能才能达到最佳。</p><ul><li>如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程很大，否则将可能造成<strong>拥塞</strong>。</li><li>如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成<strong>死锁</strong>。</li></ul><h2 id="什么是线程饥饿死锁"><a href="#什么是线程饥饿死锁" class="headerlink" title="什么是线程饥饿死锁"></a>什么是线程饥饿死锁</h2><p>只要线程池中的任务需要<strong>无限期地等待</strong>一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程<strong>饥饿死锁</strong>。</p><p>因此，每当提交了一个有依赖的Executor任务时，要清楚地知道可能会出现线程<strong>饥饿死锁</strong>，因此需要在代码或配置Executor的配置文件中记录线程池的大小或配置限制。</p><p>如果任务阻塞的时间过长，那即使不出现死锁，线程池的响应性也会变得糟糕。执行时间过长的任务不仅会造成线程池阻塞，甚至还会增加执行时间较短任务的服务时间。</p><h2 id="如何设置线程池的大小"><a href="#如何设置线程池的大小" class="headerlink" title="如何设置线程池的大小"></a>如何设置线程池的大小</h2><p>线程池的理想大小取决于<strong>被提交任务的类型</strong>以及<strong>所部署系统的特性</strong>。</p><p>设置线程池的大小需要避免“过大”和“过小”这两种极端情况。</p><ul><li>如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。</li><li>如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐率。</li></ul><p>因此，要想正确地设置线程池的大小，必须分析<strong>计算环境</strong>、<strong>资源预算</strong>和<strong>任务的特性</strong>。在部署的系统中有都少个CPU？多大的内存？任务是计算密集型、I/O密集型还是二者皆可？他们是否需要像JDBC连接这样的稀缺资源？如果需要执行不同类别的任务，并且他们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程可以根据各自的工作负载来调整。</p><p>要是处理器达到期望的使用率，线程池的最优大小等于：</p><p>$$<br>N<em>{threads}=N</em>{cpu}<em>U_{cpu}</em>(1+\frac{W}{C})<br>$$</p><ul><li>\(N_{cpu}\)：表示处理器数量，可以通过<code>Runtime.getRuntime().avaliableProcessors()</code>获得。</li><li>\(U<em>{cpu}\)：CPU的使用率，\(0\leqslant U</em>{cpu}\leqslant 1\)</li><li>\(\frac{W}{C}\)：等待时间与计算时间的比值</li></ul><p>另外，CPU周期并不是唯一影响线程池大小的资源，还包括<strong>内存、文件句柄、套接字句柄和数据库连接</strong>等。通过计算<strong>每个任务对该资源</strong>的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果解释线程池大小的上限。</p><h2 id="线程池队列的用途"><a href="#线程池队列的用途" class="headerlink" title="线程池队列的用途"></a>线程池队列的用途</h2><p>如果无限制的创建线程，那么将可能耗尽内存资源，因此可以通过采用固定大小的线程池来解决这个问题。在高负载的情况下，应用程序仍可能耗尽资源：</p><ul><li>如果<strong>请求的到达速率超过了线程池的处理速率</strong>，那么新到来的请求将累计起来。这些请求会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源，当然也比使用线程表示的开销低很多。</li><li>即使请求的平均<strong>到达速率很平稳</strong>，但还是会有请求突增的情况。尽管任务队列有助于缓解任务的突增问题，如果任务持续高速地到来，<strong>响应性能也将随着任务队列的增长而变得越来越糟</strong>。</li></ul><p><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>在默认情况下使用一个无界的<code>LinkedBlockingQueue</code>。如果所有工作者线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续地快速到达，并且超过了线程池处理他们的速度，那么队列将无限制的增加。</p><p>一种更稳妥的资源管理策略是使用<strong>有界队列</strong>，例如<code>ArrayBlockingQueue</code>、有界的<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>。有界队列有助于避免资源被耗尽，那么当队列填满后，新的任务该怎么办？可以根据饱和策略来进行处理。一般的，如果线程池较小而队列较大，那么有助于减少内存的使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价是会限制吞吐量。</p><p><code>ArrayBlockingQueue</code>或<code>LinkedBlockingQueue</code>是基于FIFO队列的，任务的执行顺序与他们的到达顺序相同。如果想进一步控制任务的执行顺序，可以使用<code>PriorityBlockingQueue</code>，这个队列可以根据优先级来安排任务。</p><p>对于<strong>非常大的线程池或者无界线程池</strong>，可以通过使用<code>SynchronousQueue</code>来避免排队，以及<strong>直接将任务从生产者移交给工作者线程</strong>。<code>SynchronousQueue</code>不是一个真正的队列，而是一种在线程之间进行移交的机制。如果要将一个元素放入<code>SynchronousQueue</code>中，必须有另一个线程正在等待接受这个元素。如果没有线程等待，并且线程池的<strong>当前大小小于最大值</strong>，那么<code>ThreadPoolExecutor</code>将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，只有当线程池是无界的或者可以拒绝任务时，<code>SynchronousQueue</code>才有实际的价值。在<code>newCachedThreadPool</code>工厂方法中就是用了<code>SynchronousQueue</code>。</p><h2 id="如何选择线程池"><a href="#如何选择线程池" class="headerlink" title="如何选择线程池"></a>如何选择线程池</h2><ul><li><code>newCachedThreadPool</code>工厂方法是一种很好的默认选择，它能够提供比固定大小的线程池更好的排队性能；</li><li>当需要限制当前任务的数量以满足资源管理器需求时，那么可以选择固定大小的线程池，例如在接受网络请求的服务器程序中，如果不进行限制，那么很容易导致过载问题。</li><li>只有当任务<strong>相互独立</strong>，为线程池设置界限才合理；如果任务之间存在<strong>依赖性</strong>，那么有界的线程池或队列就可能导致线程<strong>饥饿死锁</strong>问题，那么此时应该使用无界的线程池。</li><li>对于提交任务并等待其结果的任务来说，还有一种配置方法。就是使用有界的线程池，并使用<code>SynchronousQueue</code>作为工作队列，以及<strong>调用者运行</strong>饱和策略。</li></ul><h2 id="什么是线程池的饱和策略"><a href="#什么是线程池的饱和策略" class="headerlink" title="什么是线程池的饱和策略"></a>什么是线程池的饱和策略</h2><p>当有界队列被填满后，饱和策略将发挥作用。<code>ThreadPoolExecutor</code>的饱和策略可以通过调用<code>setRejectedExecutionHandler</code>来修改。如果某个任务被提交到一个已关闭的Executor，也会用到饱和策略。JDK提供了几种不同的<code>RejectedExecutionHandler</code>的饱和策略实现：</p><ol><li><strong>AbortPolicy（中止）</strong>：<ul><li>该策略是<strong>默认的</strong>饱和策略；</li><li>会抛出未检查的<code>RejectedExecutionException</code>，调用者可以捕获这个异常，然后根据需求编写自己的处理代码；</li></ul></li><li><strong>DiscardPolicy（抛弃）</strong>：<ul><li>当提交的任务无法保存到队列中等待执行时，Discard策略会悄悄抛弃该任务。</li></ul></li><li><strong>DiscardOldestPolicy（抛弃最旧）</strong>：<ul><li>会抛弃下一个将被执行的任务，然后尝试重新提交的新任务。</li><li>如果工作队列是一个优先队列，那么<strong>抛弃最旧的</strong>策略，会抛弃优先级最高的任务，因此最好不要将<strong>抛弃最旧的</strong>饱和策略和优先级队列放在一起使用。</li></ul></li><li><strong>CallerRunsPolicy（调用者运行）</strong>：<ul><li>该策略既不会抛弃任务，也不会抛出异常，而是当线程池中的所有线程都被占用后，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行，从而降低新任务的流量。</li><li>由于执行任务需要一定的时间，因此主线程至少在一定的时间内不能提交任何任务，从而使得工作者线程有时间来处理正在执行的任务。</li><li>另一方面，在这期间，主线程不会调用accept，那么到达的请求将被保存在TCP层的队列中而不是在应用程序的队列中。</li><li>如果持续过载，那么TCP层将最终发现他的请求队列被填满，因此同样会开始抛弃请求。</li><li>当服务器过载时，这种过载情况会逐渐向外蔓延开来——从<strong>线程池</strong>到<strong>工作队列</strong>到<strong>应用程序</strong>再到<strong>TCP层</strong>，最终到达<strong>客户端</strong>，导致服务器在高负载的情况下实现一种平缓的性能降低。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor <span class="title">newThreadPoolOfFixedWithCallerPolicy</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">200</span>,</div><div class="line">            <span class="number">200</span>,</div><div class="line">            <span class="number">0L</span>,</div><div class="line">            TimeUnit.MILLISECONDS,</div><div class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>));</div><div class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</div><div class="line">    <span class="keyword">return</span> executor;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过，当工作队列被填满后，并没有预定的饱和策略来阻塞execute。因此，可以通过信号量Semaphore来限制任务的到达速率，就可以实现该功能。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedExecutor</span><span class="params">(Executor executor, <span class="keyword">int</span> bound)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(bound);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitTask</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        semaphore.acquire();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            executor.execute(command::run);</div><div class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">            semaphore.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="什么是线程工厂"><a href="#什么是线程工厂" class="headerlink" title="什么是线程工厂"></a>什么是线程工厂</h2><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含任何特殊的配置信息。</p><p>因此，通过指定一个线程工厂方法，可以定制线程的配置信息。例如，可以定制一个用于日志打印的线程工厂，在线程被创建或者终止时把调试信息写入日志。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggerThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.poolName = poolName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoggerThread(r, poolName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"logable thread"</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> debugLifecycle = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger CREATED = <span class="keyword">new</span> AtomicInteger();</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger ALIVE = <span class="keyword">new</span> AtomicInteger();</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = Logger.getAnonymousLogger();</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoggerThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>(r, DEFAULT_NAME);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoggerThread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(target, name + <span class="string">"-"</span> + CREATED.incrementAndGet());</div><div class="line">            setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</div><div class="line">                    LOG.log(Level.SEVERE, <span class="string">"UNCAUGHT in thread "</span> + t.getName(), e);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">boolean</span> debug = debugLifecycle;</div><div class="line">            <span class="keyword">if</span> (debug) &#123;</div><div class="line">                LOG.log(Level.FINE, <span class="string">"Created "</span> + getName());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ALIVE.incrementAndGet();</div><div class="line">                <span class="keyword">super</span>.run();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                ALIVE.decrementAndGet();</div><div class="line">                <span class="keyword">if</span> (debug) &#123;</div><div class="line">                    LOG.log(Level.FINE, <span class="string">"Exiting "</span> + getName());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsCreated</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> CREATED.get();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> ALIVE.get();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDebug</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> debugLifecycle;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> debug)</span> </span>&#123;</div><div class="line">            debugLifecycle = debug;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>另外，如果在应用程序中需要利用安全策略来控制对某些特殊代码库的访问权限，那么可以通过Executor中的<code>PrivilegedThreadFactory</code>工厂来定制自己的线程工厂。</p><h2 id="unconfigurableExecutorService用途"><a href="#unconfigurableExecutorService用途" class="headerlink" title="unconfigurableExecutorService用途"></a>unconfigurableExecutorService用途</h2><p>在调用完ThreadPoolExecutor的构造函数后，仍然可以通过设置函数来修改大多数传递给它的构造函数参数（例如，线程池的大小、最大大小、存活时间等）。</p><p>在Executors中包含一个<code>unconfigurableExecutorService</code>工厂方法，该方法能够对一个现有的<code>ExecutorService</code>进行包装，使其只暴露出<code>ExecutorService</code>的方法，因此不能对它进行配置，从而保证原有线程池工厂的执行语义，因此可以使用这项技术保证自己的Executor执行策略不被修改。</p><h2 id="如何扩展ThreadPoolExecutor"><a href="#如何扩展ThreadPoolExecutor" class="headerlink" title="如何扩展ThreadPoolExecutor"></a>如何扩展ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是可扩展的，提供了几个可以在子类化中改写的方法：<code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>，这些方法可以从来扩展<code>ThreadPoolExecutor</code>的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = Logger.getLogger(TimingThreadPool.class.getSimpleName());</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger numTask = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong totalTime = <span class="keyword">new</span> AtomicLong();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimingThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</div><div class="line">        log.fine(String.format(<span class="string">"Thread %s: start %s"</span>, t, r));</div><div class="line">        startTime.set(System.nanoTime());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">            <span class="keyword">long</span> taskTime = endTime - startTime.get();</div><div class="line">            numTask.incrementAndGet();</div><div class="line">            totalTime.addAndGet(taskTime);</div><div class="line">            log.fine(String.format(<span class="string">"Thread %s: end %s, time=%dns"</span>, t, r, taskTime));</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">super</span>.afterExecute(r, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            log.info(String.format(<span class="string">"Terminated: avg time=%dns"</span>, totalTime.get() / numTask.get()));</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">super</span>.terminated();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何实现递归算法的并行化"><a href="#如何实现递归算法的并行化" class="headerlink" title="如何实现递归算法的并行化"></a>如何实现递归算法的并行化</h2><p>如果循环中的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成再继续进行，那么就可以使用Executor将串行循环转化为并行循环。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInParallel</span><span class="params">(Executor exec, List&lt;Element&gt; elements)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(Element e: elements)&#123;</div><div class="line">        exec.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                process(e);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>processInParallel</code>能够更快的返回，不会等待这些任务全部完成。如果需要提交一个任务集并等待他们全部完成，那么可以使用<code>ExecutorService.invokeAll()</code>，并且在所有任务执行完成后，使用<code>CompletionService.take()</code>获取结果。</p><p>在一些递归设计中同样采用循环并行化的方法，一种简单的情况是：<strong>在每个迭代操作中都不需要来自于后续递归迭代的结果</strong>。例如，等待通过并行方式计算的结果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sequentialRecursive</span><span class="params">(List&lt;Node&gt; nodes, Collection&lt;T&gt; results)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(Node&lt;T&gt; n : nodes)&#123;</div><div class="line">        results.add(n.compute());</div><div class="line">        sequentialRecursive(n.getChildren(), results);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor exec, List&lt;Node&lt;T&gt;&gt; nodes, <span class="keyword">final</span> Collection&lt;T&gt; results)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(Node&lt;T&gt; n : nodes)&#123;</div><div class="line">        exec.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                results.add(n.compute());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        parallelRecursive(exec, n.getChildren(), results);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getParallelResults</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span></span>&#123;</div><div class="line">    ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">    Queue&lt;T&gt; resultQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</div><div class="line">    parallelRecursive(exec, nodes, resultQueue);</div><div class="line">    exec.shutdown();</div><div class="line">    exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</div><div class="line">    <span class="keyword">return</span> resultQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      如何利用线程来提高并发应用程序的吞吐量或响应性，如何识别可并行的任务，如何取消或中断任务以及任务框架的一些更高级特性。
    
    </summary>
    
      <category term="多线程" scheme="http://www.vibrancy.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.vibrancy.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识自查表——类加载</title>
    <link href="http://www.vibrancy.cn/repository/jvm-knowledge-self-class-loading.html"/>
    <id>http://www.vibrancy.cn/repository/jvm-knowledge-self-class-loading.html</id>
    <published>2017-06-17T12:36:33.000Z</published>
    <updated>2017-06-17T12:57:27.394Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h2><p>类加载器不仅仅只用于实现类的加载动作，对于任意一个类，都需要由<strong>加载它的类加载器</strong>和这个类本身一同确立其在Java虚拟机中的<strong>唯一性</strong>。简单地说，比较两个类是否<strong>相等</strong>，只有在这两个类由<strong>同一个类加载器加载</strong>的前提之下才有意义。否则，即使这两个类来自于同一个Class文件，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p>这里所说的相等，包括代表类的Class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法返回的结果，也包括使用<code>instanceOf</code>关键字做对象所属关系判定等情况。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span> )+<span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</div><div class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</div><div class="line">                    is.read(b);</div><div class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Object obj = myLoader.loadClass(<span class="string">"com.cwc.test.jvm.classtest.ClassLoaderTest"</span>).newInstance();</div><div class="line">        System.out.println(obj.getClass());</div><div class="line">        System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">class com.cwc.test.jvm.classtest.ClassLoaderTest</div><div class="line">false</div></pre></td></tr></table></figure><p>由运行结果可以看到，这时虚拟机中存在了两个ClassLoaderTest类，一个是<strong>系统应用程序类加载器</strong>加载的，另一个是由<strong>自定义的类加载器</strong>加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查的时候结果自然为false。</p><h2 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h2><p>从虚拟机角度上讲，只存在两个不同的类加载器：一种是<strong>启动类加载器</strong>（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是<strong>所有其他的类加载器</strong>，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类<code>java.lang.ClassLoader</code>。</p><ol><li><p><strong>三种系统提供的类加载器</strong></p><ul><li><strong>启动类加载器</strong>（Bootstrap ClassLoader）：<ul><li>负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中，或者被<code>-Xbootclasspath</code>参数所指定的路径中，并且是虚拟机识别的类库加载到虚拟机内存中。</li><li><strong>启动类加载器无法被Java程序直接引用</strong>。</li></ul></li><li><strong>扩展类加载器</strong>（Extension ClassLoader）<ul><li>这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li><li><strong>开发者可以直接使用扩展类加载器</strong>。</li></ul></li><li><strong>应用程序类加载器</strong>（Application ClassLoader）<ul><li>这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。</li><li>该类加载器也是ClassLoader中<code>getSystemClassLoader()</code>方法的返回值，所以一般称为<strong>系统类加载器</strong>。</li><li>负责加载用户类路径（ClassPath）上所指定的类库。</li><li>开发者可以直接使用这个类加载器，如果应用程序没有自定义类加载器，一般情况下就是默认的类加载器。</li></ul></li></ul></li><li><p><strong>三种类加载器之间的关系如图所示</strong></p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.svg" alt="image"></p><p>上图所示的类加载器之间的层次关系，就称之为<strong>类加载器的双亲委派模型</strong>（Parent Delegation Model）。双亲委派模型除了要求顶层的启动类加载器外，其余的类加载器都有自己的父类加载器。这里的类加载器之间的父子关系并不以<strong>继承的关系</strong>实现，而是通过<strong>组合关系</strong>来复用父加载器代码的。</p></li><li><p><strong>双亲委派模型的工作过程</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（在他的<strong>搜索范围</strong>内没有找到所需的类），子类加载器才会去尝试自己去加载。</p><p>使用双亲委派模型的优点：随着他的类加载器一起具备了一种带有优先级的层次关系。例如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>包中，无论哪一个类加载器加载这个类，最终都是要委派给启动类加载器进行加载，因此Object类在程序的各类加载器环境中都是同一个类。</p></li></ol><h2 id="为什么Web服务器要自定义类加载器"><a href="#为什么Web服务器要自定义类加载器" class="headerlink" title="为什么Web服务器要自定义类加载器"></a>为什么Web服务器要自定义类加载器</h2><p>主流的Java Web服务器都实现了自己定义的类加载器（不止一个），因为一个功能健全的Web服务器，都需要解决如下几个问题：</p><ol><li><p>部署在同一个服务器上的两个Web应用程序所使用的<strong>Java类库可以实现相互隔离</strong>。这是最基本的要求，两个不同的应用程序可能会依赖同一个三方库的<strong>不同版本</strong>，不能要求一个类库在一个服务器中只能存在一份，因此，服务器应当可以保证<strong>两个应用程序的类库可以互相独立</strong>使用。</p></li><li><p>部署在同一个服务器上的两个Web应用程序所使用的<strong>Java类库可以互相共享</strong>。类库在使用的时候都需要被加载到服务器内存中，如果类库不能共享，虚拟机的方法区很容易就会出现过度膨胀的风险。</p></li><li><p><strong>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响</strong>。因为大多数主流的Java Web服务器自身也是使用Java语言来实现的，因此服务器本身也有类库依赖。因此，基于安全考虑，<strong>服务器所使用的类库</strong>应该与<strong>应用程序的类库</strong>互相独立。</p></li><li><p>支持JSP生成类的热替换（HotSwap功能）。</p></li></ol><p>由于存在上述问题，在部署Web应用时，单独的一个ClassPath就无法满足用户的需求，所以各种Web服务器都提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般都以“lib”或“classes”命名。<strong>被放置到不同路径中的类库，具备不同的访问范围和服务对象</strong>。通常每一个目录都会有一个<strong>相应的自定义类加载器</strong>去加载放置在里面的Java类库。</p><h2 id="Tomcat的类加载器结构"><a href="#Tomcat的类加载器结构" class="headerlink" title="Tomcat的类加载器结构"></a>Tomcat的类加载器结构</h2><p>在Tomcat目录结构中（老版本），有以下目录可以存放Java类库：</p><ul><li><strong>common/</strong>：类库可以被Tomcat和所有的Web应用程序功能使用；</li><li><strong>server/</strong>：类库可以被Tomcat使用，对所有的Web应用程序都不可见；</li><li><strong>shared/</strong>：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li><li><strong>webapp/WEB-INF/</strong>：类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li></ul><p>Tomcat自定义了多个类加载器，这些类加载器都按照<strong>经典的双亲委派模型</strong>来实现的。<strong>CommonClassLoader</strong>、<strong>CatalinaClassLoader</strong>、<strong>SharedClassLoader</strong> 和<strong>WebappClassLoader</strong>他们分别加载/common/、/server/、 /shared/ 、 和 /webapp/WEB-INF/中Java类库的逻辑。其中WebApp类加载器和Jsp类加载器通常会存在<strong>多个实例</strong></p><ul><li>每一个Web应用程序对应一个WebApp类加载器；</li><li>每个JSP文件对应一个Jsp类加载器。</li></ul><p>Tomcat多个类加载器之间的关系如图所示：</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.svg" alt="image"></p><p>从上图可以看出：</p><ul><li>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用；</li><li>CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</li><li>WebappClassLoader可以使用SharedClassLoader加载到的类，但各个WebappClassLoader实例之间相互隔离。</li><li>JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class，他出现的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过新创建一个JSP类加载器实现JSP文件的HotSqap功能。</li></ul><h2 id="哪些情况必须对类进行初始化"><a href="#哪些情况必须对类进行初始化" class="headerlink" title="哪些情况必须对类进行初始化"></a>哪些情况必须对类进行初始化</h2><ol><li>使用<strong>new关键字实例化对象</strong>的时候；读取或设置一个类的静态字段时；调用类的静态方法时。</li><li>当初始化一个类时，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>使用\(java.lang.reflect\)包的方法对类进行反射初始化的时候。</li><li>当虚拟机启动时，用户指定的执行主类（包含main()方法的类）。</li></ol><p><strong>接口的加载</strong>过程和<strong>类加载</strong>过程稍有不同：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部初始化完成，只有在真正使用到父接口的时候（如<strong>引用接口中定义的常量</strong>）才会初始初始化。</p><h2 id="哪些情况不会触发对类的初始化"><a href="#哪些情况不会触发对类的初始化" class="headerlink" title="哪些情况不会触发对类的初始化"></a>哪些情况不会触发对类的初始化</h2><ol><li><p><strong>通过子类引用父类的静态字段，不会导致子类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> vlaue = <span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(SubClass.vlaue);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">SuperClass init!</div><div class="line">123</div></pre></td></tr></table></figure><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类引用父类中定义的静态字段，只会触发父类的初始化。</p><p>不过，通过\(-XX:+TraceClassLoading\)参数可以看到此操作导致了子类的加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[Loaded com.cwc.test.jvm.classtest.SuperClass from file:/G:/DevelopmentTest/JavaSE/Test/out/production/Test/]</div><div class="line">[Loaded com.cwc.test.jvm.classtest.SubClass from file:/G:/DevelopmentTest/JavaSE/Test/out/production/Test/]</div><div class="line">SuperClass init!</div><div class="line">123</div></pre></td></tr></table></figure></li><li><p><strong>通过数组定义来引用类，不会触发此类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SuperClass[] superClasses = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">运行结果：</div></pre></td></tr></table></figure><p>运行之后没有发现输出\(SuperClass\ init!\)，不过\(SuperClass\)进行了<strong>加载Loading</strong>。不过，这段代码中会触发另外一个名为\([Lcom.cwc.test.jvm.classtest.SuperClass\)的类的初始化，该类是由虚拟机自动生成的、直接继承于\(java.lang.Object\)的子类，创建动作由字节码指令\(newarray\)触发。</p></li><li><p><strong>常量在编译阶段会存入==调用类的常量池==中，本质上没有直接引用到定义常量的类，因此不会触发定义常量类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VALUE = <span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(ConstClass.VALUE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">123</div></pre></td></tr></table></figure><p>虽然引用了\(ConstClass\)类中的常量VALUE，但是在编译阶段将此常量的值存储到了\(NotInitialization\)类的常量池中，对常量\(ConstClass.VALUE\)的引用实际上都转化为\(NotInitialization\)类对自身常量池的引用。</p></li></ol><h2 id="谈谈类加载的过程"><a href="#谈谈类加载的过程" class="headerlink" title="谈谈类加载的过程"></a>谈谈类加载的过程</h2><p>虚拟机把描述类的数据从Class文件<strong>加载到内存</strong>，并对数据进行<strong>校验</strong>、<strong>转换解析</strong>和<strong>初始化</strong>、最终形成可以被虚拟机直接使用的<strong>Java类型</strong>，这就是虚拟机的类加载机制。</p><p>在Java语言里，类型的<strong>加载和连接</strong>过程都是在程序运行期间完成的，虽然会增加一些性能开销，但是为<strong>运行期间动态加载</strong>和<strong>动态连接</strong>提供了可能。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="image"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是固定的，而<strong>解析阶段</strong>则不一定，在某些情况下可以在<strong>初始化阶段</strong>之后在开始，这是为了支持Java语言的<strong>运行时绑定</strong>。</p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>在<strong>加载阶段</strong>，虚拟机需要完成以下三件事：</p><ol><li>通过一个类的<strong>全限定名</strong>来获取定义此类的<strong>二进制字节流</strong>。获取二进制字节流的来源包括：<ul><li>从JAR、EAR、WAR包中获取</li><li>从网络中获取</li><li>运行时计算生成，例如，动态代理技术</li><li>由其他文件生成，如JSP应用</li></ul></li><li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>。</li><li>在Java堆中生成一个代表这个类的\(java.lang.Class\)对象，作为方法区这些数据的访问入口。</li></ol><p><strong>加载阶段</strong>（加载阶段中<strong>获取类的二进制字节流的动作</strong>）也是开发期间<strong>可控性最强</strong>的阶段，因为加载阶段既可以使用系统提供的<strong>类加载器</strong>完成，也可以使用用户自定义的类加载器完成。</p><p>加载阶段和连接阶段的<strong>部分内容是交叉进行</strong>的（一部分字节码文件格式验证动作），加载阶段尚未完成，连接阶段可能已经开始，但这些夹杂在加载阶段之中进行的动作，仍然属于连接阶段的内容。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证的目的是为了确保<strong>Class文件的字节流</strong>中包含的信息流符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>不过Java语言是相对安全的语言，使用纯粹的Java代码不会访问诸如数组边界之外的数据、将一个对象转型为并为实现的类型、跳转到并不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。</p><p>Class二进制字节流的来源很多，并不一定要求Java源码编译而来。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p><p>验证阶段的检验过程主要包括：</p><ol><li><strong>文件格式验证</strong>：字节流是否符合Class文件格式的规范，保证输入的字节流能正确地解析并存储于方法区之内。<ul><li>是否以魔数<code>0xCAFEBABE</code>开头</li><li>主、次版本号是否在当前虚拟机处理范围内</li><li>常量池的常量是否有不被支持的常量类型。</li><li>指向常量池的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info类型的常量中是否有不符合UTF8编码的数据</li><li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息。</li><li>…</li></ul></li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求。<ul><li>这个类是否有父类；</li><li>这个类的父类是否继承了不允许被继承的类（如final修饰的类）；</li><li>如果这个类不是抽象类，是否实现了父类或接口中要求实现的方法；</li><li>类中的字段、方法是否与父类产生矛盾。</li><li>…</li></ul></li><li><strong>字节码验证</strong>：进行<strong>数据流</strong>和<strong>控制流</strong>分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。<strong>因为不能通过程序准确地检查出程序是否能在有限的时间之内结束运行</strong>。</li><li><p><strong>符号引用验证</strong>：将<strong>符合引用</strong>转化为<strong>直接引用</strong>，这个转化动作将在连接的第三阶段完成（解析阶段）。目的是保证<strong>解析动作</strong>能正常执行，如果无法通过符号引用验证，将会抛出一个\(java.lang.IncompatibleClassChangeError\)异常的子类，如\(java.lang.NoSuchMethodError\)等。</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类；</li><li>在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段；</li><li><p>符合引用中的类、字段和方法的访问性是否可被当前类访问。</p><p>该阶段是一个非常重要，但非必须的阶段，如果所运行的代码都已经反复被使用和验证过，在实施阶段可以考虑使用\(-Xverify:none\)参数关闭大部分的类验证措施，缩短虚拟机类加载的时间。</p></li></ul></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段的目的是正式为<strong>类变量分配内存</strong>并设置<strong>类变量初始值</strong>的阶段，这些内存都将在<strong>方法区</strong>中分配。</p><p>该阶段进行内存分配的仅包括<strong>类变量</strong>（被static修饰的变量），而不包括实例变量，实例变量将在对象实例化时随着对象分配在Java堆中。</p><p>另外，设置类变量的初始值是0值，而不是用户初始化的值。例如，<code>public static int value=123;</code>在准备阶段过后，value的值为0，而不是123。如果类字段的字段属性表中存在final属性，那么准备阶段过后value就会被初始化<strong>为final属性</strong>所执行的值。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>方法调用</strong>并不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪个方法），暂时还不涉及方法内部的具体运行过程。</p><p>一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而<strong>不是</strong>方法在实际运行时内存布局的<strong>入口地址</strong>。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在<strong>类加载期间</strong>甚至到运行期间才能确定目标方法的直接引用。</p><p>解析阶段是虚拟机将常量池内的<strong>符号引用</strong>解析为<strong>直接引用</strong>的过程：</p><ul><li><strong>符号引用</strong>：以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用的时候能无歧义地定位到目标即可。符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li><li><strong>直接引用</strong>：直接引用可以是直接指向目标的<strong>指针</strong>、<strong>相对偏移量</strong>或是一个间接定位到<strong>目标的句柄</strong>。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p>解析的动作主要针对<strong>类或接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>四类符号引用进行解析。</p><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分<strong>符号引用转化为直接引用</strong>。而这种解析能成立的前提是：++方法在程序真真运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的++。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。</p><p>在Java语言中，符合“<strong>编译期可知，运行期不可变</strong>”这个要求的方法主要有<strong>静态方法</strong>和<strong>私有方法</strong>两大类，前者与类型直接相关，后者在外部不可被访问，这两个方法都不能通过继承或别的方式重写出其他版本，因此他们都适合在类加载阶段进行解析。</p><p>在Java虚拟机里面提供了四条方法调用字节码指令</p><ul><li><strong>invokestatic</strong>：调用静态方法；</li><li><strong>invokespecial</strong>：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法；</li><li><strong>invokevirtual</strong>：调用所有的虚方法；</li><li><strong>invokeinterface</strong>：调用接口方法，会在运行时再确定一个实现接口的对象。</li></ul><p>只要能够被invokestatic 和 invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有<strong>静态方法</strong>、<strong>私有方法</strong>、<strong>实例构造器</strong>和<strong>父类方法</strong>四类，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以成为非虚方法。与之相反，其他方法就称为虚方法（除final方法）。</p><p>Java中的非虚方法除了使用invokestatic 和 invokespecial指令调用之外，就是被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但由于他无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，或者说多态的选择结果是唯一的。Java规范中明确说明了final方法是一个中非虚方法。</p><p>解析调用一定是个<strong>静态过程</strong>，在编译期就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派，这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派和动态多分派四种情况。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化时类加载过程的最后一步，在该阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。或者可以理解为执行类构造器<code>&lt;clinit&gt;()</code>的过程。</p><ol><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<strong>类变变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的。编译器收集的==顺序==有语句在<strong>源文件中出现的顺序</strong>所决定，静态语句块中只能访问到在静态语句块之前的变量。</li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数（实例构造器<code>&lt;init&gt;()</code>方法）不同，他不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</li><li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        A=<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(Child.B);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">2</div></pre></td></tr></table></figure></li><li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法方法。</p></li><li>接口中不能使用静态语句块，但仍有变量初始化的赋值操作，因此接口与类一样会生成<code>&lt;clinit&gt;()</code>方法方法。但接口与类不同，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li><li>在多线程环境中，虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法被正确的加锁和同步。如果多个线程同时初始化一个类，那么只有一个线程执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li></ol><h2 id="什么是静态分派"><a href="#什么是静态分派" class="headerlink" title="什么是静态分派"></a>什么是静态分派</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human man)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, guy"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, man"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Women man)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, women"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human women = <span class="keyword">new</span> Women();</div><div class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</div><div class="line">        sd.sayHello(man);</div><div class="line">        sd.sayHello(women);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">hello, guy</div><div class="line">hello, guy</div></pre></td></tr></table></figure><p>在上面的代码中，Human称为变量的<strong>静态类型</strong>（Static Type）或者外观类型，后面的Man则称为变量的<strong>实际类型</strong>。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在<strong>使用时</strong>发生，变量本身的静态类型不会被改变，并且最终的静态类型是在<strong>编译期可知</strong>的；而<strong>实际类型</strong>变化的结果在<strong>运行期</strong>才可以确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实际类型变化</span></div><div class="line">Human man = <span class="keyword">new</span> Man();</div><div class="line">man = <span class="keyword">new</span> Women();</div><div class="line"><span class="comment">// 静态类型变化</span></div><div class="line">sd.sayHello((Man)man);</div><div class="line">sd.sayHello((Women)man);</div></pre></td></tr></table></figure><p>在<code>main()</code>方法的两次<code>sayHello()</code>方法调用中，在方法接收者已经确定对象“sd”的情况下，使用过哪个重载版本，就完全取决于不同的变量，但是虚拟机（编译器）在重载时是通过<strong>参数的静态类型</strong>而不是实际类型作为判定依据的。并且静态类型是编译器可知的。所以在编译阶段，javac编译器就根据参数的静态类型决定使用哪个重载版本，并把这个方法的符号引用写到了main()方法里的两条<code>invokevirtual</code>指令的参数中。</p><p>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用就是<strong>方法重载</strong>，静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p><h2 id="什么是动态分派"><a href="#什么是动态分派" class="headerlink" title="什么是动态分派"></a>什么是动态分派</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"man, say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"women, say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human women = <span class="keyword">new</span> Women();</div><div class="line"></div><div class="line">        man.sayHello();</div><div class="line">        women.sayHello();</div><div class="line"></div><div class="line">        man = <span class="keyword">new</span> Women();</div><div class="line">        man.sayHello();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">man, say hello</div><div class="line">women, say hello</div><div class="line">women, say hello</div></pre></td></tr></table></figure><p>变量man在两次调用中执行了不同的方法，很明显的原因是这个两个变量的实际类型不同，那么Java虚拟机是如何根据实际类型来分派方法执行版本的呢？其原因需要从<code>invokevirtual</code>指令的多态查找过程说起，<code>invokevirtual</code>指令的运行时解析过程的步骤为：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；</li><li>如果类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ol><p>由于<code>invokevirtual</code>指令执行的第一步是在运行期确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是java语言方法重写的本质。</p><p>并且把这种在运行期间根据实际类型确定方法执行版本的分派过程称为动态分派。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      主要介绍了Java虚拟机的类加载器、类加载过程。
    
    </summary>
    
      <category term="jvm" scheme="http://www.vibrancy.cn/categories/jvm/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="jvm" scheme="http://www.vibrancy.cn/tags/jvm/"/>
    
      <category term="类加载" scheme="http://www.vibrancy.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识自查表——垃圾收集</title>
    <link href="http://www.vibrancy.cn/repository/jvm-knowledge-self-gc.html"/>
    <id>http://www.vibrancy.cn/repository/jvm-knowledge-self-gc.html</id>
    <published>2017-06-17T10:37:26.000Z</published>
    <updated>2017-06-17T10:56:29.897Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="垃圾收集器主要针对哪些区域进行内存回收"><a href="#垃圾收集器主要针对哪些区域进行内存回收" class="headerlink" title="垃圾收集器主要针对哪些区域进行内存回收"></a>垃圾收集器主要针对哪些区域进行内存回收</h2><p><strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>三个区域随线程而生，随线程而灭；</p><p>虚拟机栈中的<strong>栈帧</strong>随着方法的进入和退出有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性。</p><p><strong>java堆</strong>和<strong>方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在<strong>程序运行期间才能知道会创建那些对象</strong>，这部分内存的分配和回收都是动态的，垃圾收集所关注的是这部分内存。</p><h2 id="有哪些判断对象是否存活的算法"><a href="#有哪些判断对象是否存活的算法" class="headerlink" title="有哪些判断对象是否存活的算法"></a>有哪些判断对象是否存活的算法</h2><h3 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>Java中并没有选用引用计数器算法来管理内存，其中最主要的原因是很难解决对象之间的相互循环引用的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * JVM Args: -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _MB];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ReferenceCountingGC oA = <span class="keyword">new</span> ReferenceCountingGC();</div><div class="line">        ReferenceCountingGC oB = <span class="keyword">new</span> ReferenceCountingGC();</div><div class="line"></div><div class="line">        oA.instance = oB;</div><div class="line">        oB.instance = oA;</div><div class="line"></div><div class="line">        oA = <span class="keyword">null</span>;</div><div class="line">        oB = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        System.gc();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">2017-05-20T12:51:57.191+0800: 0.217: [GC (System.gc()) [PSYoungGen: 6758K-&gt;712K(38400K)] 6758K-&gt;720K(125952K), 0.0176237 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] </div><div class="line">2017-05-20T12:51:57.206+0800: 0.219: [Full GC (System.gc()) [PSYoungGen: 712K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;591K(87552K)] 720K-&gt;591K(125952K), [Metaspace: 3014K-&gt;3014K(1056768K)], 0.0081622 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] </div><div class="line">Heap</div><div class="line"> PSYoungGen      total 38400K, used 998K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 3% used [0x00000000d5f00000,0x00000000d5ff9b70,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 591K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c93ff0,0x0000000087180000)</div><div class="line"> Metaspace       used 3037K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 330K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>当把\(oA\)和\(oB\)对两个对象的引用置空时，这两个对象已经不可能再被访问，但是这两个对象内部还互相引用着对方，导致他们的引用计数器不为0，于是引用计数器算法无法通知计数器回收他们。</p><p>但是通过运行结果\(6758K-&gt;720K\)可知，虚拟机并没有因为这两个对象互相引用就不回收他们，从侧面说明了虚拟机并<strong>不是通过引用计数算法</strong>来判断对象是否存活的。</p><h3 id="根搜索算法（GC-Roots-Tracing）"><a href="#根搜索算法（GC-Roots-Tracing）" class="headerlink" title="根搜索算法（GC Roots Tracing）"></a>根搜索算法（GC Roots Tracing）</h3><p>通过定义一系列名为\(GC\ Roots\)对象作为起点，从起点向下搜索，搜索所走过的路径称为<strong>引用链</strong>。当一个对象到\(GC\ Roots\)没有任何引用链相连时，则证明此对象是不可用的。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.jpg" alt="image"></p><p>如上图所示，对象\(object5,object6,object7\)虽然有关联，但是他们到\(GC\ Roots\)是不可达的，所以他们将会被判定为可回收的对象。</p><p>在Java中，可被作为\(GC\ Roots\)对象包括以下几种：</p><ul><li>虚拟机栈（栈帧中的<strong>局部变量表</strong>）中的引用的对象；</li><li>本地方法栈中<strong>JNI</strong>的引用的对象；</li><li>方法区中的<strong>类静态属性</strong>引用的对象；</li><li>方法区中的<strong>常量</strong>引用的对象。</li></ul><h2 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h2><p>Java对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种，这四种引用强度<strong>依次逐渐减弱</strong>。</p><ul><li><strong>强引用</strong>：指在程序代码之中普遍存在的，类似\(Object\ obj = new\ Object()\)这类引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。</li><li><strong>软引用</strong>：用来描述一些还有用，但是非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中，并进行第二次回收。如果这次回收之后没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用</strong>：用来描述非必须的对象，被弱引用关联的对象只能生存到<strong>下一次垃圾收集发生之前</strong>，不论内存是否足够，都会回收掉弱引用关联的对象。</li><li><strong>虚引用</strong>：最弱的一种引用，无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的<strong>唯一目的</strong>就是希望能在这个对象被回收时收到一个系统通知。</li></ul><h2 id="finalize-终结方法"><a href="#finalize-终结方法" class="headerlink" title="finalize()终结方法"></a>finalize()终结方法</h2><p>根搜索算法中的不可达对象，至少要经历两次标记过程，才会真正宣告死亡。如某个果对象在进行根搜索后发现没有与\(GC\ Roots\)相连接的引用链，那它将会被第一次标记并且进行一次筛选。</p><p>筛选的条件是此对象是否有必要执行\(finalize()\)方法，如果该方法<strong>已执行过</strong>或<strong>没有覆盖</strong>，则虚拟机将这两种情况视为“没有必要执行”。</p><ul><li>如果没有必要执行，那么进行回收；</li><li>如果有必要执行，那么该对象被放置在一个名为\(F-Queue\)的队列中，并在稍后由一条有虚拟机自动建立、低优先级的\(Finalizer\)线程去执行。\(finalize()\)方法是对象逃脱死亡的最后一次机会，稍后GC将对\(F-Queue\)中的对象进行第二次小规模的标记，如果对象在\(finalize()\)方法中重新被引用，那么在第二次标记时它将被移除“<strong>即将回收的集合</strong>”；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"yes. i am still alive :)"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">super</span>.finalize();</div><div class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</div><div class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        System.gc();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">500</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        System.gc();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">500</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">finalize method executed!</div><div class="line">yes. i am still alive :)</div><div class="line">no, i am dead :(</div></pre></td></tr></table></figure><p>根据执行结果可知，任何对象的\(finalize()\)方法都只会被系统自动调用一次，如果对象面临下一次回收，它的\(finalize()\)方法不会被再次执行。</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>Java虚拟机规范中提到过可以不要求虚拟机在<strong>方法区</strong>或<strong>堆的永久代</strong>实现垃圾收集，因为在此区域进行垃圾收集的“<strong>性价比</strong>”一般比较低；</p><p>在堆中，对新生代进行一次垃圾收集一般可以回收\(70\%-90\%\)的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代的垃圾收集主要分为两部分内容：</p><ul><li><strong>废弃常量</strong>：是指在常量池中的常量不被任何地方引用，那么这个常量将被系统移除常量池。</li><li><p><strong>无用的类</strong>：判定一个类是否无用条件相对苛刻，需要满足以下三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的ClassLoader已经被回收；</li><li><p>该类对应的\(java.lang.Class\)对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>当一个类满足以上三个条件之后，虚拟机可以对其进行回收，但不像对象一样，不使用了就必然回收。是否对类进行回收，HotSpot虚拟机提供了\(-Xnoclassgc\)参数进行控制，还可以使用\(-verbose:class\)以及\(-XX:+TraceClassLoading\)、\(-XX:+TraceClassUnLoading\)查看类的加载和卸载信息。</p><p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景，都需要虚拟机具备<strong>类卸载功能</strong>，以保证永久代不会溢出。</p></li></ul></li></ul><h2 id="有哪些垃圾收集算法，原理及优缺点"><a href="#有哪些垃圾收集算法，原理及优缺点" class="headerlink" title="有哪些垃圾收集算法，原理及优缺点"></a>有哪些垃圾收集算法，原理及优缺点</h2><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><ol><li><p>算法思想：</p><p>首先<strong>标记</strong>处所有需要回收的对象，在标记完成后<strong>统一回收</strong>掉所有被标记的对象。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p></li><li><p>缺点</p><ul><li><strong>效率问题</strong>：标记和清除的过程效率不高；</li><li><strong>空间问题</strong>：标记清除后产生大量<strong>不连续的内存碎片</strong>。空间碎片太多，会导致程序以后运行过程中需要分配较大对象时无法找到足够的连续内存空间而不得不提前触发另一次垃圾收集动作。</li></ul></li></ol><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><ol><li><p>算法思想</p><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完后，就将<strong>还存活着的对象</strong>复制到另一块上去，然后再把已使用过的内存空间一次清理掉。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p></li><li><p>优点</p><p>内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效；</p></li><li><p>缺点</p><ul><li>将内存缩小为原来的一般，代价太高；</li><li>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率会变低。</li></ul></li><li><p>算法改进</p><p>新生代的对象98%都是朝生夕死的，所以并不需要按照\(1:1\)的比例来划分内存空间，而是将内存分为一块较大的\(Eden\)空间和两块较小的\(Survivor\)空间，每次使用\(Eden\)和其中的一块\(Survivor\)空间。当回收时，将\(Eden\)和\(Survivor\)上还存活的对象一次性拷贝到另外一块\(Survivor\)空间上，最后清理\(Eden\)和刚使用的\(Survivor\)空间。</p><p>HotSpot虚拟机默认\(Eden\)和\(Survivor\)的大小比例是\(8:1\)，也就是说，新生代可用空间为整个新生代容量的\(90\%\)，只有\(10\%\)的空间是浪费的。但是也没办法保证每次回收都只有不多于\(10\%\)的对象存活，当\(Survivor\)空间不够用时，需要依赖其他内存（老年代）进行分配担保。</p></li></ol><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>主要用于<strong>老年代</strong>，标记操作和“标记-清除”算法一致，但后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向<strong>一端移动</strong>，并更新引用其对象的指针。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="image"></p><h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h3><p>当前商业虚拟机的垃圾收集都采用“<strong>分代收集</strong>”算法，根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样可以根据各个年代的特点采用<strong>最适当的收集算法</strong>。</p><ul><li>在新生代：每次垃圾收集都有大量的对象死去，只有少量的存活，那么就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</li><li>在老年代：因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“<strong>标记-清理</strong>”或“<strong>标记-整理</strong>”算法来进行回收。</li></ul><h2 id="有哪些垃圾收集器，以及各自的特点"><a href="#有哪些垃圾收集器，以及各自的特点" class="headerlink" title="有哪些垃圾收集器，以及各自的特点"></a>有哪些垃圾收集器，以及各自的特点</h2><p>下图展示了7种不同分代的收集器，如果两个收集器之间存在连线，说明他们可以搭配使用。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><h3 id="Serial收集器（串行收集器）"><a href="#Serial收集器（串行收集器）" class="headerlink" title="Serial收集器（串行收集器）"></a>Serial收集器（串行收集器）</h3><p>Serial收集器是一个单线程收集器，这里说单线程并不是说只会使用一个CPU或一条收集线程去完成垃圾收集工作，而是说他在垃圾收集的时候，必须<strong>暂停其他所有的工作线程</strong>，直到收集结束。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvmSerial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>不过，Serial收集器依然是虚拟机运行在<strong>Client模式</strong>下的默认新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于<strong>没有线程交互的开销</strong>，专心做垃圾收集自然可以获得最高的<strong>单线程收集效率</strong>。</p><h3 id="ParNew收集器（并行新生代收集器）"><a href="#ParNew收集器（并行新生代收集器）" class="headerlink" title="ParNew收集器（并行新生代收集器）"></a>ParNew收集器（并行新生代收集器）</h3><p>ParNew收集器是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial完全一样。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvmParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>ParNew收集器是运行在Server模式下的虚拟机中的<strong>首选新生代收集器</strong>。另外，它还能与CMS收集器（Concurrent Mark Sweep）配合工作，<strong>CMS收集器</strong>是HoSpot虚拟机中第一款真正意义上的==并发==收集器，实现了垃圾收集线程与用户线程同时工作。</p><h3 id="Parallel-Scavenge收集器（并行扫描式收集器）"><a href="#Parallel-Scavenge收集器（并行扫描式收集器）" class="headerlink" title="Parallel Scavenge收集器（并行扫描式收集器）"></a>Parallel Scavenge收集器（并行扫描式收集器）</h3><p>Parallel Scavenge收集器也是一个新生代收集器，是使用<strong>复制算法</strong>的收集器，又是<strong>并行的多线程</strong>收集器。</p><p>Parallel Scavenge收集器的特点是他<strong>关注点</strong>与其他收集器不同：</p><ul><li>\(CMS\)收集器关注点尽可能缩短垃圾收集器时用户线程的停顿时间；停顿时间越短，就越适合与用户交互的程序，良好的响应速度能够提升用户体验；</li><li>\(Parallel\ Scavenge\)收集器的目标则是达到一个可控制的<strong>吞吐量</strong>。所谓吞吐量就是CPU用于<strong>运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值，即\(thruput=\tfrac{T(code\ run)}{T(code\ run)+T(gc)}\)。如果虚拟机总运行时间为100分钟，其中垃圾收集花掉1分钟，那么吞吐量就是\(99\%\)。高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li></ul><p>Parallel Scavenge收集器提供的调节参数：</p><ul><li><strong>-XX:MaxGCPauseMills</strong>：控制最大垃圾收集停顿时间；</li><li><strong>-XX:GCTimeRatio</strong>：直接设置吞吐量大小。</li><li><strong>-XX:+UseAdaptiveSizePolicy</strong>：这是一个开关参数，当打开时，就不需要手工指定新生代的大小(-Xmn)、Eden与Suvivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供共最适合的停顿时间或最大吞吐量，这种方式称为<strong>GC自适应的调节策略</strong>。</li></ul><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用“<strong>标记-整理</strong>”算法，主要使用在Client模式下的虚拟机。</p><p>如果在Server模式下，Serial Old有两个用途：</p><ul><li>在jdk1.5之前版本中与Parallel Scvenge收集器搭配使用；</li><li>作为CMS收集器的后备 预案，在并发收集发生Concurrent Mode Failure的时候使用。</li></ul><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和“<strong>标记-整理</strong>”算法。</p><p>在<strong>吞吐量</strong>以及<strong>CPU资源敏感</strong>的场合，都可以优先考虑\(Parallel\ Scavenge+Parallel Old\)收集器。Parallel Old收集器的工作过程如图所示：</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/Parallel%20Scavenge%20+%20old%20%E5%8A%9F%E8%BF%87%E8%BF%87%E7%A8%8B.png" alt="image"></p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。CMS收集器非常适合基于B/S系统的服务器上，系统停顿时间更短，给用户带来较好的体验。</p><ol><li><p>CMS收集器是基于“<strong>标记-清除</strong>”算法实现的，它的运作过程分为4个步骤：</p><ul><li>初始标记（CMS initial mark）<ul><li>需要“Stop The World”</li><li>标记一下GC Roots能直接关联到的对象，速度很快。</li></ul></li><li>并发标记（CMS concurrent mark）<ul><li>耗时长</li><li>进行GCRoots Tracing的过程；</li></ul></li><li>重新标记（CMS remark）<ul><li>需要“Stop The World”，但比初始标记停止时间短。</li><li>为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</li></ul></li><li><p>并发清除（CMS concurrent sweep）</p><ul><li>耗时长</li></ul><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p></li></ul></li><li>CMS的缺点<ul><li>CMS收集器对CPU资源非常敏感<ul><li>在并发阶段，虽然不会导致用于线程停顿，但会因为占用了一部分线程（CPU资源）而导致应用程序变慢，总吞吐量降低。</li><li>CMS默认启动的回收线程数是\((CPU+3)/4\)。当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过\(25\%\)的CPU资源。但当CPU不足4个时，那么CMS对用于程序的影响可能变得很大。</li></ul></li><li>CMS收集器无法处理浮动垃圾<ul><li>因为收集线程和用户线程并发执行，伴随着程序的执行自然还会有新的垃圾不断产生，CMS无法在本次收集中处理掉他们。</li><li>CMS不能像其他收集器那样等到老年代几乎完全被填满再进行收集，需要预留一<strong>部分空间</strong>提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了\(68\%\)的空间后就会被激活。这是一个保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数\(-XX:CMSInitiatingOccupancyFraction\)的值来提高触发百分比，以便降低内存回收次数获取更好的性能。</li><li>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次\(Concurrent\ Mode\ Failure\)失败，这时候虚拟机将启动后备源：临时启用\(Serial\ Old\)收集器，重新进行老年代的垃圾收集，这样停顿的时间就长了。所以说，参数\(-XX:CMSInitiatingOccupancyFraction\)设置的太高将会很容易导致大量的\(Concurrent\ Mode\ Failure\)失败，性能反而下降。</li></ul></li><li>会产生大量的空间碎片<ul><li>因为CMS收集器是基于“<strong>标记-清除</strong>”算法，收集结束后会产生大量的空间碎片。空间碎片过多时，将会给<strong>大对象分配</strong>带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是<strong>无法找到足够大的连续空间</strong>来分配当前对象，不得不提前触发一次Full GC。</li><li>为了解决CMS产生碎片的问题，CMS收集器提供了参数\(-XX:+UseCMSCompactAlFullCollection\)，用于启用在Full GC完后，额外进行一个碎片整理过程。不过内存整理是无法并发的，空间碎片问题没有了，但是停顿时间变长了。因此，可以使用另一个参数\(-XX:CMSFullGCsBeforeCompaction\)，用于设置在执行了多少次不压缩的Full GC后，跟着来一次带压缩的。</li></ul></li></ul></li></ol><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器是基于“<strong>标记-整理</strong>”算法实现的收集器，也就是说不会产生空间碎片；</p><p>可以非常<strong>精确的控制停顿</strong>，既能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，达到了实时Java的来及收集器特征。</p><p>G1可以实现基本<strong>不牺牲吞吐量的前提</strong>下完成低停顿的内存回收，这是因为它能够极力地<strong>避免全区域的垃圾收集</strong>，之前的收集器进行收集的范围都是整个新生代或老年代。</p><p>而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立取余，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分以及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率</strong>。</p><h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td>虚拟机运行在Client模式下的默认值。使用\(Serial+Serial\ Old\)的收集器组合。</td></tr><tr><td>UseParNewGC</td><td>使用\(ParNew+Serial\ Old\)的收集器组合。</td></tr><tr><td>UseConcMarkSweepGC</td><td>使用\(ParNew+CMS+Serial\ Old\)的收集器组合。\(Serial\ Old\)作为CMS收集器出现\(Concurrent\ Mode\ Failure\)失败后的后备收集器使用。</td></tr><tr><td>UseParallelGC</td><td>虚拟机运行在Server模式下的默认值。使用\(Parallel\ Scavenge+Serial\ Old\)的收集器组合。</td></tr><tr><td>UseParallelOldGC</td><td>使用\(Parallel\ Scavenge+Parallel\ Old\)的收集器组合</td></tr><tr><td>SurvivorRatio</td><td>新生代中的Eden区域与Survivor区域的容量比值，默认为8，代表\(Eden:Survivor=8:1\)。</td></tr><tr><td>PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，大于这个参数的对象将直接在老年代分配。仅在使用Serial和ParNew时生效</td></tr><tr><td>MaxTenuringThreshold</td><td>晋升到老年代的对象年龄。每个对象在坚持过一次\(Minor\ GC\)后，年龄就+1，当超过这个值，就进入老年代。</td></tr><tr><td>UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄。</td></tr><tr><td>HandlePromotionFailure</td><td>是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况。</td></tr><tr><td>ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数</td></tr><tr><td>GCTimeRatio</td><td>GC时间占总时间的比率，默认为99，即允许\(1\%\)的GC时间。仅在使用\(Parallel\ Scavenge\)收集时生效</td></tr><tr><td>MaxGCPauseMills</td><td>设置GC的最大停顿时间，仅在使用\(Parallel\ Scavenge\)收集器时生效</td></tr><tr><td>CMSInitiatingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少次后触发垃圾收集，默认值为\(68\%\)，仅在使用CMS收集器时生效</td></tr><tr><td>UseCMDCompactAlFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用CMS收集器时生效</td></tr><tr><td>CMSFullGCsBeforeCompactions</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效。</td></tr></tbody></table><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><p>Java技术体系中提倡的自动内存管理最终可以归结为自动化解决两个问题：<strong>给对象分配内存</strong>以及<strong>回收分配给对象的内存</strong>。</p><p>对象的内存分配，往大的方向上讲，就是在<strong>堆</strong>上分配，对象主要分配在<strong>新生代的Eden区</strong>上，少数情况下也可能直接分配在<strong>老年代</strong>。分配的规则并不是百分之百固定，其细节取决于当前使用的是哪一种<strong>垃圾收集器组合</strong>，以及虚拟机中与内存相关的<strong>参数的设置</strong>。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次\(Minor\ GC\)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* JVM Args: -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</div><div class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        testAllocation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">[GC (Allocation Failure) [PSYoungGen: 7459K-&gt;712K(9216K)] 7459K-&gt;6864K(19456K), 0.0041970 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </div><div class="line">[Full GC (Ergonomics) [PSYoungGen: 712K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6739K(10240K)] 6864K-&gt;6739K(19456K), [Metaspace: 3080K-&gt;3080K(1056768K)], 0.0089859 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </div><div class="line">Heap</div><div class="line"> PSYoungGen      total 9216K, used 2212K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">  eden space 8192K, 27% used [0x00000000ff600000,0x00000000ff8290f0,0x00000000ffe00000)</div><div class="line">  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</div><div class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</div><div class="line"> ParOldGen       total 10240K, used 6739K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  object space 10240K, 65% used [0x00000000fec00000,0x00000000ff294d98,0x00000000ff600000)</div><div class="line"> Metaspace       used 3104K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 337K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>虚拟机参数设置解析：</p><ul><li><strong>-Xms20M</strong>：设置Java堆的大小为20M；</li><li><strong>-Xmx20M</strong>：Java堆不可扩展；</li><li><strong>-Xmn10M</strong>：Java堆中新生代的大小为10M，剩余10M分配给老年代；</li><li><strong>-XX:SurvivorRatio=8</strong>：决定了新生代中Eden与一个Survivor区的空间比例为\(8:1\)。</li><li><strong>-XX:+PrintGCDetails</strong>：虚拟机在垃圾收集时进行日志打印，并且在进程退出时输出当前内存各区域的分配情况。</li></ul><p>执行\(testAllocation()\)中分配\(allocation4\)对象的语句时会发生一次\(Minor\ GC\)，当GC完成后，内存总量则几乎没有减少，因为\(allocation1,2,3\)三个对象都是存活的，虚拟机没有找到可回收的对象。</p><p>GC发生 的原因是给allocation4分配内存的时候，发现Eden已经占用了6MB，剩余空间不足以分配allication4分配的内存时，因此发生了GC。</p><p>GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓大对象是指需要<strong>大量连续内存空间</strong>的Java对象，最典型的大对象是那种很长的<strong>字符串及数组</strong>。对于虚拟机来说，大对象是一个坏消息，尤其是短命的大对象。经常出现大对象容易导致内存还有不少空间的时候就<strong>提前触发垃圾收集以获取足够的连续空间</strong>来安置他们。</p><p>虚拟机提供一个\(-XX:PretenureSizeThreshold\)参数来控制，令大于这个设置值的对象直接在老年代分配。避免在Eden区及两个Survior区之间发生大量的内存拷贝，因为新生代采用复制算法收集内存。另外，<code>PretenureSizeThreshold</code>参数只对Serial 和ParNew两款收集器有效，Parallel Scavenge不认识这个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * -XX:+UseParNewGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:PretenureSizeThreshold=2097152</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PretenureSizeThresholdTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release</div><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 1315K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  16% used [0x00000000fec00000, 0x00000000fed48e40, 0x00000000ff400000)</div><div class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)</div><div class="line"> Metaspace       used 2927K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 320K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>可见运行结果，Eden空间几乎没有使用，而老年代10MB空间被使用了40%，也就是说4MB空间的allocation对象直接就分配在老年代中。</p><h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>虚拟机采用了分代收集的思想来管理内存，通过给每个对象定义一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将别移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区每熬过一次MinorGC，年龄就加1岁，当年龄超过\(-XX:MaxTenuringThreshold\)设置的值时，就会被晋升到老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</div><div class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</div><div class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</div><div class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">    allocation3 = <span class="keyword">null</span>;</div><div class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>设置\(-XX:MaxTenuringThreshold=1\)</p><p>allocation1对象需要256KB的内存空间，Survivor空间可以容纳。在第二次GC发生后，allocation1进入了老年代，新生代使用的GC内存后变成0KB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 4260K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0290f0, 0x00000000ff400000)</div><div class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 4959K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  48% used [0x00000000ff600000, 0x00000000ffad7cb8, 0x00000000ffad7e00, 0x0000000100000000)</div><div class="line"> Metaspace       used 3006K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 327K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li><li><p>设置\(-XX:MaxTenuringThreshold=15\)</p><p>第二次GC发生后，allocation1对象则还留在新生代Survivor空间，这时候新生代仍然有404KB的空间被占用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 4587K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff021ed8, 0x00000000ff400000)</div><div class="line">  from space 1024K,  34% used [0x00000000ff400000, 0x00000000ff458f20, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 4967K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  48% used [0x00000000ff600000, 0x00000000ffad9cb8, 0x00000000ffad9e00, 0x0000000100000000)</div><div class="line"> Metaspace       used 3075K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 334K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li></ul><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>其实为了更好的适应不同程序的内存状态，虚拟机并不总是要求对象的年龄必须达到\(MaxTenuringThreshold\)才能晋升老年代，如果在Survivor空间中<strong>相同年龄的对象大小</strong>总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</div><div class="line">    <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</div><div class="line">    <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</div><div class="line">    <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">    allocation4 = <span class="keyword">null</span>;</div><div class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 4531K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff021f80, 0x00000000ff400000)</div><div class="line">  from space 1024K,  29% used [0x00000000ff400000, 0x00000000ff44ad78, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 5234K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  51% used [0x00000000ff600000, 0x00000000ffb1c948, 0x00000000ffb1ca00, 0x0000000100000000)</div><div class="line"> Metaspace       used 3060K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 333K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p></p><p>allocation1，allocation2对象都直接进入了老年代，没有等到15岁的临界接线。因为这两个对象加起来已经达到512KB，并且他们是同年的，满足同年对象达到Survivor空间一般的规则。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次<strong>晋升到老年代的平均大小</strong>是否大于老年代的剩余空间：</p><ul><li>如果大于，则改为直接进行一次Full GC。</li><li>如果小于，则查看\(HandlePromotionFailure\)设置是否允许担保失败<ul><li>如果允许，那只会进行Minor GC；</li><li>如果不允许，则要改为进行一次Full GC。</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      主要介绍了Java虚拟机的垃圾回收算法和垃圾回收器。
    
    </summary>
    
      <category term="jvm" scheme="http://www.vibrancy.cn/categories/jvm/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="jvm" scheme="http://www.vibrancy.cn/tags/jvm/"/>
    
      <category term="垃圾回收算法" scheme="http://www.vibrancy.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
      <category term="垃圾收集器" scheme="http://www.vibrancy.cn/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识自查表——Java内存区域</title>
    <link href="http://www.vibrancy.cn/repository/jvm-knowledge-self-java-memory-area.html"/>
    <id>http://www.vibrancy.cn/repository/jvm-knowledge-self-java-memory-area.html</id>
    <published>2017-06-17T09:36:44.000Z</published>
    <updated>2017-06-17T11:14:08.748Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="运行时数据区有哪些"><a href="#运行时数据区有哪些" class="headerlink" title="运行时数据区有哪些"></a>运行时数据区有哪些</h2><p>运行时数据区主要分为所有<strong>线程共享</strong>的数据区和<strong>线程隔离</strong>的数据区。</p><ol><li>线程共享的数据区主要包括<strong>方法区</strong>和<strong>Java堆</strong>；</li><li>线程隔离的数据区主要包括<strong>虚拟机栈</strong>、<strong>程序计数器</strong>和<strong>本地方法栈</strong>。</li></ol><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvmJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="image"></p><h2 id="什么是程序计数器以及他的用途"><a href="#什么是程序计数器以及他的用途" class="headerlink" title="什么是程序计数器以及他的用途"></a>什么是程序计数器以及他的用途</h2><p>程序计数器是一块较小的内存空间，它的用于<strong>当前线程</strong>执行字节码的<strong>信号指示器</strong>。字节码指示器通过<strong>改变</strong>这个计数器的值来选取下一个需要执行的字节码指令。</p><p>由于Java虚拟机的多线程是通过<strong>线程轮流切换</strong>并分配<strong>CPU执行时间</strong>来的方式来实现的，在一个时间片内，一个处理器只会执行一个线程指令。因此，为了在线程切换后能够恢复到正确的执行位置，每个线程都需要独立的程序计数器，互补影响，独立存储（这也是为什么程序计数器数据区是线程隔离的原因）。</p><h2 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h2><p>Java的虚拟机栈也是线程私有的，它的生命周期与线程相同。它描述的是Java方法执行的内存模型：每个方法执行的时候都会创建一个<strong>栈帧</strong>，每个方法从调用到执行完成的过程，就对应一个<strong>栈帧</strong>在虚拟机栈里面从<strong>入栈到出栈</strong>的过程。</p><p>Java虚拟机规范对虚拟机栈定义了两种异常情况</p><ol><li><strong>StackOverflowError</strong>：如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的最大深度，将抛出该异常。</li><li><strong>OutOfMemoryError</strong>：一般虚拟机可以动态扩展，如果扩展后也无法申请到足够内存时将抛出该异常。</li></ol><h2 id="什么是栈帧"><a href="#什么是栈帧" class="headerlink" title="什么是栈帧"></a>什么是栈帧</h2><p><strong>栈帧</strong>是用于支持虚拟机进行<strong>方法调用</strong>和<strong>方法执行</strong>的数据结构，它是虚拟机运行时数据区<strong>虚拟机栈</strong>的栈元素。栈帧中存储了方法的<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>和<strong>方法返回地址</strong>等信息。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E6%A0%88%E5%B8%A7%E7%9A%84%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84.svg" alt="image"></p><p>一个线程的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来讲，在活动线程中，<strong>只有栈顶的栈帧是有效的</strong>，称为“<strong>当前栈帧</strong>”，当前栈帧所关联的方法称为<strong>当前方法</strong>。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p><p>在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于虚拟机的具体实现。</p><h2 id="什么是局部变量表"><a href="#什么是局部变量表" class="headerlink" title="什么是局部变量表"></a>什么是局部变量表</h2><p>局部变量表是一组<strong>变量值存储空间</strong>，用于存放<strong>方法参数</strong>和方法内部定义的<strong>局部变量</strong>。</p><p>局部变量表所需要的<strong>空间大小</strong>会在程序编译期就完全确定下来，在方法的<strong>Code属性的max_locals数据项</strong>中存储了该方法所以需要分配的最大局部变量表的容量。局部变量表的容量以<strong>变量槽</strong>为最小单位，一般一个slot的长度为32位。对于64位的数据类型，虚拟机会以高位在前的方式为其分配<strong>两个连续的slot空间</strong>。由于局部变量表是建立在线程堆栈上，是线程私有的数据，无论读写两个连续的slot是否是原子操作，都<strong>不会引起数据安全问题</strong>。</p><h2 id="如何访问局部变量表"><a href="#如何访问局部变量表" class="headerlink" title="如何访问局部变量表"></a>如何访问局部变量表</h2><p>虚拟机通过<strong>索引定位的方式</strong>。因为变量在局部变量表中都是按照顺序来排列的，当参数表分配完毕后，再根据方法内部定义的局部变量顺序和作用域分配其余slot。如果是实例方法，那么在局部变量表中第0位索引的slot默认是方法所属对象的this引用。</p><h2 id="讲讲局部变量表的slot可重用特性"><a href="#讲讲局部变量表的slot可重用特性" class="headerlink" title="讲讲局部变量表的slot可重用特性"></a>讲讲局部变量表的slot可重用特性</h2><p>在方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码的PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的slot可以交由其他变量使用。</p><ol><li><p>如果执行GC时，变量还在作用域之内，那么无论如何都不会回收的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">        System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">垃圾收集结果：</div><div class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 66141K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 75% used [0x0000000081c00000,0x0000000085c97450,0x0000000087180000)</div><div class="line"> Metaspace       used 3175K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li><li><p>如果执行GC时，在变量的作用域之外，从代码逻辑上讲，placeholder已经不可能再被访问，但实际结果来看，这64MB的内存并没有被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">    &#125;</div><div class="line">    System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">垃圾收集结果：</div><div class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 66141K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 75% used [0x0000000081c00000,0x0000000085c97450,0x0000000087180000)</div><div class="line"> Metaspace       used 3175K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li><li><p>在变量的作用域之外，初始化另一个局部变量，此时执行GC，将会回收内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</div><div class="line">    System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">运行结果:</div><div class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 605K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c97440,0x0000000087180000)</div><div class="line"> Metaspace       used 3175K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li></ol><p>在第一次修改后，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保存着对他的关联。</p><h2 id="什么是操作数栈"><a href="#什么是操作数栈" class="headerlink" title="什么是操作数栈"></a>什么是操作数栈</h2><p>当一个方法刚刚开始执行的时候，这个方法的<strong>操作数栈是空的</strong>。在方法执行的过程中，会有各种字节码指令向操作数栈中<strong>写入和提取内容</strong>，也就是入栈和出栈操作。</p><p>操作数栈的最大深度也是在编译期就确定下来，记录到Code属性的max_stacks数据项中。</p><p>操作数栈的每一个元素可以是任意的Java数据类型。另外，操作数栈的<strong>元素类型</strong>必须与字节码的指令序列<strong>要求的类型</strong>严格匹配。</p><h2 id="什么是动态连接"><a href="#什么是动态连接" class="headerlink" title="什么是动态连接"></a>什么是动态连接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属<strong>方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态连接。</p><h2 id="什么是方法返回地址"><a href="#什么是方法返回地址" class="headerlink" title="什么是方法返回地址"></a>什么是方法返回地址</h2><p>当一个方法被执行后，有两种方式退出这个方法。</p><ol><li>执行引擎遇到任意一个<strong>方法返回的字节码指令</strong>，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>正常完成出口</strong>。</li><li>当方法执行遇到了异常，并且这个异常没有在方法体内得到处理，没有在本方法内的异常表中搜索到匹配的异常处理器，就会导致方法退出，这种退出的方式称为<strong>异常完成出口</strong>。</li></ol><p>当方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过<strong>异常处理器表</strong>决定，栈帧中一般不会保存这部分消息。</p><p>方法退出的过程实际上等同于把<strong>当前栈帧出栈</strong>，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用者指令后面的一条指令。</p><h2 id="什么是Java堆"><a href="#什么是Java堆" class="headerlink" title="什么是Java堆"></a>什么是Java堆</h2><p>Java堆是Java虚拟机所管理的内存中最大的一块，也是被所有线程共享的一块区域，在虚拟机启动时创建。此内存存在的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p><p>Java堆也是垃圾收集器管理的主要区域，因此很多时候也被称作“<strong>GC堆</strong>”（Garbage Collected Heap），Java堆会划分成很多区域</p><ul><li><p>从<strong>内存回收</strong>的角度来看</p><p>由于现在收集器基本采用的是<strong>分代收集算法</strong>，所以Java堆还可以细分为<strong>新生代</strong>和<strong>老年代</strong>，新生代还分有<code>Eden</code>、<code>FromSurvivor</code>和<code>ToSurvivor</code>空间。</p></li><li><p>从<strong>内存分配</strong>的角度来看，线程共享的Java堆会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p></li></ul><p>无论如何划分区域，都与存储内容无关，无论哪个区域，存储的都是对象实例，进一步划分是为了更好的回收内存，或者更快的分配内存。</p><p>另外，Java堆可以处于<strong>物理上不连续</strong>的内存空间中，只要<strong>逻辑上是连续</strong>的即可。在实现时，既可以实现固定大小的，也可以是扩展的。不过主流虚拟机都是按照<strong>可扩展</strong>来实现的（通过\(-Xmx\)和\(-Xms\)来控制）。如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出<strong>OutOfMemeoryError</strong>异常。</p><h2 id="什么是方法区"><a href="#什么是方法区" class="headerlink" title="什么是方法区"></a>什么是方法区</h2><p>方法区和Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p><p>Java虚拟机规范对这个区域的管理非常宽松，除了<strong>不需要连续的内存</strong>和可以选择<strong>固定大小或可扩展</strong>外，还可以选择<strong>不实现垃圾收集</strong>。不实现垃圾收集，并非数据进入方法区就如“永久代”的名字一样永久存在了，对这个区域的==内存回收目标==主要是针对<strong>常量池的回收</strong>和对<strong>类型的卸载</strong>。</p><p><strong>运行时常量池</strong>（Runtime Constant Pool）是方法区的一部分。Class文件中也有常量池（Constant Pool），Class文件中的<strong>常量池</strong>用于存放编译器生成的各种<strong>字面量</strong>、<strong>符号引用</strong>和<strong>翻译出来的直接引用</strong>，这部分内容将在==类加载后==存放到<strong>方法区的运行时常量池</strong>中。<strong>运行时常量池</strong>的相对于Class文件常量池的另一个重要特征就是<strong>具备动态性</strong>，在运行期间也能将<strong>新的常量</strong>放入池中，例如调用String类的\(intern()\)方法。当常量池无法申请到内存时会抛出\(OutOfMemeoryError\)异常。</p><h2 id="什么是直接内存"><a href="#什么是直接内存" class="headerlink" title="什么是直接内存"></a>什么是直接内存</h2><p>在JDK1.4中新加入的NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的\(DirectByteBuffer\)对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免在Java堆和Native堆中来回复制数据。</p><p>这部分内存也会导致\(OutOfMemoryError\)异常出现，虽然不会受到Java堆大小的限制，但是，既然是内存，则肯定会受到<strong>本机总内存的大小</strong>和<strong>处理器寻址空间</strong>的限制。</p><h2 id="如何去访问对象"><a href="#如何去访问对象" class="headerlink" title="如何去访问对象"></a>如何去访问对象</h2><p>对象访问在Java语言中无处不在，即使是最简单的访问，也会涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系。例如如下代码：<code>Object obj = new Object();</code></p><ul><li><strong>Object obj</strong>：这部分语义会反映到<strong>虚拟机栈的局部变量表</strong>中，作为一个reference类型数据存在。</li><li><strong>new Object()</strong>：这部分语义会反映到<strong>Java堆</strong>中，形成一块存储了Object类型所有实例数据值（对象中各个实例字段的数据）的<strong>结构化内存</strong>。另外，在Java堆中还必须包含能查找到此<strong>对象类型数据</strong>（如对象类型、父类、实现的接口、方法等）的<strong>地址信息</strong>，这些<strong>类型数据存储到方法区</strong>中。</li></ul><p>Java虚拟机规范规定了<strong>虚拟机栈的局部变量表</strong>中的reference类型为一个指向对象的引用，并没有定义这个引用应该通过<strong>哪种方式</strong>去定位，以及通过哪种方式去访问到Java堆中的对象的<strong>具体位置</strong>。不同的虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：</p><ul><li><p>使用句柄访问方式</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="image"></p><p>Java堆中将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了<strong>对象实例数据</strong>和<strong>类型数据</strong>各自的具体地址信息。</p><p><strong>使用句柄访问的优点</strong>：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中实例数据指针，而reference本身不许要被改变。</p></li><li><p>使用直接指针访问方式</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="image"></p><p>Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是<strong>对象的地址</strong>。</p><p><strong>使用直接指针访问方式的优点</strong>：速度更快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这种开销积少成多也是一项非常可观的成本。</p></li></ul><h2 id="内存分配参数解释"><a href="#内存分配参数解释" class="headerlink" title="内存分配参数解释"></a>内存分配参数解释</h2><table><thead><tr><th>参数名</th><th>用途</th></tr></thead><tbody><tr><td>-Xms</td><td>设置初始堆内存</td></tr><tr><td>-Xmx</td><td>设置最大可用内存，如果最大可用内存和初始内存相同，可以避免每次垃圾回收后重新分配内存</td></tr><tr><td>-Xss</td><td>设置每个线程的堆栈容量大小，理论上减少这个值能生成更多的线程</td></tr><tr><td>-Xoss</td><td>设置本地方法栈的大小</td></tr><tr><td>-XX:PermSize</td><td>设置方法区初始内存大小</td></tr><tr><td>-XX:MaxPermSize</td><td>设置方法区最大内存大小</td></tr><tr><td>-XX:MaxDirectMemorySize=10M</td><td>设置最大直接内存大小</td></tr></tbody></table><h2 id="如何实现Java堆溢出"><a href="#如何实现Java堆溢出" class="headerlink" title="如何实现Java堆溢出"></a>如何实现Java堆溢出</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证<strong>GC Roots到对象之间有可达路径</strong>来避免垃圾回收机制清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> Object());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">Dumping heap to java_pid12160.hprof ...</div><div class="line">Exception in thread &quot;main&quot; Heap dump file created [28125483 bytes in 0.211 secs]</div><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</div><div class="line">	at java.util.ArrayList.grow(ArrayList.java:261)</div><div class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</div><div class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</div><div class="line">	at java.util.ArrayList.add(ArrayList.java:458)</div><div class="line">	at com.cwc.test.jvm.test.HeapOOM.main(HeapOOM.java:14)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div></pre></td></tr></table></figure><h2 id="如何实现虚拟机栈和本地方法栈溢出"><a href="#如何实现虚拟机栈和本地方法栈溢出" class="headerlink" title="如何实现虚拟机栈和本地方法栈溢出"></a>如何实现虚拟机栈和本地方法栈溢出</h2><p>在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，\(-Xoss\)参数虽然存在，但实际上是无效的，栈容量只由\(-Xss\)参数设定。</p><ul><li><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出\(StackOverflowError\)异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss128k</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stackLength++;</div><div class="line">        stackLeak();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JavaVMStackSOF sof = <span class="keyword">new</span> JavaVMStackSOF();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            sof.stackLeak();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            System.out.println(<span class="string">"stack length:"</span> + sof.stackLength);</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  运行结果：</div><div class="line">  stack length:978</div><div class="line">  Exception in thread &quot;main&quot; java.lang.StackOverflowError</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10)</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">···</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.main(JavaVMStackSOF.java:18)</div><div class="line">  	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">  	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">  	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">  	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">  	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div></pre></td></tr></table></figure><p>结果表明：在<strong>单个线程</strong>下，无论是由于栈帧太大，还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是\(StackOverflowError\)异常。</p></li><li><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出\(OutOfMemoryError\)异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss2M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doNotStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    doNotStop();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</div><div class="line">        oom.stackLeakByThread();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<strong>多线程环境</strong>下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。因为，操作系统分配给每个进程的内存是有限制的，虚拟机提供参数来控制<strong>Java堆</strong>和<strong>方法区</strong>的这两部分内存的最大值。</p><p>假如剩余内存有2GB，减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存小，可以忽略。如果虚拟机进程本身耗费的内存在计算在内，剩下的内存就由<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>“瓜分”了。++每个线程分配到的栈容量越大，可以建立的线程数量自然就越少++，建立线程时就越容易把剩下的内存耗尽。</p><p>因此，如果是建立多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过<strong>减少最大堆</strong>和<strong>减少栈容量</strong>来换取更多的线程。</p></li></ul><h2 id="如何实现运行时常量池溢出"><a href="#如何实现运行时常量池溢出" class="headerlink" title="如何实现运行时常量池溢出"></a>如何实现运行时常量池溢出</h2><p>如果要向运行时常量池添加内容，最简单的方法就是使用\(String.intern()\)这个Native方法。由于运行时常量池分配在方法区内，我们可以通过\(-XX:permSize\)和\(-XX:MaxPermSize\)限制方法区的大小，从而间接限制其中的常量池容量。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        String s = <span class="string">"abc"</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            s += s;</div><div class="line">            list.add(s.intern());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space  </div><div class="line">    at java.lang.String.intern(Native Method)  </div><div class="line">    at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)</div></pre></td></tr></table></figure><p>从运行结果可看出，运行时常量池溢出，在\(OutOfMemoryError\)后面的提示信息“PermGen Space”，说明运行时常量池处于方法区。</p><h2 id="怎样实现方法区溢出"><a href="#怎样实现方法区溢出" class="headerlink" title="怎样实现方法区溢出"></a>怎样实现方法区溢出</h2><p>方法区用于存放Class的相关信息，如<strong>类名、访问修饰符、常量池、字段描述、方法描述</strong>等。对于这个区域的测试，基本思路是运行时<strong>产生大量的类</strong>去填满方法区，直到溢出。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">            enhancer.setSuperclass(OOMObject.class);</div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">            enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; methodProxy.invokeSuper(o, args));</div><div class="line">            enhancer.create();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾回收器回收掉，判定条件非常苛刻。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。在大量JSP或动态产生JSP文件的应用（JSP第一次运行会被编译为Java类）、基于OSGI的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）。</p><h2 id="怎样实现本机直接内存溢出"><a href="#怎样实现本机直接内存溢出" class="headerlink" title="怎样实现本机直接内存溢出"></a>怎样实现本机直接内存溢出</h2><p>DirectMemory容量可以通过\(-XX:MaxDirectMemorySize\)指定，如果不指定，则默认与Java堆的最大值(-Xmx指定)一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</div><div class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</div><div class="line"></div><div class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            unsafe.allocateMemory(_1MB);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      主要介绍了Java虚拟机内存的各个区域，及其作用、服务对象以及其中可能产生的问题。
    
    </summary>
    
      <category term="jvm" scheme="http://www.vibrancy.cn/categories/jvm/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="jvm" scheme="http://www.vibrancy.cn/tags/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.vibrancy.cn/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>多线程知识自查表——并发基础理论</title>
    <link href="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-basic-theory.html"/>
    <id>http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-basic-theory.html</id>
    <published>2017-06-13T08:44:55.000Z</published>
    <updated>2017-06-13T11:25:32.605Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="什么是对象的状态"><a href="#什么是对象的状态" class="headerlink" title="什么是对象的状态"></a>什么是对象的状态</h2><p>对象的状态是指存储在<strong>实例</strong>或<strong>静态域</strong>中的数据。</p><ul><li>如果对象中所有的域都是<strong>基本类型的变量</strong>，那么这些域将构成对象的全部状态；</li><li>如果对象中的域<strong>引用了其他的对象</strong>，那么该对象的状态将包含被引用对象的域。例如，LinkedList对象的状态包括该链表中所有节点对象的状态。</li></ul><p>一个对象是否线程安全的，取决于它是否被多个线程访问。当有多个线程访问某个<strong>状态变量</strong>并且其中有一个线程执行写入操作时，那么必须采用<strong>同步机制</strong>来协同这些线程对变量的访问。</p><h2 id="对象的哪些域不属于对象状态的一部分"><a href="#对象的哪些域不属于对象状态的一部分" class="headerlink" title="对象的哪些域不属于对象状态的一部分"></a>对象的哪些域不属于对象状态的一部分</h2><p>如果以某个对象为根节点构造一张对象图，那么该<strong>对象状态</strong>将是对象图中的所有对象包含的域的<strong>一个子集</strong>。也就是说，在定义哪些变量将构成对象的状态时，<strong>只考虑对象拥有的数据</strong>。所有权意味着控制权，然而，<strong>如果发布了某个可变对象的引用，那么就不再拥有独占的控制权</strong>，最多是“<strong>共享控制权</strong>”。对于从构造函数中传递进来的对象，类通常并不拥有这些对象。</p><p><strong>容器类</strong>通常表现出一种“所有权分离”的形式，其中容器类拥有自身的状态，客户代码则拥有容器中各个对象的状态。</p><h2 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h2><p>当多个线程访问某个类时，这个类<strong>始终</strong>都能表现出<strong>正确的行为</strong>，那么就称这个类是线程安全的。</p><p><strong>无状态对象一定是线程安全的</strong>。因为它既<strong>不包含任何域</strong>，又不包含任何对<strong>其他类中的域的引用</strong>。</p><p>方法中的临时变量一定是线程安全的，因为计算过程中的临时状态仅存在于线程栈上的局部变量表中，并且只能由正在执行的线程访问。</p><h2 id="线程安全核心是什么"><a href="#线程安全核心是什么" class="headerlink" title="线程安全核心是什么"></a>线程安全核心是什么</h2><p>线程安全核心在于要对<strong>状态访问操作</strong>进行管理，其中的状态主要包括以下两种状态：</p><ol><li><strong>共享的</strong>（Shared）：变量可以由多个线程同时访问；</li><li><strong>可变的</strong>（Mutable）：变量的值在其生命周期内可以发生变化。</li></ol><h2 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h2><p>例如，在一个计数器程序中，定义一个int类型的实例变量用于统计某个方法的访问次数，该方法每调用一次，就执行<code>i++</code>操作，但该操作并不是线程安全的。因为看上去<code>i++</code>是一个非常紧凑的语法，但是该操作<strong>并不是原子的</strong>。实际上，它包括了三个独立的操作：读取i的值，将值+1，然后将计算结果写入i。也就是说，这是一个<strong>读取——修改——写入</strong>的操作序列，其<strong>结果状态依赖于之前的状态</strong>。</p><p>所以，一个操作的原子性是指该操作是不可分割的，其他线程只能在修改操作完成之前或之后读取和修改状态，而不能在修改状态的过程中。</p><h2 id="什么是竞态条件"><a href="#什么是竞态条件" class="headerlink" title="什么是竞态条件"></a>什么是竞态条件</h2><p>在并发编程中，当某个计算取决于<strong>多线程的交替执行时序</strong>时，那么就会发生<strong>竞态条件</strong>（Race Condition）。多数情况下，竞态条件不一定会发生错误，还需要某种<strong>不恰当的执行时序</strong>。</p><p>竞态条件的常见情况</p><ol><li><strong>延迟初始化</strong></li><li><strong>基于对象之前的状态来定义对象状态的转换</strong></li></ol><p>解决竞态条件的方法就是需要包含一组以原子方式执行的操作。可以使用<code>java.util.concurrent.atomic</code>包中的一些原子变量类，用于实现在数值和对象引用上的原子状态转换。或者使用锁将保护的代码路径以<strong>串行方式</strong>来访问，使复合操作成为原子操作。</p><h2 id="Java提供了哪些同步机制"><a href="#Java提供了哪些同步机制" class="headerlink" title="Java提供了哪些同步机制"></a>Java提供了哪些同步机制</h2><p>主要的同步机制是关键字<code>synchronized</code>，它提供了一种独占的加锁方式。另外，还包括<code>volatile</code>类型的变量，<strong>显式锁</strong>以及<strong>原子变量</strong>。</p><h2 id="什么是synchronized"><a href="#什么是synchronized" class="headerlink" title="什么是synchronized"></a>什么是synchronized</h2><p>Java提供了一种内置锁来支持原子性：<strong>同步代码块</strong>。同步代码块包括两个部分，一个作为<strong>锁的对象引用</strong>，一个作为这个锁<strong>保护的代码块</strong>。</p><p>以<code>synchronized</code>来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的<strong>对象</strong>，静态的<code>synchronized</code>方法以Class对象作为锁。</p><p>Java内置锁相当于一种互斥体，意味着最多只有一个线程能够持有这种锁，其他线程必须等待或阻塞，直到持有这个锁的线程释放锁。</p><p>如果某个线程视图已经获得某个对象的锁，那么持有锁的过程中，也可以访问该对象的其他<code>synchronized</code>来修饰的方法，这个称作锁的<strong>可重入</strong>。<strong>重入</strong>意味着获取锁的操作的粒度是<strong>线程</strong>，而不是<strong>调用</strong>。假设没有可重入的锁，那么就会发生死锁。因此，重入避免了这种死锁的发生。</p><p>另外，仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调多线程对某个变量的访问，那么在访问这个变量的<strong>所有位置都需要使用同步</strong>，而且该同步锁必须是<strong>同一把锁</strong>。</p><p>如果不加区别的将每个方法都加上锁，这可能会导致<strong>活跃性问题</strong>或<strong>性能问题</strong>。如果该加锁的方法是一个耗时操作，那么其他所有的线程都必须等待。当执行时间较长的计算或者可能无法快速完成的操作时，一定不要持有锁。</p><p>因此，可以缩小同步代码块的范围，做到既保证并发性，同时又维护线程安全性。不过，要确保同步代码块不要太小，并且不要将本应是原子的操作拆分到多个同步代码块中。尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去。</p><h2 id="什么是volatile关键字"><a href="#什么是volatile关键字" class="headerlink" title="什么是volatile关键字"></a>什么是volatile关键字</h2><ol><li><p>用途</p><p>volatile修饰的变量可用来确保<strong>该变量的更新操作</strong>会通知到其他线程。访问volatile变量的时候不会执行加锁操作，也就不会线程阻塞。因此，volatile变量是一种比sychronized关键字更轻量级的同步机制。从<strong>内存可见性</strong>的角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</p></li><li><p>应用场景</p><p>volatile变量通常用作于某个<strong>操作完成、发生中断或者状态的标志</strong>。</p></li><li><p>使用条件</p><ul><li>对变量的写入操作不依赖当前的值（避免出现竞态条件），或者能够确保只有单个线程更新变量的值；</li><li>该变量不会与其他状态变量一起纳入不变性条件中；</li><li>在访问变量时不需要加锁。</li></ul></li><li><p>与Synchronized的区别</p><p><strong>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性</strong>。因为volatile的语义不足以确保<strong>递增操作</strong>的原子性，除非能够保证只有一个线程对变量执行写操作。</p></li></ol><h2 id="什么是对象的发布"><a href="#什么是对象的发布" class="headerlink" title="什么是对象的发布"></a>什么是对象的发布</h2><p><strong>发布</strong>（Publish）一个对象是指使对象能够在<strong>当前作用域之外</strong>的代码中使用。例如，将一个指向对象的引用保存到其他代码可以访问的地方；或者将引用传递到其他类的方法中。</p><h2 id="什么是对象的逃逸"><a href="#什么是对象的逃逸" class="headerlink" title="什么是对象的逃逸"></a>什么是对象的逃逸</h2><p>逃逸是指当发布一个对象时，在该对象的<strong>非私有域中引用的所有对象</strong>同样会被发布。某个对象逃逸之后，必须假设有某个类或线程可能会误用该对象。</p><p>另一种特殊的逃逸是指<strong>this引用逃逸</strong>，是指<strong>对象还没有构造完成，它的this引用就会被发布出去</strong>。这会危及到线程安全，因为其他线程可以通过这个逸出的引用访问到<strong>初始化了一半</strong>的对象。其结果就是，某些线程看到该对象的状态是<strong>没初始化完的状态</strong>，而另外一些线程看到的却是已经初始化完的状态，这种不一致性是不确定的，程序也会产生一些无法预知的并发错误。</p><p>this引用逃逸逃逸发生要满足两个条件:</p><ol><li>在构造函数中创建内部类；</li><li>在构造函数中就把这个内部类给发布出去了。</li></ol><p>因此，要防止this引用逸出的方法就是<strong>避免让这两个条件同时出现</strong>。</p><h2 id="什么是线程封闭"><a href="#什么是线程封闭" class="headerlink" title="什么是线程封闭"></a>什么是线程封闭</h2><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。<strong>将某个对象封闭在线程中</strong>，将会自动实现线程安全性，即使被封闭的对象本身不是线程安全的，这种技术被称为<strong>线程封闭</strong>。</p><blockquote><p>线程封闭技术的一个常见应用是JDBC的Connection对象。JDBC规范并不要求Connection对象是安全的。在典型的服务器应用程序中，线程从连接池获得一个Connection对象，并且用该对象来处理请求，使用完对象后再将对象返还给连接池。由于大多数请求都是由单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池<strong>不会再将它分配给其他线程</strong>。因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。</p></blockquote><h2 id="线程封闭有哪些实现"><a href="#线程封闭有哪些实现" class="headerlink" title="线程封闭有哪些实现"></a>线程封闭有哪些实现</h2><ol><li><p><strong>栈封闭</strong></p><p>在栈封闭中，只能通过局部变量才能访问对象，局部变量的特性就是封闭在执行线程中，他们位于执行线程的栈中，其他线程无法访问这个栈。</p><p>另外，在维持对象引用的栈封闭性时，需要保证被引用的对象不会逸出。</p></li><li><p><strong>ThreadLocal</strong></p><p>ThreadLocal类能够使线程的<strong>某个值</strong>与<strong>保存该值的线程对象</strong>关联起来。ThreadLocal提供了get和set等方法，这些方法使每个使用该变量的线程都存有一个独立的副本，因此<strong>get总是返回由当前执行线程在调用set设置的最新值</strong>。</p><p>当某个线程初次调用<code>ThreadLocal.get</code>方法时，就会调用<code>initialValue</code>来获取初始值。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = </div><div class="line">            ThreadLocal.withInitial(() -&gt; DriverManager.getConnecton(DB_URL));</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> connectionHolder.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果此时需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象，可以维持线程安全性，从而<strong>避免了</strong>对可变的<strong>单实例变量</strong>或<strong>全局变量</strong>进行共享。</p><p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望在每次执行时都重新分配该临时对象，就可以使用该技术。</p></li></ol><h2 id="什么是不可变性"><a href="#什么是不可变性" class="headerlink" title="什么是不可变性"></a>什么是不可变性</h2><p>首先不可变对象一定是<strong>线程安全</strong>的。其次，不可变对象需要满足以下条件：</p><ul><li>对象创建后其状态<strong>不能被修改</strong>；</li><li>对象的所有域都是<strong>final类型</strong>；</li><li>对象是<strong>正确创建</strong>的（对象创建期间，this引用没有逸出）。</li></ul><h2 id="final的特点"><a href="#final的特点" class="headerlink" title="final的特点"></a>final的特点</h2><p>用于构造不可变对象，final类型的域是不能被修改的。它会保证不受限制的访问不可变对象，并在共享这些对象是无需同步。</p><p>在编程中，除非需要某个域是可变的，否则应该将其声明为final域；</p><p>当访问和更新多个相关变量时出现竞争条件问题时，可以通过将这些变量全部封装在一个不可变对象中来消除竞争。如果是一个可变对象，那么就<strong>必须使用锁来确保原子性</strong>。如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> BigInteger[] service(BigInteger num) &#123;</div><div class="line">        BigInteger[] lastFactors = cache.getFactors(num);</div><div class="line">        <span class="keyword">if</span> (lastFactors == <span class="keyword">null</span>) &#123;</div><div class="line">            lastFactors = factor(num);</div><div class="line">            cache = <span class="keyword">new</span> OneValueCache(num, lastFactors);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lastFactors;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger lastNumber, BigInteger[] lastFactors)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.lastNumber = lastNumber;</div><div class="line">            <span class="keyword">this</span>.lastFactors = Arrays.copyOf(lastFactors, lastFactors.length);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</div><div class="line">            <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何去安全发布一个对象"><a href="#如何去安全发布一个对象" class="headerlink" title="如何去安全发布一个对象"></a>如何去安全发布一个对象</h2><ol><li><p>对象的发布需求取决于它的可变性</p><ul><li>不可变对象可以通过任意机制来发布；</li><li>事实不可变的对象必须通过安全方式发布；</li><li>可变对象必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来。</li></ul></li><li><p>要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布：</p><ul><li>在<strong>静态初始化函数</strong>中初始化一个对象引用；</li><li>将对象的引用保存到<strong>volatile类型</strong>的域或者AtomicReference对象中；</li><li>将对象的引用保存到某个正确构造对象的<strong>final类型域</strong>中；</li><li>将对象的引用保存到一个由<strong>锁保护的域</strong>中。</li></ul></li><li><p>在并发程序中<strong>使用</strong>和<strong>共享</strong>对象时，可以使用一些使用的策略</p><ul><li><strong>线程封闭</strong>：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由该线程修改；</li><li><strong>只读共享</strong>：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括<strong>不可变对象</strong>和<strong>事实不可变对象</strong></li><li><strong>线程安全共享</strong>：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li><li><strong>保护对象</strong>：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li></ul></li></ol><h2 id="什么是不变性条件和后验条件，以及他们的用途"><a href="#什么是不变性条件和后验条件，以及他们的用途" class="headerlink" title="什么是不变性条件和后验条件，以及他们的用途"></a>什么是不变性条件和后验条件，以及他们的用途</h2><ol><li><p>不变性条件</p><p>用于判断状态是有效还是无效的，不变式表达了对状态的约束，这些状态应该符合这个约束的值的组合。</p></li><li><p>后验条件</p><p>用来判断状态迁移是否有效，规定了调用方法后必须为真的条件。</p></li><li><p>用途</p><p>类的<strong>不变性条件</strong>和<strong>后验条件</strong>约束了对象上有哪些状态和状态转换是<strong>有效的</strong>。如果不了解对象的<strong>不变性条件和后验条件</strong>，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于<strong>原子性</strong>和<strong>封装性</strong>。</p></li></ol><h2 id="什么是同步策略"><a href="#什么是同步策略" class="headerlink" title="什么是同步策略"></a>什么是同步策略</h2><p>同步策略（Synchronization Policy）定义了如何在不违背对象<strong>不变性条件</strong>或<strong>后验条件</strong>的情况下，对状态的访问操作进行协同。同时，同步策略还规定了如何将<strong>不可变性</strong>、<strong>线程封闭</strong>与<strong>加锁机制</strong>等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。</p><h2 id="什么是依赖状态的操作"><a href="#什么是依赖状态的操作" class="headerlink" title="什么是依赖状态的操作"></a>什么是依赖状态的操作</h2><p>在某些对象的方法中包含了一些<strong>基于状态的先验条件</strong>。例如，不能从空队列中删除一个元素，在删除一个元素之前，必须保证队列处于<strong>非空状态</strong>。因此，如果某个操作包含基于状态的先验条件，那么这个操作就称为<strong>依赖状态的操作</strong>。</p><p>在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由其他线程的执行而变为真，在并发程序中要一直等到先验条件成立在执行该操作。要想实现某个等待先验条件为真时才执行的操作，一种更为简单的方法就是通过现有类库（<strong>阻塞队列</strong>[BlockingQueue]）或者<strong>信号量</strong>来实现依赖状态的行为。</p><h2 id="如何设计线程安全的类"><a href="#如何设计线程安全的类" class="headerlink" title="如何设计线程安全的类"></a>如何设计线程安全的类</h2><p>在设计线程安全的类中，需要包含以下三个基本要素：</p><ol><li>找出<strong>构成</strong>对象状态的所有变量；</li><li>找出<strong>约束</strong>对象状态的不变性条件；</li><li>建立对象状态的并发访问管理策略。</li></ol><p><strong>委托</strong>是创建线程安全类的一个最有效的策略，只需让现有的线程安全类管理所有的状态即可。</p><h2 id="如何以线程安全的方式访问非线程安全对象"><a href="#如何以线程安全的方式访问非线程安全对象" class="headerlink" title="如何以线程安全的方式访问非线程安全对象"></a>如何以线程安全的方式访问非线程安全对象</h2><p>可以使用<strong>实例封闭机制</strong>（Instance Confinement），当对象被封闭到另一个对象中时，能够访问被封装对象的所有<strong>代码路径都是已知</strong>的。通过将<strong>封闭机制</strong>与<strong>合适的加锁策略</strong>结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p><p>实例封闭是构建线程安全的一个最简单的方式，简化了线程安全类的实现过程。还使得在<strong>锁策略上的选择</strong>拥有了更多的灵活性，使得不同的状态变量可以由不同的锁策略来保护。</p><p>Java平台类库中，由很多实例封闭的示例，有些类的唯一用途就是将非线程安全的类转换为线程安全的类。例如，包装器工厂方法（Collections.synchronizedList及同族的方法），使得这些非线程安全的类可以安全地用于多线程环境。这些工厂方法利用装饰器模式，使用一个同步的包装器对象包装容器；包装器将相关接口的每个方法实现为同步方法，并将请求转发到下层的容器对象上。只要包装器对象占有着对下层容器唯一的可触及的引用（底层容器限制于包装器内），包装器对象就是线程安全的。</p><h2 id="使用私有的锁对象而不是内置锁的好处"><a href="#使用私有的锁对象而不是内置锁的好处" class="headerlink" title="使用私有的锁对象而不是内置锁的好处"></a>使用私有的锁对象而不是内置锁的好处</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="comment">//修改变量的状态</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>私有的锁可以将被封装起来，使客户端代码无法得到锁；</li><li>但客户端代码可以通过<strong>公有方法来访问锁</strong>，以便正确的参与到它的同步策略中。</li><li>实现更加细粒度的加锁策略来提高可伸缩性。</li></ul><h2 id="如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？"><a href="#如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？" class="headerlink" title="如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？"></a>如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？</h2><p>如果一个类是由多个<strong>独立</strong>且<strong>线程安全的状态变量</strong>组成，并且在所有的操作中都<strong>不包含无效状态转换</strong>，那么可以将线程安全性委托给底层的状态变量，不需要在封装类中再增加一个额外的安全层。</p><p>类似于volatile变量的规则：仅当一个变量参与到包含其他状态变量的不变性条件时，才可以声明为volatile类型。</p><p>例如，在NumberRange使用了两个AtomicInteger来管理状态，并且含有一个约束条件，即第一个数值要小于第二个数值。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger lower = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger upper = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i &gt; upper.get()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">        lower.set(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i &lt; lower.get()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">        upper.set(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInRange</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>然而，NumberRange并不是线程安全的，如果一个线程调用setLower(5)，另一个线程调用setUpper(4)，那么在一些<strong>错误的执行时序</strong>中，这两个调用将会通过检查，并都能执行成功，但结果状态是一个无效的状态。</p><p>因为没有维持对下界和上界进行约束的不变性条件。setLower和setUpper都是“先检查后执行”的操作，但他们<strong>没有使用足够的加锁机制来保证这些操作的原子性</strong>。虽然AtomicInteger是线程安全的，但经过组合得到的类却不是，由于<strong>状态变量lower和upper不是彼此独立的</strong>，因此NumberRange不能将线程安全性委托给它的线程安全状态变量。因此，NumberRange必须通过<strong>加锁机制</strong>来维护不变性条件以确保线程安全性，此外，还必须<strong>避免发布</strong>lower和upper，从而防止客户端代码破坏其不变性条件。</p><h2 id="当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？"><a href="#当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？" class="headerlink" title="当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？"></a>当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？</h2><p>如果一个状态变量是<strong>线程安全</strong>的，并且<strong>没有任何不变性条件</strong>来约束它的值，在变量的操作上也<strong>不存在任何不允许的状态转换</strong>，那么就可以安全的发布这个变量。</p><ol><li><p>线程安全且可变的Point类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafePoint</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span>[] get() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>安全发布底层状态的车辆追踪器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishingVehicleTracker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, SafePoint&gt; locations;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublishingVehicleTracker</span><span class="params">(ConcurrentHashMap&lt;String, SafePoint&gt; locations)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.locations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(locations);</div><div class="line">        <span class="keyword">this</span>.unmodifiableMap = Collections.unmodifiableMap(locations);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, SafePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unmodifiableMap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SafePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> locations.get(id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (locations.replace(id, <span class="keyword">new</span> SafePoint(x, y)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="谈谈对ConcurrentHashMap的了解"><a href="#谈谈对ConcurrentHashMap的了解" class="headerlink" title="谈谈对ConcurrentHashMap的了解"></a>谈谈对ConcurrentHashMap的了解</h2><p>ConcurrentHashMap也是一个基于<strong>散列</strong>的Map，但他使用了一个完全不同的<strong>加锁策略</strong>来提供更高的<strong>并发性</strong>和<strong>伸缩性</strong>。ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种<strong>粒度更细的加锁机制</strong>来实现更大程度的共享，这种机制称为<strong>分段锁</strong>（Lock Striping）。在这种机制中，任意数量的读取线程可以并发的访问Map，执行<strong>读取操作</strong>的线程和执行<strong>写入操作</strong>的线程可以并发地访问Map。ConcurrentHashMap带来的结果就是，在并发访问环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。</p><p>ConcurrentHashMap提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。ConcurrentHashMap返回的迭代器具有<strong>弱一致性</strong>，而并非<strong>及时失败</strong>。弱一致性可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器被构造后将修改操作反映给容器。</p><p>ConcurrentHashMap尽管有这些改进，但仍有一些需要权衡的因素，对于一些需要在<strong>整个Map上进行计算</strong>的方法，例如<strong>size和isEmpty</strong>，这些方法的语义被略微减弱以反映整个容器的并发性。由于size返回的结果在计算时可能已经过期，但他实际上只是一个估计值，因此允许size返回<strong>一个近似值而不是一个精确值</strong>。但是，事实上size和isEmpty这样的方法在并发过程中的用处很小，因为他们的返回值总是不断变化。因此，这些操作的需求被弱化，以换取对其他更重要操作的性能优化。</p><p>ConcurrentHashMap不能被加锁来执行独占的访问，因此无法在客户端加锁来创建新的原子操作。一些常见的复合操作，例如<strong>若没有则添加</strong>、<strong>若相等则移除</strong>、<strong>若相等则替换</strong>，都已实现为原子操作并且在ConcurrentMap接口中声明。如果你需要在现有的同步Map中添加这样的功能，那么就是用<strong>ConcurrentMap接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(K key, V value)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V newValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="谈谈对CopyOnWriteArrayList的了解"><a href="#谈谈对CopyOnWriteArrayList的了解" class="headerlink" title="谈谈对CopyOnWriteArrayList的了解"></a>谈谈对CopyOnWriteArrayList的了解</h2><ol><li><p>基本原理</p><p>CopyOnWrite容器即<strong>写时复制</strong>的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><p>不过在<code>CopyOnWriteArrayList</code>中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p><p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p></li><li><p>应用场景</p><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p></li><li><p>使用注意</p><ul><li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li><li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</li></ul></li><li><p>CopyOnWrite的缺点</p><ul><li>内存占用问题：有可能造成频繁的Yong GC和Full GC</li><li>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li></ul></li></ol><h2 id="基于阻塞队列生产者和消费者模式"><a href="#基于阻塞队列生产者和消费者模式" class="headerlink" title="基于阻塞队列生产者和消费者模式"></a>基于阻塞队列生产者和消费者模式</h2><ol><li><p>什么是生产者——消费者模式</p><p><strong>生产者——消费者</strong>模式将“<strong>找出需要完成的工作</strong>”与“<strong>执行工作</strong>”这两个过程分离开来，并把工作项放入一个“<strong>待完成</strong>”列表中以便在随后处理，而不是找出后立即处理。生产者和消费者模式简化了开发过程，因为它消除了生产者类和消费者类之间的代码依赖性，此外，该模式还将生产数据的过程和使用数据的过程解耦开来以简化工作负载的管理。</p></li><li><p>什么是阻塞队列</p><p>阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法将阻塞直到有空间可用；如果队列为空，那么take方法将会阻塞直到有元素可用。</p></li><li><p>阻塞队列在生产者——消费者模式的运用</p><p>如果生产者生成工作的速率比消费者处理工作的速率快，那么工作项会在队列中累计起来，并最终消耗内存。同样，put方法的阻塞特性极大的简化了生产者的编码。如果使用<strong>有界队列</strong>，那么当队列充满时，生产者将阻塞并且不能继续生成工作，而消费者就有时间赶上工作处理进度。因此，有界队列是一种强大的资源管理工具：<strong>能够抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮</strong>。</p><p>阻塞队列同样提供一个offer方法，如果数据项不能被添加到队列中，那么将返回一个失败状态。这样你就能够创建更多灵活性的策略来处理负荷过载的情况。例如减轻负重，将多余的工作项序列化并写入磁盘，减少生产者线程数量，或通过某种方式抑制生产者线程。</p></li><li><p>阻塞队列的具体实现以及应用</p><p>在类库中包含了BlockingQueue的多种实现，其中LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，二者分别于LinkedList和ArrayList类似，但比同步List拥有更好的并发性。</p><p><strong>PriorityBlockingQueue</strong>是一个按优先级排序的队列，如果希望按照某种顺序而不是FIFO来处理元素时，该队列非常有用。</p><p><strong>SynchronousQueue</strong>不会为队列中的元素维护存储空间，它会维护一组线程。当任务到达的时候，会直接交付工作给某一个线程去执行，从而降低了将数据从生产者移动到消费者的延迟。这就好比，将文件直接交给同事，还是将文件放到他的邮箱并希望他能尽快拿到文件。SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备参与到交付过程中。仅当有足够的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p></li></ol><h2 id="什么是双端队列和工作密取"><a href="#什么是双端队列和工作密取" class="headerlink" title="什么是双端队列和工作密取"></a>什么是双端队列和工作密取</h2><p>Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。</p><p>在生产者——消费者设计中，所有消费者有一个共享的工作队列，而在工作密取设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者各自的双端<strong>队列末尾</strong>秘密地获取工作。</p><p>密取工作模式比传统的生产者——消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。大多数时候，只在访问自己的双端队列，从而极大的减少了竞争。</p><p>工作密取非常适用于既是消费者也是生产者的问题——当执行某个工作可能导致更多的工作。例如，在网页爬虫程序处理一个页面时，通常会发现有更多的页面需要处理。当一个工作线程找到新的任务单元时，它将会放到自己队列的末尾。当双端队列为空时，它会在另一个线程的队列队尾查找新的任务，从而确保每个线程都保持忙碌状态。</p><h2 id="同步工具类用途"><a href="#同步工具类用途" class="headerlink" title="同步工具类用途"></a>同步工具类用途</h2><p>同步工具类可以是任何一个对象，只要它可以<strong>根据其自身的状态来协调线程的控制流</strong>。阻塞队列可以作为同步工具类，其他类型的同步工具还包括信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch）。</p><p>所有的同步工具类都有一些<strong>特定的结构化属性</strong>：封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待。</p><h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><ol><li><p>什么是闭锁</p><p>闭锁是一种同步工具类，可以延迟线程的工作进度直到其到达终止状态。</p></li><li><p>闭锁的作用</p><p>相当于一扇门：在闭锁达到结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当达到结束状态时，这扇门会打开并允许所有线程通过。当闭锁达到结束状态之后，将不会再改变状态，因此这扇门将永远保持打开状态。总而言之，闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。</p></li><li><p>CountDownLatch</p><p>CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的时间都已经发生。如果计数器值非零，那么await会一直阻塞直到计数器为零，或者等待线程中断，或者等待超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</div><div class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    startGate.await();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        task.run();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        endGate.countDown();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        startGate.countDown();</div><div class="line">        endGate.await();</div><div class="line">        <span class="keyword">long</span> end = System.nanoTime();</div><div class="line">        <span class="keyword">return</span> end - start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用于测试n个线程并发执行某个任务是需要的时间，如果在创建线程后立即启动他们，那么先启动的线程会领先后启动的线程，并且活跃线程数量会随着时间的推移而增加或减少，竞争程度也在不断发生变化。</p><p>启动门将使得主线程能够<strong>同时释放所有的工作线程</strong>，而结束门则使主线程能够等待<strong>最后一个线程执行完成</strong>，而不是顺序等待每个线程执行完成。</p></li></ol><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask也可以用作闭锁，表示一种抽象的可生成结果的计算。FutureTask表示的计算是通过Callable来实现，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：<strong>等待运行、正在运行和运行完成</strong>。当FutureTask进入完成状态之后，它会永远停止在这个状态。</p><p>Future.get的行为取决于任务的状态，如果任务已经完成，那么可以立即返回结果，否则将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。FutureTask将计算结果从<strong>执行计算的线程传递到获取这个结果的线程</strong>，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。</p><p>Callable表示的任务可抛出受检查的或未受检查的异常，并且任何代码都可能抛出一个Error。无论任务代码抛出什么异常，都会封装到一个ExecutionException中，并在Future.get中被重新抛出。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p><p>Semaphore中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。在执行操作时候可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，acquire将阻塞直到有许可。release方法将返回一个许可给信号量。</p><p>计算信号量的一种简化形式是<strong>二值信号量</strong>，即初始值为1的Semaphore。二值信号量可以用作互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个许可，谁就拥有了互斥锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;(bound));</div><div class="line">        <span class="keyword">this</span>.sem = <span class="keyword">new</span> Semaphore(bound);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sem.acquire();</div><div class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wasAdded = set.add(o);</div><div class="line">            <span class="keyword">return</span> wasAdded;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</div><div class="line">                sem.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T o)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</div><div class="line">        <span class="keyword">if</span> (wasRemoved) &#123;</div><div class="line">            sem.release();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wasRemoved;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>栅栏（Barrier）类似于闭锁，他能阻塞一组线程直到某个事件发生。</p><p><strong>栅栏与闭锁的关键区别</strong>在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议，例如几个家庭决定要在某个地方集合：“所有人6:00在麦当劳碰头，到了以后要等其他人，之后在讨论下一步要做的事情”。</p><p>CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集，他在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列互相独立的子问题。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到<strong>所有线程都到达栅栏位置</strong>。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有的线程将释放，而栅栏将被重置以便下次使用。</p><h2 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, V&gt; func;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer</span><span class="params">(Function&lt;A, V&gt; func)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.func = func;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">apply</span><span class="params">(A arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Future&lt;V&gt; f = cache.get(arg);</div><div class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">                FutureTask&lt;V&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;V&gt;(() -&gt; func.apply(arg));</div><div class="line">                f = cache.putIfAbsent(arg, futureTask);</div><div class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">                    f = futureTask;</div><div class="line">                    futureTask.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> f.get();</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                cache.remove(arg, f);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="comment">//other </span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Java多线程基础知识部分，介绍了并发性和线程安全性的基本概念，以及构建线程安全类的方法和类库提供的并发构建块的原理及使用
    
    </summary>
    
      <category term="多线程" scheme="http://www.vibrancy.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="多线程" scheme="http://www.vibrancy.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>8大经典排序算法总结</title>
    <link href="http://www.vibrancy.cn/repository/classic-sort.html"/>
    <id>http://www.vibrancy.cn/repository/classic-sort.html</id>
    <published>2017-05-14T00:08:29.000Z</published>
    <updated>2017-06-13T11:49:58.542Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h3><p>按照索引顺序，每一步将该索引上的值插入到前面已经有序的一组的值适当位置（通过从当前索引处往前的挨个比较）上，直到全部插入为止，详细算法步骤如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个X元素，在已经排序的元素序列中从后向前扫描；</li><li>如果扫描到的元素（已排序）大于X元素，将该元素往后移动一个位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于X元素的位置；</li><li>将X元素插入到该位置；</li><li>重复步骤2~4。</li></ol><h3 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA.gif" alt="直接插入排序"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StraightInsertSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; e.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> x = e[i];</div><div class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; e[j] &gt; x; j--) &#123;</div><div class="line">                e[j + <span class="number">1</span>] = e[j];</div><div class="line">            &#125;</div><div class="line">            e[j + <span class="number">1</span>] = x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>当输入数据以<strong>反序</strong>输入时，直接插入排序的时间复杂度为\(O(N^2)\)，因为由于嵌套循环的每一个都花费N次迭代；</li><li>当输入数据已<strong>预先排序</strong>，直接插入排序的时间复杂度为\(O(N)\)，因为内层的for循环的检测总是立即判定不成立而终止。</li><li>直接插入排序适合<strong>数据量比较小</strong>的排序应用；</li><li><strong>逆序数</strong>也正好是需要由插入排序执行的<strong>交换次数</strong>，而一个排过序的数组没有逆序。当输入数据是<code>34,8,64,51,32,21</code>时，该数据有9个逆序，即<code>(34,8),(34,32),(34,21),(64,51),(64,32),(64,21),(51,32),(51,21)</code>以及<code>(32,21)</code>。由于算法还有\(O(N)\)量的其他工作，因此插入排序的运行时间是\(O(I+N)\)，其中I为原始数组中的逆序数。于是，若逆序数是\(O(N)\)，则插入排序以线性时间运行。</li><li>N个互异数的数组的平均逆序数是\(N(N-1)/4\)；</li><li>通过<strong>交换相邻元素</strong>进行排序的任何算法平均时间复杂度都需要\(O(N^2)\)，也就是说，为了使一个排序算法以\(O(N^2)\)时间运行，必须执行一些比较，特别是要对相距较远的元素进行交换。一个排序算法通过删除逆序得以向前进行，而为了有效的进行，他必须使每次交换删除不止一个逆序。</li></ol><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><h3 id="排序思想-1"><a href="#排序思想-1" class="headerlink" title="排序思想"></a>排序思想</h3><p>按照索引顺序，每一步将该索引上的值插入到前面已经有序的一组的值适当位置（通过二分查找法找到，可以减少比较次数）上，直到全部插入为止。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left, current, mid, right;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            current = array[i];</div><div class="line">            left = <span class="number">0</span>;</div><div class="line">            right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">                mid = (left + right) / <span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span> (current &gt; array[mid]) &#123;</div><div class="line">                    left = mid + <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    right = mid - <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= left; k--) &#123;</div><div class="line">                array[k + <span class="number">1</span>] = array[k];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (left != i) &#123;</div><div class="line">                array[left] = current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ol><li>当N比较大时，二分插入排序的比较次数比直接插入排序的最差情况（反序）要好得多，但是比直接插入排序的最好情况（基本有序）要差。</li><li>当元素初始序列接近有序时，直接插入排序比二分插入排序的比较次数少。</li><li>二分插入排序元素移动次数与直接插入排序相同，依赖于元素的初始序列。</li></ol><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="排序思想-2"><a href="#排序思想-2" class="headerlink" title="排序思想"></a>排序思想</h3><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但到了这一步，数据几乎已经排好序。</p><h3 id="排序演示-1"><a href="#排序演示-1" class="headerlink" title="排序演示"></a>排序演示</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E8%B0%A2%E5%B0%94%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png" alt="希尔排序"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] e)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = e.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">int</span> j;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; e.length; i++) &#123;</div><div class="line">                <span class="keyword">int</span> current = e[i];</div><div class="line">                <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; e[j] &gt; current; j -= gap) &#123;</div><div class="line">                    e[j + gap] = e[j];</div><div class="line">                &#125;</div><div class="line">                e[j + gap] = current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><ol><li>如果有一个<strong>很小的数据</strong>在一个已按升序排好序的数组的<strong>末端</strong>，如果用复杂度为\(O(N^2)\)的排序算法（<strong>冒泡排序</strong>或<strong>直接插入排序</strong>），可能会进行<strong>n次的比较和交换</strong>才能将该数据移至正确的位置。而希尔排序会用<strong>较大的步长</strong>移动数据，所以小数据只需要进行<strong>少数比较和交换</strong>即可到正确位置。</li><li>使用增量序列\(h_k\)进行一趟排序后，对于每个i我们都有\(a[i]&lt;=a[i+h_k]\)，所有相隔\(h_k\)的元素都被排序，此时称文件时\(h_k\)排序的。</li><li>\(h_k\)排序的实质就是，将\(h_k\)，\(h_k+1\)，···，\(N-1\)中的每个位置i，把该位置对应的元素放到\(i-{h_k}\)中的正确位置上。</li><li>一趟\(h_k\)排序的作用就是对\(h_k\)个独立的子数组执行一次插入排序。</li><li>一个\(h<em>k\)排序的文件（然后是\(h</em>{k-1}\)排序）会一直保持它的\(h_k\)排序性，前面各趟排序的成果不会被后面的排序打乱。</li><li><p>希尔排序<strong>不是稳定的排序算法</strong></p><p>虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性将会被打乱。</p><p>比如序列{ 3, 5, 10, <strong>8</strong>, 7, 2, <em>8</em>, 1, 20, 6 }h=2时分成两个子序列 { 3, 10, 7, <em>8</em>, 20 } 和 { 5, <strong>8</strong>, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, <em>8</em>, 10, 20 } 和 { 1, 2, 5, 6, <strong>8</strong> } ，即 { 3, 1, 7, 2, <em>8</em>, 5, 10, 6, 20, <strong>8</strong> } ，两个8的相对次序发生了改变。</p></li></ol><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="排序思想-3"><a href="#排序思想-3" class="headerlink" title="排序思想"></a>排序思想</h3><p>按照索引顺序，每趟会在该索引后的元素中找出一个最小元素与当前索引处的元素进行交换。</p><h3 id="排序演示-2"><a href="#排序演示-2" class="headerlink" title="排序演示"></a>排序演示</h3><ol><li><p>简单排序过程示例</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.jpg" alt="简单排序"></p></li><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="简单排序"></p></li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> minValue = array[i];</div><div class="line">            <span class="keyword">int</span> minIndex = i;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt; minValue) &#123;</div><div class="line">                    minValue = array[j];</div><div class="line">                    minIndex = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            array[minIndex] = array[i];</div><div class="line">            array[i] = minValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><ol><li>简单选择排序的时间复杂度都为\(O(N^2)\)；</li><li>是不稳定的排序算法</li></ol><h3 id="简单选择排序的改进"><a href="#简单选择排序的改进" class="headerlink" title="简单选择排序的改进"></a>简单选择排序的改进</h3><p>将每趟循环可以确定两个元素（最大和最小值），从而减少排序所需的循环次数。 改进后对\(N\)个数据进行排序，最多只需进行\(N/2\)趟即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, min, max, len = array.length; i &lt;= len / <span class="number">2</span>; i++) &#123;</div><div class="line">            min = max = i;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= len - i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &gt; array[max]) &#123;</div><div class="line">                    max = j;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt; array[min]) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//该交换操作还可分情况讨论以提高效率</span></div><div class="line">            Utils.swap(array, min, i - <span class="number">1</span>);</div><div class="line">            Utils.swap(array, max, len - i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="排序思想-4"><a href="#排序思想-4" class="headerlink" title="排序思想"></a>排序思想</h3><p>优先队列可以用于以<code>O(NlogN)</code>时间来排序，基于该思想的算法叫做<strong>堆排序heapsort</strong>。在建立N个元素的二叉堆时，该阶段花费\(O(N)\)时间，然后又执行N次deleteMin操作，由于每个deleteMin花费时间\(O(logN)\)，因此总运行时间是\(O(NlogN)\)。</p><p>优先队列的算法主要问题在于，它使用了一个附加数组，因此，存储需求增加一倍。但不会太影响时间问题，附加的时间消耗只有\(O(N)\)，只是增加了空间复杂度。</p><p>那么对于以上问题，在堆排序中的解决方案是：在每次deleteMin之后，将堆缩小1。因此，堆中的最后一个单元可以用来存放刚刚删除的元素。使用这种策略，在最后一次deleteMin之后，该数组将以递减的顺序包含这些元素。如果想要排成更典型的递增顺序，那么可以在构建堆的时候建立<strong>最大堆</strong>。</p><h3 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt=""></p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            percolateDown(array, i, array.length);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">            Utils.swap(array, <span class="number">0</span>, i);</div><div class="line">            percolateDown(array, <span class="number">0</span>, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">percolateDown</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> child;</div><div class="line">        <span class="keyword">int</span> tmp;</div><div class="line">        <span class="keyword">for</span> (tmp = a[i]; leftChild(i) &lt; n; i = child) &#123;</div><div class="line">            child = leftChild(i);</div><div class="line">            <span class="comment">//找到i孩子节点中最大的一个</span></div><div class="line">            <span class="keyword">if</span> (child != n - <span class="number">1</span> &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>]) &#123;</div><div class="line">                child++;<span class="comment">//i的右孩子</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (tmp &lt; a[child]) &#123;<span class="comment">//如果较大的子结点大于父结点  </span></div><div class="line">                a[i] = a[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点 </span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        a[i] = tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="排序思想-5"><a href="#排序思想-5" class="headerlink" title="排序思想"></a>排序思想</h3><p>通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了，重复N次即可以使数组有序。</p><h3 id="排序演示-3"><a href="#排序演示-3" class="headerlink" title="排序演示"></a>排序演示</h3><ol><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm739525-20160329100443676-1647340243%5B1%5D.gif" alt=""></p></li><li><p>排序过程示意图</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.jpg" alt=""></p></li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="comment">// j &lt; array.length - i - 1 意思是后面的已经有序，不需要在判断</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">                    Utils.swap(array, j, j + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h3><p>冒泡排序是基于比较的算法，时间复杂度为\(O(N^2)\)，只有在<strong>n比较小</strong>的时候性能才比较好。</p><h3 id="冒泡排序算法改进"><a href="#冒泡排序算法改进" class="headerlink" title="冒泡排序算法改进"></a>冒泡排序算法改进</h3><ol><li><p>设置一个标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos之后的记录均已交换到位，因此在下一趟排序时只要扫描到pos位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; ) &#123;</div><div class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                    <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">                        pos = j;</div><div class="line">                        Utils.swap(array, j, j + <span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                i = pos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>传统冒泡排序在每趟的操作中只能找到一个最大值或最小值，因此，考虑利用在每趟排序中进行正向和反向的两边冒泡方法一次可以得到两个最终值（最大值和最小值），从而使排序趟数几乎减少一半。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</div><div class="line">               <span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</div><div class="line">                   Utils.swap(array, i, i + <span class="number">1</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           high--;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = high; i &gt; low; i--) &#123;</div><div class="line">               <span class="keyword">if</span> (array[i] &lt; array[i - <span class="number">1</span>]) &#123;</div><div class="line">                   Utils.swap(array, i, i - <span class="number">1</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           low++;</div><div class="line">       &#125;</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="排序思想-6"><a href="#排序思想-6" class="headerlink" title="排序思想"></a>排序思想</h3><ol><li>选取一个基准pivot元素，通常选择第一个元素或者最后一个元素；</li><li>进行分区partition操作，通过一趟排序将待排序的记录分割成两个部分，其中一个部分的元素均比基准元素小，另一部分元素均比基准元素大；</li><li>对每个分区递归地进行步骤1~3，递归的结束条件是子序列的大小是0或1，这时整体已经排好序。</li></ol><h3 id="排序演示-4"><a href="#排序演示-4" class="headerlink" title="排序演示"></a>排序演示</h3><ol><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt=""></p></li><li><p>排序过程</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png" alt=""></p></li></ol><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">            <span class="keyword">int</span> pivot = partition(array, low, high);</div><div class="line">            quickSort(array, <span class="number">0</span>, pivot - <span class="number">1</span>);</div><div class="line">            quickSort(array, pivot + <span class="number">1</span>, high);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pivot = array[low]; low &lt; high; ) &#123;</div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[high] &gt;= pivot) &#123;</div><div class="line">                high--;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[low] &lt;= pivot) &#123;</div><div class="line">                low++;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h3><ol><li>最<strong>坏</strong>的情况下，也就是每次选取的基准都是<strong>最大或最小的元素</strong>（例如，在上例7,8,10,9中），导致每次只划分出了一个子序列，需要进行n-1次划分才能结束递归，时间复杂度为<code>O(n^2)</code>；</li><li>最好的情况下，每次选取的基准都能均匀划分，只需要<code>logN</code>次划分就能结束递归，时间复杂度为<code>O(logN)</code>。</li><li>平均情况下，需要的时间复杂度为<code>O(NlogN)</code>。</li><li>快速排序不是稳定的排序算法。</li></ol><h3 id="快速排序算法改进"><a href="#快速排序算法改进" class="headerlink" title="快速排序算法改进"></a>快速排序算法改进</h3><p>快速排序通常被认为在同数量级\(O(NlogN)\)的排序方法中性能最好的，若初始序列已经基本有序，快排反而退化为冒泡排序。</p><p>在改进的算法中，只对长度大于k的子序列递归调用快速排序，让原序列基本有序，然后再对整个基本有序的序列使用直接插入排序。实践证明，改进后的算法时间复杂度有所降低，且当k取8左右的时候，改进算法的性能最优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        quickSortImprove(array, <span class="number">0</span>, array.length - <span class="number">1</span>, k);</div><div class="line">        StraightInsertSort.sort(array);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortImprove</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (high - low &gt; k) &#123;</div><div class="line">            <span class="keyword">int</span> pivot = partition(array, low, high);</div><div class="line">            quickSortImprove(array, <span class="number">0</span>, pivot - <span class="number">1</span>, k);</div><div class="line">            quickSortImprove(array, pivot + <span class="number">1</span>, high, k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pivot = array[low]; low &lt; high; ) &#123;<span class="comment">//从表的两端交替地向中间扫描</span></div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[high] &gt;= pivot) &#123; <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端</span></div><div class="line">                high--;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[low] &lt;= pivot) &#123;</div><div class="line">                low++;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><h3 id="排序思想-7"><a href="#排序思想-7" class="headerlink" title="排序思想"></a>排序思想</h3><p>归并排序是采用分治法的一个非常典型的应用，归并排序的思想就是先<strong>递归分解</strong>数组，再<strong>合并数组</strong>。</p><p>先考虑<strong>合并</strong>两个有序数组，基本思路是两个输入数组A和B，一个输出数组C，以及3个计数器ai、bi、ci，他们的初始置于对应数组的开始端。A[ai]和B[bi]中的最小者被拷贝到C中的下一个位置，相关的计数器向前推进一步。当两个输入表有一个用完时，则将另一个表剩余部分拷贝到C中。</p><p>再考虑<strong>递归分解</strong>，基本思路是将数组分解成<code>left</code>和<code>right</code>，如果这两个数组内部数据是有序的，那么就可以用上面的合并数组方式将这两个数组合并排序。如何让这两个数组内部有序？可以再二分，直至分解出的小组含有一个元素为止，此时认为该小组内部已有序，然后<strong>合并</strong>排序相邻两个小组即可。</p><h3 id="排序演示-5"><a href="#排序演示-5" class="headerlink" title="排序演示"></a>排序演示</h3><ol><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="归并排序动图"></p></li><li><p>排序过程</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">before sort= 5 9 4 3 2 6 10 1 7 8 </div><div class="line">-------------------</div><div class="line">left[0:0]  = 5 </div><div class="line">                    ====&gt; 5 9 0 0 0 0 0 0 0 0 </div><div class="line">right[1:1] = 9 </div><div class="line">-------------------</div><div class="line">left[0:1]  = 5 9 </div><div class="line">                    ====&gt; 4 5 9 0 0 0 0 0 0 0 </div><div class="line">right[2:2] = 4 </div><div class="line">-------------------</div><div class="line">left[3:3]  = 3 </div><div class="line">                    ====&gt; 4 5 9 2 3 0 0 0 0 0 </div><div class="line">right[4:4] = 2 </div><div class="line">-------------------</div><div class="line">left[0:2]  = 4 5 9 </div><div class="line">                    ====&gt; 2 3 4 5 9 0 0 0 0 0 </div><div class="line">right[3:4] = 2 3 </div><div class="line">-------------------</div><div class="line">left[5:5]  = 6 </div><div class="line">                    ====&gt; 2 3 4 5 9 6 10 0 0 0  </div><div class="line">right[6:6] = 10 </div><div class="line">-------------------</div><div class="line">left[5:6]  = 6 10 </div><div class="line">                    ====&gt; 2 3 4 5 9 1 6 10 0 0  </div><div class="line">right[7:7] = 1 </div><div class="line">-------------------</div><div class="line">left[8:8]  = 7 </div><div class="line">                    ====&gt; 2 3 4 5 9 1 6 10 7 8 </div><div class="line">right[9:9] = 8 </div><div class="line">-------------------</div><div class="line">left[5:7]  = 1 6 10 </div><div class="line">                    ====&gt; 2 3 4 5 9 1 6 7 8 10</div><div class="line">right[8:9] = 7 8 </div><div class="line">-------------------</div><div class="line">left[0:4]  = 2 3 4 5 9 </div><div class="line">                    ====&gt; 1 2 3 4 5 6 7 8 9 10 </div><div class="line">right[5:9] = 1 6 7 8 10 </div><div class="line">-------------------</div><div class="line"></div><div class="line">after sort = 1 2 3 4 5 6 7 8 9 10</div></pre></td></tr></table></figure></li></ol><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] tmpArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</div><div class="line">        sort(array, tmpArray, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</div><div class="line">            sort(array, tmp, left, center);</div><div class="line">            sort(array, tmp, center + <span class="number">1</span>, right);</div><div class="line">            merge(array, tmp, left, center + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmpArray, <span class="keyword">int</span> leftStart, <span class="keyword">int</span> rightStart, <span class="keyword">int</span> rightEnd)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> leftEnd = rightStart - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> tmpStart = leftStart;</div><div class="line">        <span class="keyword">int</span> numElements = rightEnd - leftStart + <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (leftStart &lt;= leftEnd &amp;&amp; rightStart &lt;= rightEnd) &#123;</div><div class="line">            <span class="keyword">if</span> (array[leftStart] &lt;= array[rightStart]) &#123;</div><div class="line">                tmpArray[tmpStart++] = array[leftStart++];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tmpArray[tmpStart++] = array[rightStart++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*将left剩余元素复制到tmp中*/</span></div><div class="line">        <span class="keyword">while</span> (leftStart &lt;= leftEnd) &#123;</div><div class="line">            tmpArray[tmpStart++] = array[leftStart++];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/*将right剩余元素复制到tmp中*/</span></div><div class="line">        <span class="keyword">while</span> (rightStart &lt;= rightEnd) &#123;</div><div class="line">            tmpArray[tmpStart++] = array[rightStart++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++, rightEnd--) &#123;</div><div class="line">            array[rightEnd] = tmpArray[rightEnd];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h3><ol><li>归并排序是经典的分治策略，它将问题<strong>分（divide）</strong>成一些小问题然后递归求解，而<strong>治（conquer）</strong>的阶段则将分的阶段解得的各答案修补在一起。</li><li>最差的情况下，归并排序的运行时间是\(O(NlogN)\)，但是有一个明显的问题，整个算法还要花费将数据拷贝到临时数组再拷贝回来这样一个附加的工作，明显减慢了排序的速度。</li><li>归并排序使用所有流行排序算法中最少的比较次数。</li></ol><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><h3 id="排序思想-8"><a href="#排序思想-8" class="headerlink" title="排序思想"></a>排序思想</h3><p>将数组中的相邻元素两两配对，构成\(N/2\)个长度为2的排好序的子数组，然后再将他们排序成长度为4的子数组段，如此下去，直至整个数组排好序。</p><h3 id="排序演示-6"><a href="#排序演示-6" class="headerlink" title="排序演示"></a>排序演示</h3><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序非递归图解"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 非递归排序</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = <span class="number">1</span>, len = array.length, tmpIndex, leftStart, leftEnd, rightStart, rightEnd; gap &lt; len; gap *= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (tmpIndex = <span class="number">0</span>, leftStart = <span class="number">0</span>; leftStart &lt; len - gap; leftStart = rightEnd) &#123;</div><div class="line">                <span class="keyword">if</span> ((rightEnd = ((rightStart = leftEnd = leftStart + gap) + gap)) &gt; len) &#123;</div><div class="line">                    rightEnd = len;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (leftStart &lt; leftEnd &amp;&amp; rightStart &lt; rightEnd) &#123;</div><div class="line">                    tmp[tmpIndex++] = array[leftStart] &gt; array[rightStart] ? array[rightStart++] : array[leftStart++];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (leftStart &lt; leftEnd) &#123;</div><div class="line">                    array[--rightStart] = array[--leftEnd];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (tmpIndex &gt; <span class="number">0</span>) &#123;</div><div class="line">                    array[--rightStart] = tmp[--tmpIndex];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="排序综合比较"><a href="#排序综合比较" class="headerlink" title="排序综合比较"></a>排序综合比较</h1><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">最差时间复杂度</th><th style="text-align:center">最优时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">辅助空间</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">二分插入排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">\(O(NlogN)-O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N^{1.3})\)</td><td style="text-align:center">\(O(NlogN)-O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(logN)-O(N)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">\(O(N+K)\)</td><td style="text-align:center">\(O(N+K)\)</td><td style="text-align:center">\(O(N+K)\)</td><td style="text-align:center">\(O(K)\)</td><td style="text-align:center">稳定</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://segmentfault.com/a/1190000002595152#articleHeader18" target="_blank" rel="external">常用排序算法总结（性能+代码）</a></li><li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">经典排序算法总结与实现</a></li><li><a href="http://blog.csdn.net/morewindows/article/details/7961256" target="_blank" rel="external">白话经典算法系列</a></li><li><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="external">排序算法可视化</a></li><li><a href="http://blog.csdn.net/super_chris/article/details/4581900" target="_blank" rel="external">所谓堆和堆排序</a></li><li><a href="http://6924918.blog.51cto.com/6914918/1260860" target="_blank" rel="external">几种经典排序算法</a></li><li><a href="https://www.byvoid.com/zhs/blog/sort-radix" target="_blank" rel="external">三种线性排序算法 计数排序、桶排序与基数排序</a></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文是对8大排序算法总结，包括其排序思想、动图演示、代码实现和结论。
    
    </summary>
    
      <category term="算法" scheme="http://www.vibrancy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="8大排序算法" scheme="http://www.vibrancy.cn/tags/8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java8 HashMap原理分析</title>
    <link href="http://www.vibrancy.cn/repository/java8-HashMap-principle-analysis.html"/>
    <id>http://www.vibrancy.cn/repository/java8-HashMap-principle-analysis.html</id>
    <published>2017-05-03T04:55:16.000Z</published>
    <updated>2017-05-15T11:56:10.510Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</li><li>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li>映射中的key是不可变对象，不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</li></ol><h3 id="类继承关系图"><a href="#类继承关系图" class="headerlink" title="类继承关系图"></a>类继承关系图</h3><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/diagram.svg" alt="hashmap"></p><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="几个重要的属性"><a href="#几个重要的属性" class="headerlink" title="几个重要的属性"></a>几个重要的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">transient Node&lt;K, V&gt;[] table; </div><div class="line">int threshold;</div><div class="line">final float loadFactor;</div><div class="line">transient int size; </div><div class="line">transient int modCount;</div><div class="line">static final int TREEIFY_THRESHOLD = 8;</div></pre></td></tr></table></figure><ol><li><p>table</p><ul><li>哈希桶数组</li><li>初始化长度length默认为16，长度必须为2的n次方（合数）。</li><li>常规设计是把length设计为<strong>素数</strong>，来减少hash冲突的概率。而HashMap在此是为了在<strong>取模和扩容</strong>的时候做优化，同时也为了减少冲突。</li></ul></li><li><p>loadFactor</p><ul><li>负载因子，是table中<strong>元素数量</strong>和<strong>table长度</strong>的比值。</li><li>默认值是0.75</li></ul></li><li><p>threshold</p><ul><li>HashMap所能容纳的最大数据量的Node(键值对)个数；</li><li>计算公式：<code>threshold = table.length * loadFactor</code>，结合公式可知，threshold是负载因子和数组长度对应下允许的最大元素数目，如果超过这个数目，那么就得重新扩容（resize），扩容后的容量是之前容量的2倍。</li><li>如果<strong>内存空间大</strong>而又对<strong>时间效率要求很高</strong>，可以<strong>降低</strong>负载因子Load factor的值。</li><li>如果<strong>内存空间紧张</strong>而对<strong>时间效率要求不高</strong>，可以<strong>增加</strong>负载因子loadFactor的值，这个值可以大于1。</li></ul></li><li><p>size</p><ul><li>HashMap中实际存在的键值对数量；</li><li>注意与<code>table.length</code>、<code>threshold</code>的区别。</li></ul></li><li><p>modCount</p><ul><li>记录HashMap内部结构发生变化的次数；</li><li>用于迭代的快速失败。</li></ul></li><li><p>TREEIFY_THRESHOLD</p><ul><li>链表转红黑树的长度阈值。</li></ul></li></ol><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>从结构实现来讲，HashMap是<strong>数组+链表+红黑树</strong>来实现的。</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/hashmap-inner-structure.png" alt="image"></p><p>从源码可知，<code>HashMap类</code>中有一个非常重要的字段，就是<code>Node[] table</code>，即上图中的<strong>哈希桶数组table</strong>，是一个<code>Node类型</code>的数组。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;</div><div class="line">    final int hash; //用来定位数组索引的位置</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K, V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry接口</code>，本质是就是一个映射(键值对)，上图中的每个黑色圆点就是一个<code>Node对象</code>。</p><p>HashMap就是使用<strong>哈希表</strong>来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题，Java中HashMap采用了<strong>链地址法</strong>，链地址法简单来说，就是数组加链表的结合。在每个数组元素上都对应一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p><p>如果<strong>哈希桶数组</strong>很大，即使较差的Hash算法也会比较分散；如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡。其实就是根据实际情况实行哈希数组的<strong>扩容或收缩</strong>，并在此基础上设计<strong>好的hash算法</strong>减少Hash碰撞。</p><p>负载因子和Hash算法设计的再合理，也免不了会出现链表过长的情况，一旦链表过长，则会严重影响HashMap的性能。当链表长度太长（默认超过<code>TREEIFY_THRESHOLD</code>）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><h3 id="核心方法分析"><a href="#核心方法分析" class="headerlink" title="核心方法分析"></a>核心方法分析</h3><h4 id="根据键值计算哈希桶数组的索引"><a href="#根据键值计算哈希桶数组的索引" class="headerlink" title="根据键值计算哈希桶数组的索引"></a>根据键值计算哈希桶数组的索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*</div><div class="line">* 根据key计算hash值</div><div class="line">*/</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    // h = key.hashCode(); 第一步、取 kek的hashCode值</div><div class="line">    // h ^ (h &gt;&gt;&gt; 16) 第二步、取hash的高位与hash参与异或运算</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 根据hash值和数组长度，计算key在table中的索引。</div><div class="line">* JDK8 中没有该方法，它直接在方法内部计算 hash &amp; (length - 1) 的值</div><div class="line">*/</div><div class="line">private static int indexFor(int hash, int length) &#123;</div><div class="line">    return hash &amp; (length - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不管是增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。对于任意给定的对象，只要hashCode相同，那么<code>hash()</code>方法返回的hash值总是相同的。一般情况下，将hash值与数组长度进行<strong>取模运算</strong>来得到数组索引，但是取模运算的消耗还是比较大的。在HashMap中，通过<code>indexFor()</code>方法来计算索引。</p><p><code>indexFor()</code>方法非常的巧妙，通过<code>hash &amp; (length-1)</code>得到对象的保存位置。因为HashMap底层数组的长度总是2的n次方，这时<code>hash &amp; (length-1)</code>运算等价于hash对length的取模，&amp;比%具有更高的效率。</p><p>画图说明<code>hash()</code>和<code>indexFor()</code>的运算过程:<br><img src="http://op87q3xru.bkt.clouddn.com/image/java/hash-indexfor.png" alt="image"></p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ol><li><p>put()流程</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/HashMap%20put%E6%B5%81%E7%A8%8B.jpg" alt="image"></p></li><li><p>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">               boolean evict) &#123;</div><div class="line">    Node&lt;K, V&gt;[] tab;</div><div class="line">    Node&lt;K, V&gt; p;</div><div class="line">    int n, i;</div><div class="line">    //table 是否为空 或者 长度为0</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0) &#123;</div><div class="line">        // resize 重新扩容</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    &#125;</div><div class="line">    //如果当前table索引上的值为空</div><div class="line">    if ((p = tab[i = hash &amp; (n - 1)]) == null)</div><div class="line">        //直接将值插入</div><div class="line">        tab[i] = newNode(hash, key, value, null);</div><div class="line">    else &#123;</div><div class="line">        Node&lt;K, V&gt; e;</div><div class="line">        K k;</div><div class="line">        // 如果 key 并且 hash 相同</div><div class="line">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            e = p;//直接覆盖value</div><div class="line">        else if (p instanceof TreeNode)</div><div class="line">            //如果是红黑树，则直接在树中插入键值对</div><div class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value);</div><div class="line">        else &#123;</div><div class="line">            //开始循环，遍历链表</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line"></div><div class="line">                if ((e = p.next) == null) &#123;</div><div class="line">                    //到了链表末尾</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div class="line">                        //链表长度大于8转换为红黑树进行处理</div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                // 如果 key 并且 hash 相同</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    //直接覆盖value</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        //超过最大容量 就扩容</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p><strong>扩容</strong>(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</p><p>下面举个例子说明下扩容过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;</div><div class="line">    HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(2);</div><div class="line">    printInfo(map, &quot;初始化HashMap的信息为：&quot;);</div><div class="line">    int[] values = &#123;3, 7, 5, 9&#125;;</div><div class="line">    for (int i = 0; i &lt; values.length; i++) &#123;</div><div class="line">        map.put(values[i], &quot;v&quot;);</div><div class="line">        printInfo(map, String.format(&quot;添加第%d个元素[%s=%s]后的info：&quot;, i + 1, values[i], &quot;v&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下图所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">初始化HashMap的信息为：</div><div class="line">size: 0</div><div class="line">tableLength: 0</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 2</div><div class="line">modCount: 0</div><div class="line">table:	null</div><div class="line"></div><div class="line">添加第1个元素[3=v]后的info：</div><div class="line">size: 1</div><div class="line">tableLength: 2</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 1</div><div class="line">modCount: 1</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [3=v]</div><div class="line"></div><div class="line">添加第2个元素[7=v]扩容后的info：</div><div class="line">size: 2</div><div class="line">tableLength: 4</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 3</div><div class="line">modCount: 2</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | null</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div><div class="line"></div><div class="line">添加第3个元素[5=v]后的info：</div><div class="line">size: 3</div><div class="line">tableLength: 4</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 3</div><div class="line">modCount: 3</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [5=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div><div class="line"></div><div class="line">添加第4个元素[9=v]扩容后的info：</div><div class="line">size: 4</div><div class="line">tableLength: 8</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 6</div><div class="line">modCount: 4</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v]</div><div class="line">	 4   | null</div><div class="line">	 5   | [5=v]</div><div class="line">	 6   | null</div><div class="line">	 7   | [7=v]</div></pre></td></tr></table></figure><p></p><p>经过观测可发现，HashMap的table数组长度使用的是2次幂的扩展（长度扩展为原来2倍），数组扩展后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置，扩展后对于<strong>元素新位置的判断</strong>对应的源码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">HashMap.resize():</div><div class="line"></div><div class="line">Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">Node&lt;K,V&gt; next;</div><div class="line">do &#123;</div><div class="line">    next = e.next;</div><div class="line">    if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">        if (loTail == null)</div><div class="line">            loHead = e;</div><div class="line">        else</div><div class="line">            loTail.next = e;</div><div class="line">        loTail = e;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (hiTail == null)</div><div class="line">            hiHead = e;</div><div class="line">        else</div><div class="line">            hiTail.next = e;</div><div class="line">        hiTail = e;</div><div class="line">    &#125;</div><div class="line">&#125; while ((e = next) != null);</div><div class="line">if (loTail != null) &#123;</div><div class="line">    loTail.next = null;</div><div class="line">    newTab[j] = loHead;</div><div class="line">&#125;</div><div class="line">if (hiTail != null) &#123;</div><div class="line">    hiTail.next = null;</div><div class="line">    newTab[j + oldCap] = hiHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接下来以<strong>添加第4个元素之后进行扩容</strong>的过程分析一下上面代码的原理</p><ol><li><p>以上4个元素的hash值分别为：</p><p>| key | hash |<br>| :—: | :—: |<br>| 3 | 3 |<br>| 7 | 7 |<br>| 5 | 5 |<br>| 9 | 9 |</p></li><li><p>当把第4个元素[9=v]添加进map之后，未扩容（未执行resize()）前的table为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [5=v] --&gt; [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div></pre></td></tr></table></figure></li></ol><ol><li><p>这时由于<code>++size &gt; threashold ==&gt; 4&gt;3</code> ，所以需要执行resize()方法</p><p>该过程为新建一个长度为原来2倍的数组，如果判断原来数组上的node是一个链表，那么会遍历链表，判断每个元素的<code>(e.hash &amp; oldCap)</code>的值是否为0，来决定链表中元素的新位置</p><p>| key | hash | (e.hash &amp; oldCap) | 是否为0 | 新索引 |<br>| :—: | :—: | :—————: | :—–: | :—-: |<br>| 3 | 3 | 0 | 是 | 3 |<br>| 7 | 7 | 4 | 否 | 3+4 |<br>| 5 | 5 | 4 | 是 | 1+4 |<br>| 9 | 9 | 0 | 否 | 1 |</p><p>根据上表的统计可以得出结论，如果<code>e.hash &amp; oldCap</code>为0，则位置索引不变；否则新的索引是<strong>原位置索引+oldCap</strong>的，那么扩容后的table为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v]</div><div class="line">	 4   | null</div><div class="line">	 5   | [5=v]</div><div class="line">	 6   | null</div><div class="line">	 7   | [7=v]</div></pre></td></tr></table></figure><p>该判断是JDK8的一个优化，不需要像JDK7那样重新计算hash，只需要判断元素的hash值与oldCap的与运算结果就好了。这样的设计省去了重新计算hash值的时间，并且能够均匀的把冲突的节点分散到新的table中去。另外，JDK8的HashMap在迁移链表的时候会保持链表元素的顺序不变。</p></li><li><p><code>resize()</code>方法的全部代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K, V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K, V&gt;[] oldTab = table;</div><div class="line">    int oldCapacity = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThreshold = threshold;</div><div class="line">    int newCapacity, newThreshold = 0;</div><div class="line">    if (oldCapacity &gt; 0) &#123;</div><div class="line">        if (oldCapacity &gt;= MAXIMUM_CAPACITY) &#123;//扩容前的数组大小如果已经达到最大(2^30)了</div><div class="line">            threshold = Integer.MAX_VALUE;//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</div><div class="line">            return oldTab;</div><div class="line">        &#125; else if ((newCapacity = oldCapacity &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                oldCapacity &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThreshold = oldThreshold &lt;&lt; 1; // 将容量和阈值在原来的基础上扩大2倍</div><div class="line">    &#125; else if (oldThreshold &gt; 0) // initial capacity was placed in threshold</div><div class="line">        newCapacity = oldThreshold;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCapacity = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThreshold = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThreshold == 0) &#123;</div><div class="line">        float ft = (float) newCapacity * loadFactor;</div><div class="line">        newThreshold = (newCapacity &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ?</div><div class="line">                (int) ft : Integer.MAX_VALUE);//修改阈值</div><div class="line">    &#125;</div><div class="line">    threshold = newThreshold;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</div><div class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCapacity];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCapacity; ++j) &#123;//遍历原来的哈希表数组</div><div class="line">            Node&lt;K, V&gt; current;</div><div class="line">            if ((current = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;//清空</div><div class="line">                if (current.next == null)//如果当前节点只有一个节点</div><div class="line">                    newTab[current.hash &amp; (newCapacity - 1)] = current;</div><div class="line">                else if (current instanceof TreeNode)//如果当前节点是红黑树</div><div class="line">                    ((TreeNode&lt;K, V&gt;) current).split(this, newTab, j, oldCapacity);</div><div class="line">                else &#123; // 当前是链表 ，保留顺序preserve order</div><div class="line">                    Node&lt;K, V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K, V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K, V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = current.next;</div><div class="line">                        if ((current.hash &amp; oldCapacity) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = current;</div><div class="line">                            else</div><div class="line">                                loTail.next = current;</div><div class="line">                            loTail = current;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = current;</div><div class="line">                            else</div><div class="line">                                hiTail.next = current;</div><div class="line">                            hiTail = current;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((current = next) != null);</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCapacity] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h3 id="并发的rehash过程"><a href="#并发的rehash过程" class="headerlink" title="并发的rehash过程"></a>并发的rehash过程</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，因为在并发的多线程使用场景中使用HashMap可能造成<strong>数据丢失</strong>。</p><ol><li><p>多线程测试HashMap的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(2, 0.75f);</div><div class="line">    AtomicInteger counter = new AtomicInteger(0);</div><div class="line">    map.put(5, &quot;C&quot;);</div><div class="line">    Runnable r1 = () -&gt; &#123;</div><div class="line">        map.put(7, &quot;B&quot;);</div><div class="line">        counter.incrementAndGet();</div><div class="line">    &#125;;</div><div class="line">    Runnable r2 = () -&gt; &#123;</div><div class="line">        map.put(3, &quot;A&quot;);</div><div class="line">        map.put(8, &quot;A&quot;);</div><div class="line">        counter.incrementAndGet();</div><div class="line">    &#125;;</div><div class="line">    new Thread(r1, &quot;thread1&quot;).start();</div><div class="line">    new Thread(r2, &quot;thread2&quot;).start();</div><div class="line">    while (true) &#123;</div><div class="line">        if (counter.get() == 2) &#123;</div><div class="line">            printInfo(map, &quot;&quot;);</div><div class="line">            System.out.println(map.get(7));</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过阻塞<code>thread1</code>的<code>resize()</code>，再让<code>thread2</code>执行，并进行<code>resize()</code>操作之后，最后打印的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">size: 4</div><div class="line">tableLength: 8</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 6</div><div class="line">modCount: 4</div><div class="line">table:索引 | 元素</div><div class="line">	 0   | [8=A]</div><div class="line">	 1   | null</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=A]</div><div class="line">	 4   | null</div><div class="line">	 5   | null</div><div class="line">	 6   | null</div><div class="line">	 7   | null</div><div class="line"></div><div class="line">null</div></pre></td></tr></table></figure><p>可见table的size为4，表明map经历了4次put过程，而实际上却只有两个元素，其他元素丢失了，那么接下来通过<code>IntellijIdea</code>的多线程断点调试来演示一下元素为什么丢失。</p></li><li><p>初始化一个调试环境</p><p><img src="http://op87q3xru.bkt.clouddn.com/gif/java%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E5%92%8C%E6%96%AD%E7%82%B9%E7%9A%84%E6%8C%82%E8%B5%B7%E6%A8%A1%E5%BC%8F.gif" alt="image"></p></li><li><p>用debug调试模拟多线程切换的流程</p><p><img src="http://op87q3xru.bkt.clouddn.com/gif/java%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug%E8%B0%83%E8%AF%95.gif" alt="image"></p><ol><li>点击debug按钮，这时断点会走到<code>thread1</code>处；</li><li>将<code>HashMap.resize(){next=e.next}</code>处打上断点，并设置挂起模式为thread。</li><li>接着开始执行thread1，这时thread1线程会停到刚才的断点处，相当于挂起thread1。</li><li>切换到thread2，并取消第2步设置的断点，让thread2能够一次性运行结束，并进行resize()过程。</li><li>thread2线程执行结束后，唤醒thread1，让thread1继续执行。</li><li>最后，通过打印的结果可知，数据丢失了。</li></ol></li><li><p>分析</p><p>通过分析<code>resize()</code>的源码可知，每次是让<code>table</code>指向一个<code>newTab</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">······</div><div class="line">threshold = newThr;</div><div class="line">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">table = newTab;</div><div class="line">······</div></pre></td></tr></table></figure><p>接着遍历<code>oldTab</code>，将原有的key-value存到<code>newTab</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line">                if ((e = oldTab[j]) != null) &#123;</div><div class="line">······</div><div class="line"></div><div class="line">if (loTail != null) &#123;</div><div class="line">    loTail.next = null;</div><div class="line">    newTab[j] = loHead;</div><div class="line">&#125;</div><div class="line">if (hiTail != null) &#123;</div><div class="line">    hiTail.next = null;</div><div class="line">    newTab[j + oldCap] = hiHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的<strong>第三步</strong>，<code>thread1</code>执行到<code>next = e.next</code>这挂起，接着唤醒<code>thread2</code>去执行，<code>thread2</code>把[8=A]放进map之后，也会执行resize()操作，这时会将 <code>table</code> 指向一个新的<code>newTab</code>，那么<code>thread1</code>的<code>newTab</code>将会失去引用，所以之前存储的值也就丢失了。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因此，在多线程环境中，使用<code>ConcurrentHashMap</code>替换<code>HashMap</code>，或者使用<code>Collections.synchronizedMap</code>将<code>HashMap</code>包装起来。</p><h2 id="JDK8和JDK7的HashMap性能对比"><a href="#JDK8和JDK7的HashMap性能对比" class="headerlink" title="JDK8和JDK7的HashMap性能对比"></a>JDK8和JDK7的HashMap性能对比</h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。</p><h3 id="Hash比较均匀的情况"><a href="#Hash比较均匀的情况" class="headerlink" title="Hash比较均匀的情况"></a>Hash比较均匀的情况</h3><ol><li><p>编写一个Key类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"> </div><div class="line">    private final int value;</div><div class="line"> </div><div class="line">    Key(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int compareTo(Key o) &#123;</div><div class="line">        return Integer.compare(this.value, o.value);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        if (this == o) return true;</div><div class="line">        if (o == null || getClass() != o.getClass())</div><div class="line">            return false;</div><div class="line">        Key key = (Key) o;</div><div class="line">        return value == key.value;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同。</p></li><li><p>创建Keys类，用于缓存Key，避免频繁的GC，而影响HashMap实际查找值的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Keys &#123;</div><div class="line"> </div><div class="line">    public static final int MAX_KEY = 10_000_000;</div><div class="line">    private static final Key[] KEYS_CACHE = new Key[MAX_KEY];</div><div class="line"> </div><div class="line">    static &#123;</div><div class="line">        for (int i = 0; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = new Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static Key of(int value) &#123;</div><div class="line">        return KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……、10000000）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void test(int mapSize) &#123;</div><div class="line"> </div><div class="line">       HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">       for (int i = 0; i &lt; mapSize; ++i) &#123;</div><div class="line">           map.put(Keys.of(i), i);</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       long beginTime = System.nanoTime(); //获取纳秒</div><div class="line">       for (int i = 0; i &lt; mapSize; i++) &#123;</div><div class="line">           map.get(Keys.of(i));</div><div class="line">       &#125;</div><div class="line">       long endTime = System.nanoTime();</div><div class="line">       System.out.println(endTime - beginTime);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">       for(int i=10;i&lt;= 1000 0000;i*= 10)&#123;</div><div class="line">           test(i);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li><li><p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响，结果如下：</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="image"></p><h3 id="hash极不均匀的情况"><a href="#hash极不均匀的情况" class="headerlink" title="hash极不均匀的情况"></a>hash极不均匀的情况</h3></li><li><p>假设我们有一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"> </div><div class="line">    //...</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>仍然执行main方法，得出的结果如下表所示</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="image"></p><p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，JDK1.8的HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要介绍了Java8 HashMap的实现原理、包括一些重要的成员变量、put方法分析，扩容分析、Java8与Java7HashMap性能对比。
    
    </summary>
    
      <category term="Java" scheme="http://www.vibrancy.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="HashMap" scheme="http://www.vibrancy.cn/tags/HashMap/"/>
    
      <category term="红黑树" scheme="http://www.vibrancy.cn/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="散列表" scheme="http://www.vibrancy.cn/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android增量更新：服务器篇</title>
    <link href="http://www.vibrancy.cn/repository/android-incremental-update-server-articles.html"/>
    <id>http://www.vibrancy.cn/repository/android-incremental-update-server-articles.html</id>
    <published>2017-04-30T13:40:21.000Z</published>
    <updated>2017-05-15T11:56:10.571Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="增量更新的原理"><a href="#增量更新的原理" class="headerlink" title="增量更新的原理"></a>增量更新的原理</h2><p>其实增量升级的原理很简单，即首先将应用的旧版本Apk与新版本Apk做差分，得到更新的部分的补丁，例如旧版本的APK有5M，新版的有8M，更新的部分则可能只有3M左右(这里需要说明的是，得到的差分包大小并不是简单的相减，因为其实需要包含一些上下文相关的东西——有时候旧版本10M，新版本8M，得到的差分包可能有5M)，使用差分升级的好处显而易见，那么你不需要下载完整的8M文件，只需要下载更新部分就可以，而更新部分可能只有3、4M，可以很大程度上减少流量的损失。</p><p>在用户下载了差分包之后，需要在手机端将他们组合起来。可以参考的做法是先将手机端的旧版本软件(多半在/data/下)，复制到SD卡或者cache中，将它们和之前的差分patch进行组合，得到一个新版本的apk应用，如果不出意外的话，这个生成的apk和你之前做差分的apk是一致的。</p><h2 id="增量更新实现"><a href="#增量更新实现" class="headerlink" title="增量更新实现"></a>增量更新实现</h2><h3 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h3><p>使用开源的二进制比较工具<a href="http://www.daemonology.net/bsdiff/" target="_blank" rel="external">bsdiff</a></p><p><img src="http://i.imgur.com/RBOUfG0.png" alt=""></p><p>及其依赖的<a href="http://www.bzip.org/downloads.html" target="_blank" rel="external">bzip2</a></p><p><img src="http://i.imgur.com/n4nI8zB.png" alt="bzip2"></p><p>下载完后，得到这样的目录结构：</p><p><img src="http://i.imgur.com/sxndK1G.png" alt=""></p><p><img src="http://i.imgur.com/Hgxvn4W.png" alt=""></p><p>其中bsdiff.c用于在服务端生成差分包，bspatch.c用于在客户端把旧版本apk与服务端生成的差分包进行合成为新版本apk。</p><h3 id="实现的步骤"><a href="#实现的步骤" class="headerlink" title="实现的步骤"></a>实现的步骤</h3><ol><li>在服务端，生成新旧版本的差分包</li><li>在客户端，使用已安装的旧版apk与这个差分包，合成为一个新版apk。</li><li>校验新合成的客户端文件是否完成，签名时候和已安装客户端一致，如一致，提示用户安装;</li></ol><h2 id="服务端生成差分包"><a href="#服务端生成差分包" class="headerlink" title="服务端生成差分包"></a>服务端生成差分包</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>由于服务器的不同，因此我们需要将以上的c/c++文件，build输出为动态链接库，以供java调用，其中Window环境生成名为libApkPatchLibraryServer.dll文件，Unix/Linux环境生成名为libApkPatchLibraryServer.so，OSX下生成名为libApkPatchLibraryServer.dylib的文件。下面具体讲一下在Windows服务器上怎么生成libApkPatchLibraryServer.dll文件的</p><h3 id="生成dll动态链接库"><a href="#生成dll动态链接库" class="headerlink" title="生成dll动态链接库"></a>生成dll动态链接库</h3><ol><li><p>下载开源工具</p><p>如果我们要生成dll动态链接库，那我们就不能用刚才下的bsdiff-4.3了（具体原因下面再说），我们需要在这里<a href="http://sites.inka.de/tesla/others.html#bsdiff" target="_blank" rel="external">bsdiff</a> 下载一个针对win32版本的bsdiff文件，下载页面如图所示：</p><p><img src="http://i.imgur.com/BaJoEl0.png" alt=""></p><p>下载得到的文件如图所示：</p><p><img src="http://i.imgur.com/pTbSJ1G.png" alt=""></p><p>里面已经包含了<code>bsdiff.cpp</code>，<code>bspatch.cpp</code>及其依赖的<code>bzlip</code>等文件。</p></li><li><p>改写bsdiff.cpp（生成差分包）</p><p>首先，在MyEclispe中声明一个native方法，如图所示：</p><p><img src="http://i.imgur.com/2kep1Su.png" alt=""></p><p>接着，为了生成的方便，将该类及完整的所在包复制到桌面上，我们利用javac 和javap命令将该native方法生成c/c++中对应的.h头文件：</p><p><img src="http://i.imgur.com/OytWPaJ.png" alt=""></p><p><img src="http://i.imgur.com/4k1bWXg.png" alt=""></p><p><img src="http://i.imgur.com/55agjAq.png" alt=""></p><p>这时，我们可以看到在桌面上生成了一个<code>com_cwc_smartupdate_util_DiffUtil.h</code>的头文件。打开头文件，如下图所示：</p><p><img src="http://i.imgur.com/H9elGXU.png" alt=""></p><p>以上代码需要说明一下，首先函数名的格式遵循如下规则：<code>Java_包名_类名_方法名</code>。其中，<code>JNIEXPORT</code>、<code>JNICALL</code>、<code>JNIEnv</code>和<code>jobject</code>都是JNI标准中定义的类型或者宏。</p></li><li><p>实现JNI方法</p><p>这里可以选用c或c++实现，我们这使用的是c++，因为在上文中下载win32版本的<code>bsdiff</code>中的<code>bsdiff.cpp</code>就是用c++实现的，接着我们打开该文件进行改写。（注意：我这以下的所有操作都是基于VS2013，因为涉及到很多c和h文件的引用，如果使用命令行的话，在连接阶段可能出现函数未定义的情况，为了简便本人直接使用了VS2013来生成dll文件）。</p><p>首先，利用vs2013新建一个dll项目，将<code>bsdiff4.3-win32-src.zip</code>解压得到的文件导入该项目中，并将bsdiff.cpp重新命名为<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>，另外，这里还需要三个头文件，分别是<code>jni.h</code>、<code>jni_md.h</code>（在两个在ndk里面找，可以在该ndk根文件夹子下全文搜索一下）和刚才生成的<code>com_cwc_smartupdate_util_DiffUtil.h</code>，最终得到的目录结构如下：</p><p><img src="http://i.imgur.com/gG7T8nm.png" alt=""></p><p>接着我们打开<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>文件，进行我们的改写操作，首先，引入头文件：</p><p><img src="http://i.imgur.com/V2AFD3j.png" alt=""><img src="http://i.imgur.com/uQiK24i.png" alt=""></p><p>之后，把<code>typedef long pid_t</code>注释掉，并添加<code>ftello</code>和<code>fseeko</code>两个函数宏定义，如图所示：</p><p><img src="http://i.imgur.com/NHRemD6.png" alt=""></p><p>接着，我们来实现<code>com_cwc_smartupdate_util_DiffUtil.h</code>中的函数，代码如下：</p><p><img src="http://i.imgur.com/G0Frtwr.png" alt=""></p><p>这段代码意思是将传入的三个字符串（新旧版本的文件路径和生成的差分包路径）分别放进一个<code>char* 类型</code>的指针数组里面，然后调用appDiff函数，生成差分包。那这个appDiff如何实现呢，我们找到该文件下的main方法，将该main方法重命名为appDiff：</p><p><img src="http://i.imgur.com/MckAKMJ.png" alt=""></p><p><img src="http://i.imgur.com/oCMUkUw.png" alt=""></p><p>接着，把该<code>appDiff函数</code>向下拖动，会看到这段代码，这段代码用于通过打开旧版本文件，将文件的数据读到名为old的内存当中，这段代码改写如下：</p><p><img src="http://i.imgur.com/e9f694c.png" alt=""></p><p>因为<code>lseek</code>，<code>open</code>等函数都是Linux里面的，如果在window下使用会出现打开文件失败的情况。改写的文件如下，其中stream是新定义的一个<code>FILE* stream</code>;文件类型指针：</p><p><img src="http://i.imgur.com/eDPNUHG.png" alt=""></p><p>通过这段代码可以将旧版本文件数据读取到<code>u_char* old</code>中。接着，我们改写读取新文件的这段代码，代码如下：</p><p><img src="http://i.imgur.com/8INJLrO.png" alt=""></p><p>改写成：</p><p><img src="http://i.imgur.com/quzwfPh.png" alt=""></p><p>到此为止，我们的所有操作就全部完成了，接下来我们生成dll文件，在生成的dll文件中也注意是32位的还是64位的，不然在java调用的时候会出现读取失败的情况。</p><h2 id="在服务端调用dll文件"><a href="#在服务端调用dll文件" class="headerlink" title="在服务端调用dll文件"></a>在服务端调用dll文件</h2></li></ol><p><img src="http://i.imgur.com/HSbsyVA.png" alt=""></p><p>其中，<code>DiffAppServer64</code>就是刚才生成的dll文件，由于<code>DiffAppServer64.dll</code>需要依赖其他的dll文件，我这需要依赖<code>msvcr100d</code>和<code>kernel32</code>，所以在这里也必须将两个文件导入才行。最后，这三个文件放置的位置如图所示：</p><p><img src="http://i.imgur.com/q7Sl981.png" alt=""></p><p>在tomcat根目录下的bin子目录下新建一个appdiff目录，然后把三个文件放到这里。当这些所有的操作完成之后，就可以在服务端生成差分包了。</p><h2 id="运行效果展示"><a href="#运行效果展示" class="headerlink" title="运行效果展示"></a>运行效果展示</h2><h3 id="apk文件上传页面面"><a href="#apk文件上传页面面" class="headerlink" title="apk文件上传页面面"></a>apk文件上传页面面</h3><p><img src="http://i.imgur.com/1PmCkic.png" alt=""></p><h3 id="旧版本文件上传"><a href="#旧版本文件上传" class="headerlink" title="旧版本文件上传"></a>旧版本文件上传</h3><p><img src="http://i.imgur.com/r0003FO.png" alt=""></p><h3 id="新版本文件上传"><a href="#新版本文件上传" class="headerlink" title="新版本文件上传"></a>新版本文件上传</h3><p><img src="http://i.imgur.com/3LUG2ic.png" alt=""></p><h3 id="当上传新版本后，服务端后台就自动开始生成差分包的工作了"><a href="#当上传新版本后，服务端后台就自动开始生成差分包的工作了" class="headerlink" title="当上传新版本后，服务端后台就自动开始生成差分包的工作了"></a>当上传新版本后，服务端后台就自动开始生成差分包的工作了</h3><p><img src="http://i.imgur.com/FeEghkb.png" alt=""></p><p><img src="http://i.imgur.com/sSoD3Wd.png" alt=""></p><p>那么又涉及到另外一个问题，由于比较生成差分包在底层进行，并且非常的耗时，大概需要1分多钟，那么如何显示进度，生成差分包的工作进行到哪一步了？这就需要利用jni调用java方法，将底层的信息传到java代码层。</p><h2 id="jni调用java方法，回传底层的进度信息"><a href="#jni调用java方法，回传底层的进度信息" class="headerlink" title="jni调用java方法，回传底层的进度信息"></a>jni调用java方法，回传底层的进度信息</h2><ol><li><p>在声明genDiff 这个native方法的的类中<code>java.cwc.smartupdate.util.DiffUtil</code>声明一个静态的方法：</p><p><img src="http://i.imgur.com/EHppmhA.png" alt=""></p><p>这个方法表示，在c底层进行调用该方法，传递整型state参数，通过对比不同的整型数据，找到底层对应的执行进度。</p></li><li><p>让我们返回到<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>文件中，找到我们在上文中实现的本地方法对应的函数：</p><p><img src="http://i.imgur.com/Llrwt4j.png" alt=""></p><p>为了方便演示，在这个函数上面定义一个用于发布进度的函数：</p><p><img src="http://i.imgur.com/KFULVhk.png" alt=""></p><p>这段函数的意思就是通过反射来调用DiffUtil类内的静态方法publishProgress，然后在appDiff函数内部，就可以在关键的地方调用该函数用来发布当前执行任务的状态了，（注意定义的函数需要在该文件头部声明，不然出现找不到函数的错误提示），另外还有一点需要注意，publishProgress需要调用不止一次，因此不可能每次都通过反射来创建DiffUtil的类对象(创建一次就够了)，因此，我们需要将上面的函数整理为以下格式：</p><p><img src="http://i.imgur.com/70bdDfk.png" alt=""></p></li><li><p>服务端的java代码层</p><p>由于publishProgress传递的是整型数据，我们可以自定义一些整型常量来映射出对应的任务状态。还可以在该DiffUtil定义一个内部接口，这样其他类实现了该接口，就可以接收到底层返回的进度。</p><p><img src="http://i.imgur.com/oOEXgk0.png" alt=""></p><p><img src="http://i.imgur.com/ZhwlIHh.png" alt=""></p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>到此为止，整个增量更新的服务端是实现就结束了，总结一下：</p><ul><li>我们首先在java中定义了一个本地native方法，通过javac和javap命令生成了对应的h头文件；</li><li>然后改写bsdiff.cpp文件，实现刚才生成的头文件中的函数，并针对windows服务器改写bsdiff.cpp的函数内部的细节；</li><li>最后进行将生成的dll文件放到了tomcat服务器中，利用System.loadLibrary函数加载dll文件，如果缺少依赖dll的话，就添加对应的dll文件；</li><li>最后为了实现进度的显示，我们又定义了publishProgress方法，并在底层实现了该函数，在java端的DiffUtil类中定义了一个接口，让其他实现该接口的类可以接收到底层发布的进度。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要是对增量更新服务器端如果实现进行详细的介绍。
    
    </summary>
    
      <category term="Android" scheme="http://www.vibrancy.cn/categories/Android/"/>
    
    
      <category term="增量更新" scheme="http://www.vibrancy.cn/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    
      <category term="android" scheme="http://www.vibrancy.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>到底什么时候该使用MQ</title>
    <link href="http://www.vibrancy.cn/repository/when-to-use-MQ%20.html"/>
    <id>http://www.vibrancy.cn/repository/when-to-use-MQ .html</id>
    <published>2017-04-29T22:23:39.000Z</published>
    <updated>2017-05-15T11:56:10.616Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="MQ的用途"><a href="#MQ的用途" class="headerlink" title="MQ的用途"></a>MQ的用途</h2><p>消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。</p><p>在互联网架构中，MQ是一种非常常见的上下游“<strong>逻辑解耦+物理解耦</strong>”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，逻辑上和物理上都不用依赖其他服务。</p><p><img src="http://op87q3xru.bkt.clouddn.com/message%20queue.png" alt="mq"></p><h2 id="不使用MQ的情况"><a href="#不使用MQ的情况" class="headerlink" title="不使用MQ的情况"></a>不使用MQ的情况</h2><p>MQ作为互联网分层架构中的解耦利器，那为什么不是所有通讯都使用MQ呢？因为，调用与被调用的关系，是无法被MQ取代的。<strong>调用方实时依赖执行结果的业务场景，请使用调用，而不是MQ</strong>。</p><h3 id="MQ的缺陷"><a href="#MQ的缺陷" class="headerlink" title="MQ的缺陷"></a>MQ的缺陷</h3><ul><li>系统更复杂，多了一个MQ组件；</li><li>消息传递路径更长，延时增加；</li><li>消息<strong>可靠性</strong>和<strong>重复性</strong>互为矛盾，消息不丢不重难以同时保证；</li><li>上游无法知道下游的执行结果，这一点是很致命的。</li></ul><h2 id="什么时候使用MQ"><a href="#什么时候使用MQ" class="headerlink" title="什么时候使用MQ"></a>什么时候使用MQ</h2><h3 id="场景一：数据驱动的任务依赖"><a href="#场景一：数据驱动的任务依赖" class="headerlink" title="场景一：数据驱动的任务依赖"></a>场景一：数据驱动的任务依赖</h3><ol><li><p>什么是任务依赖</p><p>互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，比如：</p><ul><li>task3需要使用task2的输出作为输入；</li><li><p>task2需要使用task1的输出作为输入；</p><p>这样的话，tast1,task2,task3之间就有任务依赖关系，必须task1先执行，再task2执行，载task3执行。</p></li></ul></li><li><p>使用cron人工排执行时间表</p><ol><li>task1，0:00执行，经验执行时间为50分钟</li><li>task2，1:00执行（为task1预留10分钟buffer），经验执行时间也是50分钟</li><li>task3，2:00执行（为task2预留10分钟buffer）</li></ol></li><li><p>使用cron的缺点</p><ul><li>如果有一个任务<strong>执行时间超过了预留buffer的时间，将会得到错误的结果</strong>，因为后置任务不清楚前置任务是否执行成功，此时要手动重跑任务，还有可能要调整排班表。</li><li>总任务的<strong>执行时间很长</strong>，总是要预留很多buffer，如果前置任务提前完成，后置任务不会提前开始。</li><li>如果一个任务被多个任务依赖，这个任务将会称为<strong>关键路径</strong>，排班表很难体现依赖关系，容易出错。</li><li>如果有一个任务的执行时间要调整，将会有<strong>多个任务的执行时间要调整</strong></li></ul></li><li><p>采用MQ解耦方案</p><ol><li>task1准时开始，结束后发一个“task1 done”的消息</li><li>task2订阅“task1 done”的消息，收到消息后第一时间启动执行，结束后发一个“task2done”的消息。</li><li>task3同理</li></ol></li><li><p>采用MQ的优点</p><ul><li>不需要预留buffer，上游任务执行完，<strong>下游任务总会在第一时间被执行。</strong></li><li>依赖多个任务，被多个任务依赖都很好处理，<strong>只需要订阅相关消息</strong>即可</li><li>有任务执行时间变化，下游任务都<strong>不需要调整执行时间</strong>。</li></ul></li><li><p>MQ使用注意</p><p>MQ只用来传递上游任务<strong>执行完成的消息</strong>，并不用于传递真正的<strong>输入输出</strong>数据。</p></li></ol><h3 id="典型场景二：上游不关心执行结果"><a href="#典型场景二：上游不关心执行结果" class="headerlink" title="典型场景二：上游不关心执行结果"></a>典型场景二：上游不关心执行结果</h3><ol><li><p>58同城的很多下游需要关注“用户发布帖子”这个事件</p><p>比如招聘用户发布帖子后，招聘业务要奖励58豆，房产用户发布帖子后，房产业务要送2个置顶，二手用户发布帖子后，二手业务要修改用户统计数据。</p></li><li><p>采用调用关系解决</p><p>帖子发布服务执行完成之后，调用下游招聘业务、房产业务、二手业务，来完成消息的通知，但事实上，这个通知是否正常正确的执行，帖子发布服务根本不关注。</p></li><li><p>采用调用的缺陷</p><ul><li>帖子发布流程的执行时间增加了</li><li>下游服务宕机，可能导致帖子发布服务受影响，上下游逻辑+物理依赖严重。</li><li>每当增加一个需要知道“帖子发布成功”信息的下游，修改代码的是帖子发布服务，这一点是最恶心的，属于<strong>架构设计中典型的依赖倒转</strong>，谁用过谁痛谁知道。</li></ul></li><li><p>采用MQ解耦方案</p><ul><li>帖子发布成功后，向MQ发一个消息</li><li>哪个下游关注“帖子发布成功”的消息，主动去MQ订阅</li></ul></li><li><p>采用MQ的优点</p><ul><li>上游<strong>执行时间短</strong></li><li><strong>上下游逻辑+物理解耦</strong>，除了与MQ有物理连接，模块之间都不相互依赖</li><li><strong>新增一个下游消息关注方，上游不需要修改任何代码</strong>。</li></ul></li></ol><h3 id="典型场景三：上游关注执行结果，但执行时间很长"><a href="#典型场景三：上游关注执行结果，但执行时间很长" class="headerlink" title="典型场景三：上游关注执行结果，但执行时间很长"></a>典型场景三：上游关注执行结果，但执行时间很长</h3><ol><li><p>微信支付</p><p>跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果，此时一般怎么玩呢？</p><p><img src="http://op87q3xru.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5.png" alt="image"></p></li></ol><ol><li>采用“回调网关+MQ”方案来解耦：<ol><li>调用方直接跨公网调用微信接口</li><li>微信返回调用成功，此时并不代表返回成功</li><li>微信执行完成后，回调统一网关</li><li>网关将返回结果通知MQ</li><li>请求方收到结果通知</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么时候不使用MQ？"><a href="#什么时候不使用MQ？" class="headerlink" title="什么时候不使用MQ？"></a>什么时候不使用MQ？</h3><p>上游实时关注执行结果</p><h3 id="什么时候使用MQ？"><a href="#什么时候使用MQ？" class="headerlink" title="什么时候使用MQ？"></a>什么时候使用MQ？</h3><ol><li>数据驱动的任务依赖</li><li>上游不关心多下游执行结果</li><li>异步返回执行时间长</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要介绍了消息队列的使用场景
    
    </summary>
    
      <category term="架构师" scheme="http://www.vibrancy.cn/categories/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
    
      <category term="架构" scheme="http://www.vibrancy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="消息队列" scheme="http://www.vibrancy.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat多实例单应用部署方案</title>
    <link href="http://www.vibrancy.cn/repository/Tomcat-multi-instance-single-application-deployment-plan.html"/>
    <id>http://www.vibrancy.cn/repository/Tomcat-multi-instance-single-application-deployment-plan.html</id>
    <published>2017-04-29T02:20:53.000Z</published>
    <updated>2017-05-15T11:56:10.704Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 05 2017 13:11:03 GMT+0800 (马来西亚半岛标准时间) --><h2 id="Tomcat部署的场景分析"><a href="#Tomcat部署的场景分析" class="headerlink" title="Tomcat部署的场景分析"></a>Tomcat部署的场景分析</h2><h3 id="单实例单应用"><a href="#单实例单应用" class="headerlink" title="单实例单应用"></a>单实例单应用</h3><p>如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。</p><h3 id="单实例多应用"><a href="#单实例多应用" class="headerlink" title="单实例多应用"></a>单实例多应用</h3><p>是把多个应用程序的war包放在同一个tomcat的webapps目录，这样一来，关闭和启动tomcat会影响所有项目。</p><h3 id="多实例单应用"><a href="#多实例单应用" class="headerlink" title="多实例单应用"></a>多实例单应用</h3><p>各个tomcat都运行同一个应用程序，对应地需要修改不同的监听端口，这种方式通常会和apache httpd或者nginx整合使用，做一些负载均衡的处理。</p><h3 id="多实例多应用"><a href="#多实例多应用" class="headerlink" title="多实例多应用"></a>多实例多应用</h3><p>相当于第一种场景的复数形式，除了修改不同的监听端口，没有本质区别。</p><h2 id="Windows服务器下多实例单应用设置流程"><a href="#Windows服务器下多实例单应用设置流程" class="headerlink" title="Windows服务器下多实例单应用设置流程"></a>Windows服务器下多实例单应用设置流程</h2><h3 id="分离目录"><a href="#分离目录" class="headerlink" title="分离目录"></a>分离目录</h3><ol><li><p>刚解压出来的tomcat目录结构</p><ul><li>bin：主要存放脚本文件，例如比较常用的windows和linux系统中启动和关闭脚本</li><li>conf：主要存放配置文件，其中最重要的两个配置文件是server.xml和web.xml</li><li>lib：主要存放tomcat运行所依赖的包</li><li>logs：主要存放运行时产生的日志文件，例如catalina.{date}.log等</li><li>temp：存放tomcat运行时产生的临时文件，例如开启了hibernate缓存的应用程序，会在该目录下生成一些文件</li><li>webapps：部署web应用程序的默认目录</li><li>work：主要存放由JSP文件生成的servlet（java文件以及最终编译生成的class文件）</li></ul></li><li><p>将解压出来的tomcat文件拆分出的目录结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">F:/DevLibs/Tomcat</div><div class="line">├─applications</div><div class="line">│  ├─backend  # 主要部署后端模块代码</div><div class="line">│  │  │  shutdown.bat</div><div class="line">│  │  │  startup.bat</div><div class="line">│  │  ├─conf</div><div class="line">│  │  ├─logs</div><div class="line">│  │  ├─temp</div><div class="line">│  │  ├─webapps   </div><div class="line">│  │  └─work</div><div class="line">│  └─officals-website # 主要部署前端代码，如官方网站</div><div class="line">│     │  shutdown.bat</div><div class="line">│     │  startup.bat</div><div class="line">│     ├─conf</div><div class="line">│     ├─logs</div><div class="line">│     ├─temp</div><div class="line">│     ├─webapps</div><div class="line">│     └─work</div><div class="line">├─bin</div><div class="line">└─lib</div></pre></td></tr></table></figure></li></ol><h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><ol><li><p>环境变量说明</p><ul><li>CATALINA_HOME：即指向<strong>Tomcat安装路径</strong>的系统变量</li><li><p>CATALINA_BASE：即指向<strong>活跃配置路径</strong>的系统变量</p><p>通过设置这两个变量，就可以将tomcat的<strong>安装目录和工作目录</strong>分离，从而<strong>实现tomcat多实例的部署</strong>。</p></li></ul></li><li><p>环境变量设置</p><ul><li>新建变量名：<code>CATALINA_HOME</code>，变量值：<code>F:/DevLibs/Tomcat</code></li><li>不需要增加<code>CATALINA_BASE</code>，该变量在脚本中动态设置。</li><li>打开PATH，添加变量值：<code>%CATALINA_HOME%\lib;%CATALINA_HOME%\bin</code></li></ul></li></ol><h3 id="修改server-xml"><a href="#修改server-xml" class="headerlink" title="修改server.xml"></a>修改server.xml</h3><ol><li>修改官方网站（officals-website）web应用的server.xml配置（<strong>端口号8081</strong>）。<ul><li>将第22行的<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code> 修改为 <code>&lt;Server port=&quot;8015&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></li><li>将第69行的<code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</code> 修改为 <code>&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;</code></li><li>将第91行的<code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>修改为<code>&lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></li><li>将第123行的<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code>修改为<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt;</code></li></ul></li><li>修改后端（backend）web应用的server.xml配置（<strong>端口号8082</strong>）。<ul><li>将第22行的<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code> 修改为 <code>&lt;Server port=&quot;8025&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></li><li>将第69行的<code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</code> 修改为 <code>&lt;Connector port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot;</code></li><li>将第91行的<code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>修改为<code>&lt;Connector port=&quot;8029&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></li><li>将第123行的<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code>修改为<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt;</code></li></ul></li></ol><h3 id="修改启动和停止脚本"><a href="#修改启动和停止脚本" class="headerlink" title="修改启动和停止脚本"></a>修改启动和停止脚本</h3><ol><li>将初始tomcat的bin目录下的<code>startup.bat</code> 和<code>shutdown.bat</code> 这两个脚本分别拷贝到<code>backend</code> 和 <code>offical-website</code> 目录下</li><li><p>编辑<code>startup.bat</code>脚本，增加一行语句，用于设置<code>CATALINA_BASE</code>变量。（backend和offical-website需要同时修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">setlocal</div><div class="line"></div><div class="line">rem Guess CATALINA_HOME if not defined</div><div class="line">set &quot;CURRENT_DIR=%cd%&quot;</div><div class="line">## 在这里将CATALINA_BASE 设置为脚本所在目录</div><div class="line">set &quot;CATALINA_BASE=%cd%&quot; </div><div class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</div><div class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</div><div class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</div><div class="line">cd ..</div><div class="line">set &quot;CATALINA_HOME=%cd%&quot;</div><div class="line">cd &quot;%CURRENT_DIR%&quot;</div><div class="line">:gotHome</div></pre></td></tr></table></figure></li><li><p>编辑shutdown.bat脚本，增加一行语句，用于设置<code>CATALINA_BASE</code>变量。（backend和offical-website需要同时修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setlocal</div><div class="line"></div><div class="line">rem Guess CATALINA_HOME if not defined</div><div class="line">set &quot;CURRENT_DIR=%cd%&quot;</div><div class="line">## 在这里将CATALINA_BASE 设置为脚本所在目录</div><div class="line">set &quot;CATALINA_BASE=%cd%&quot;</div><div class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</div><div class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</div><div class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</div><div class="line">cd ..</div><div class="line">set &quot;CATALINA_HOME=%cd%&quot;</div><div class="line">cd &quot;%CURRENT_DIR%&quot;</div><div class="line">:gotHome</div></pre></td></tr></table></figure></li></ol><h2 id="启动tomcats"><a href="#启动tomcats" class="headerlink" title="启动tomcats"></a>启动tomcats</h2><ol><li>分别在backend和officals-website目录，用Dos执行startup.bat脚本。</li><li>在浏览器输入loalhost:8081和loalhost:8082就可以访问tomcat管理页面了。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://blog.jobbole.com/109347/" target="_blank" rel="external">Tomcat多实例单应用部署方案</a></li><li><a href="http://xafc2370.iteye.com/blog/1683187" target="_blank" rel="external">一个tomcat部署多个应用实例总结</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要介绍了如何在一个服务器中运行多个Tomcat实例，保证部署在单服务器中的多个项目不会相互影响。
    
    </summary>
    
      <category term="Tomcat" scheme="http://www.vibrancy.cn/categories/Tomcat/"/>
    
    
      <category term="tomcat" scheme="http://www.vibrancy.cn/tags/tomcat/"/>
    
  </entry>
  
</feed>
