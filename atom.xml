<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心之所至、意之使然</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.vibrancy.cn/"/>
  <updated>2017-05-14T00:29:10.597Z</updated>
  <id>http://www.vibrancy.cn/</id>
  
  <author>
    <name>落枫寒</name>
    <email>luofenghan_cwc@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>8大经典排序算法总结</title>
    <link href="http://www.vibrancy.cn/repository/classic-sort.html"/>
    <id>http://www.vibrancy.cn/repository/classic-sort.html</id>
    <published>2017-05-14T00:08:29.000Z</published>
    <updated>2017-05-14T00:29:10.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 14 2017 08:37:37 GMT+0800 (马来西亚半岛标准时间) --><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ol><li><p>排序思想</p><p>按照索引顺序，每一步将该索引上的值插入到前面已经有序的一组的值适当位置（通过从当前索引处往前的挨个比较）上，直到全部插入为止，详细算法步骤如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个X元素，在已经排序的元素序列中从后向前扫描；</li><li>如果扫描到的元素（已排序）大于X元素，将该元素往后移动一个位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于X元素的位置；</li><li>将X元素插入到该位置；</li><li>重复步骤2~4。</li></ol></li></ol><ol><li><p>排序演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA.gif" alt="直接插入排序"></p></li></ol><ol><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StraightInsertSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; e.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> x = e[i];</div><div class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; e[j] &gt; x; j--) &#123;</div><div class="line">                e[j + <span class="number">1</span>] = e[j];</div><div class="line">            &#125;</div><div class="line">            e[j + <span class="number">1</span>] = x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><ol><li><p>结论</p><ol><li>当输入数据以<strong>反序</strong>输入时，直接插入排序的时间复杂度为\(O(N^2)\)，因为由于嵌套循环的每一个都花费N次迭代；</li><li>当输入数据已<strong>预先排序</strong>，直接插入排序的时间复杂度为\(O(N)\)，因为内层的for循环的检测总是立即判定不成立而终止。</li><li>直接插入排序适合<strong>数据量比较小</strong>的排序应用；</li><li><strong>逆序数</strong>也正好是需要由插入排序执行的<strong>交换次数</strong>，而一个排过序的数组没有逆序。当输入数据是<code>34,8,64,51,32,21</code>时，该数据有9个逆序，即<code>(34,8),(34,32),(34,21),(64,51),(64,32),(64,21),(51,32),(51,21)</code>以及<code>(32,21)</code>。由于算法还有\(O(N)\)量的其他工作，因此插入排序的运行时间是\(O(I+N)\)，其中I为原始数组中的逆序数。于是，若逆序数是\(O(N)\)，则插入排序以线性时间运行。</li><li>N个互异数的数组的平均逆序数是\(N(N-1)/4\)；</li><li>通过<strong>交换相邻元素</strong>进行排序的任何算法平均时间复杂度都需要\(O(N^2)\)，也就是说，为了使一个排序算法以\(O(N^2)\)时间运行，必须执行一些比较，特别是要对相距较远的元素进行交换。一个排序算法通过删除逆序得以向前进行，而为了有效的进行，他必须使每次交换删除不止一个逆序。</li></ol></li></ol><h3 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h3><ol><li><p>排序思想</p><p>按照索引顺序，每一步将该索引上的值插入到前面已经有序的一组的值适当位置（通过二分查找法找到，可以减少比较次数）上，直到全部插入为止。</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left, current, mid, right;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            current = array[i];</div><div class="line">            left = <span class="number">0</span>;</div><div class="line">            right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">                mid = (left + right) / <span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span> (current &gt; array[mid]) &#123;</div><div class="line">                    left = mid + <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    right = mid - <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= left; k--) &#123;</div><div class="line">                array[k + <span class="number">1</span>] = array[k];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (left != i) &#123;</div><div class="line">                array[left] = current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>结论</p><ol><li>当N比较大时，二分插入排序的比较次数比直接插入排序的最差情况（反序）要好得多，但是比直接插入排序的最好情况（基本有序）要差。</li><li>当元素初始序列接近有序时，直接插入排序比二分插入排序的比较次数少。</li><li>二分插入排序元素移动次数与直接插入排序相同，依赖于元素的初始序列。</li></ol></li></ol><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ol><li><p>排序思想</p><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但到了这一步，数据几乎已经排好序。</p></li><li><p>排序演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E8%B0%A2%E5%B0%94%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png" alt="希尔排序"></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] e)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = e.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">int</span> j;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; e.length; i++) &#123;</div><div class="line">                <span class="keyword">int</span> current = e[i];</div><div class="line">                <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; e[j] &gt; current; j -= gap) &#123;</div><div class="line">                    e[j + gap] = e[j];</div><div class="line">                &#125;</div><div class="line">                e[j + gap] = current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>结论</p><ol><li>如果有一个<strong>很小的数据</strong>在一个已按升序排好序的数组的<strong>末端</strong>，如果用复杂度为\(O(N^2)\)的排序算法（<strong>冒泡排序</strong>或<strong>直接插入排序</strong>），可能会进行<strong>n次的比较和交换</strong>才能将该数据移至正确的位置。而希尔排序会用<strong>较大的步长</strong>移动数据，所以小数据只需要进行<strong>少数比较和交换</strong>即可到正确位置。</li><li>使用增量序列\(h_k\)进行一趟排序后，对于每个i我们都有\(a[i]&lt;=a[i+h_k]\)，所有相隔\(h_k\)的元素都被排序，此时称文件时\(h_k\)排序的。</li><li>\(h_k\)排序的实质就是，将\(h_k\)，\(h_k+1\)，···，\(N-1\)中的每个位置i，把该位置对应的元素放到\(i-{h_k}\)中的正确位置上。</li><li>一趟\(h_k\)排序的作用就是对\(h_k\)个独立的子数组执行一次插入排序。</li><li>一个\(h<em>k\)排序的文件（然后是\(h</em>{k-1}\)排序）会一直保持它的\(h_k\)排序性，前面各趟排序的成果不会被后面的排序打乱。</li><li><p>希尔排序<strong>不是稳定的排序算法</strong></p><p>虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性将会被打乱。</p><p>比如序列{ 3, 5, 10, <strong>8</strong>, 7, 2, <em>8</em>, 1, 20, 6 }h=2时分成两个子序列 { 3, 10, 7, <em>8</em>, 20 } 和 { 5, <strong>8</strong>, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, <em>8</em>, 10, 20 } 和 { 1, 2, 5, 6, <strong>8</strong> } ，即 { 3, 1, 7, 2, <em>8</em>, 5, 10, 6, 20, <strong>8</strong> } ，两个8的相对次序发生了改变。</p></li></ol></li></ol><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><ol><li><p>排序思想</p><p>按照索引顺序，每趟会在该索引后的元素中找出一个最小元素与当前索引处的元素进行交换。</p></li><li><p>排序演示</p><ol><li><p>简单排序过程示例</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.jpg" alt="简单排序"></p></li><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="简单排序"></p></li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> minValue = array[i];</div><div class="line">            <span class="keyword">int</span> minIndex = i;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt; minValue) &#123;</div><div class="line">                    minValue = array[j];</div><div class="line">                    minIndex = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            array[minIndex] = array[i];</div><div class="line">            array[i] = minValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>结论</p><ol><li>简单选择排序的时间复杂度都为\(O(N^2)\)；</li><li>是不稳定的排序算法</li></ol></li><li><p>简单选择排序的改进</p><p>将每趟循环可以确定两个元素（最大和最小值），从而减少排序所需的循环次数。 改进后对\(N\)个数据进行排序，最多只需进行\(N/2\)趟即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, min, max, len = array.length; i &lt;= len / <span class="number">2</span>; i++) &#123;</div><div class="line">            min = max = i;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= len - i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &gt; array[max]) &#123;</div><div class="line">                    max = j;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt; array[min]) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//该交换操作还可分情况讨论以提高效率</span></div><div class="line">            Utils.swap(array, min, i - <span class="number">1</span>);</div><div class="line">            Utils.swap(array, max, len - i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li><p>排序思想</p><p>优先队列可以用于以<code>O(NlogN)</code>时间来排序，基于该思想的算法叫做<strong>堆排序heapsort</strong>。在建立N个元素的二叉堆时，该阶段花费\(O(N)\)时间，然后又执行N次deleteMin操作，由于每个deleteMin花费时间\(O(logN)\)，因此总运行时间是\(O(NlogN)\)。</p><p>优先队列的算法主要问题在于，它使用了一个附加数组，因此，存储需求增加一倍。但不会太影响时间问题，附加的时间消耗只有\(O(N)\)，只是增加了空间复杂度。</p><p>那么对于以上问题，在堆排序中的解决方案是：在每次deleteMin之后，将堆缩小1。因此，堆中的最后一个单元可以用来存放刚刚删除的元素。使用这种策略，在最后一次deleteMin之后，该数组将以递减的顺序包含这些元素。如果想要排成更典型的递增顺序，那么可以在构建堆的时候建立<strong>最大堆</strong>。</p></li><li><p>算法演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt=""></p></li><li><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            percolateDown(array, i, array.length);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">            Utils.swap(array, <span class="number">0</span>, i);</div><div class="line">            percolateDown(array, <span class="number">0</span>, i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">percolateDown</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> child;</div><div class="line">        <span class="keyword">int</span> tmp;</div><div class="line">        <span class="keyword">for</span> (tmp = a[i]; leftChild(i) &lt; n; i = child) &#123;</div><div class="line">            child = leftChild(i);</div><div class="line">            <span class="comment">//找到i孩子节点中最大的一个</span></div><div class="line">            <span class="keyword">if</span> (child != n - <span class="number">1</span> &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>]) &#123;</div><div class="line">                child++;<span class="comment">//i的右孩子</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (tmp &lt; a[child]) &#123;<span class="comment">//如果较大的子结点大于父结点  </span></div><div class="line">                a[i] = a[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点 </span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        a[i] = tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol><li><p>排序思想</p><p>通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了，重复N次即可以使数组有序。</p></li><li><p>排序演示</p><ol><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm739525-20160329100443676-1647340243%5B1%5D.gif" alt=""></p></li><li><p>排序过程示意图</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.jpg" alt=""></p></li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="comment">// j &lt; array.length - i - 1 意思是后面的已经有序，不需要在判断</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">                    Utils.swap(array, j, j + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>结论</p><p>冒泡排序是基于比较的算法，时间复杂度为\(O(N^2)\)，只有在<strong>n比较小</strong>的时候性能才比较好。</p></li><li><p>冒泡排序算法改进</p><ol><li>设置一个标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos之后的记录均已交换到位，因此在下一趟排序时只要扫描到pos位置即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; ) &#123;</div><div class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                    <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">                        pos = j;</div><div class="line">                        Utils.swap(array, j, j + <span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                i = pos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol></li></ol><pre><code>2. 传统冒泡排序在每趟的操作中只能找到一个最大值或最小值，因此，考虑利用在每趟排序中进行正向和反向的两边冒泡方法一次可以得到两个最终值（最大值和最小值），从而使排序趟数几乎减少一半。
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</div><div class="line">               <span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</div><div class="line">                   Utils.swap(array, i, i + <span class="number">1</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           high--;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = high; i &gt; low; i--) &#123;</div><div class="line">               <span class="keyword">if</span> (array[i] &lt; array[i - <span class="number">1</span>]) &#123;</div><div class="line">                   Utils.swap(array, i, i - <span class="number">1</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           low++;</div><div class="line">       &#125;</div><div class="line">   </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li><p>排序思想</p><ol><li>选取一个基准pivot元素，通常选择第一个元素或者最后一个元素；</li><li>进行分区partition操作，通过一趟排序将待排序的记录分割成两个部分，其中一个部分的元素均比基准元素小，另一部分元素均比基准元素大；</li><li>对每个分区递归地进行步骤1~3，递归的结束条件是子序列的大小是0或1，这时整体已经排好序。</li></ol></li><li><p>排序演示</p><ol><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt=""></p></li><li><p>排序过程</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png" alt=""></p></li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">            <span class="keyword">int</span> pivot = partition(array, low, high);</div><div class="line">            quickSort(array, <span class="number">0</span>, pivot - <span class="number">1</span>);</div><div class="line">            quickSort(array, pivot + <span class="number">1</span>, high);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pivot = array[low]; low &lt; high; ) &#123;</div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[high] &gt;= pivot) &#123;</div><div class="line">                high--;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[low] &lt;= pivot) &#123;</div><div class="line">                low++;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>结论</p><ol><li>最<strong>坏</strong>的情况下，也就是每次选取的基准都是<strong>最大或最小的元素</strong>（例如，在上例7,8,10,9中），导致每次只划分出了一个子序列，需要进行n-1次划分才能结束递归，时间复杂度为<code>O(n^2)</code>；</li><li>最好的情况下，每次选取的基准都能均匀划分，只需要<code>logN</code>次划分就能结束递归，时间复杂度为<code>O(logN)</code>。</li><li>平均情况下，需要的时间复杂度为<code>O(NlogN)</code>。</li><li>快速排序不是稳定的排序算法。</li></ol></li><li><p>快速排序算法改进</p><p>快速排序通常被认为在同数量级\(O(NlogN)\)的排序方法中性能最好的，若初始序列已经基本有序，快排反而退化为冒泡排序。</p><p>在改进的算法中，只对长度大于k的子序列递归调用快速排序，让原序列基本有序，然后再对整个基本有序的序列使用直接插入排序。实践证明，改进后的算法时间复杂度有所降低，且当k取8左右的时候，改进算法的性能最优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        quickSortImprove(array, <span class="number">0</span>, array.length - <span class="number">1</span>, k);</div><div class="line">        StraightInsertSort.sort(array);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortImprove</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (high - low &gt; k) &#123;</div><div class="line">            <span class="keyword">int</span> pivot = partition(array, low, high);</div><div class="line">            quickSortImprove(array, <span class="number">0</span>, pivot - <span class="number">1</span>, k);</div><div class="line">            quickSortImprove(array, pivot + <span class="number">1</span>, high, k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pivot = array[low]; low &lt; high; ) &#123;<span class="comment">//从表的两端交替地向中间扫描</span></div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[high] &gt;= pivot) &#123; <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端</span></div><div class="line">                high--;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; array[low] &lt;= pivot) &#123;</div><div class="line">                low++;</div><div class="line">            &#125;</div><div class="line">            Utils.swap(array, low, high);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><ol><li><p>排序思想</p><p>归并排序是采用分治法的一个非常典型的应用，归并排序的思想就是先<strong>递归分解</strong>数组，再<strong>合并数组</strong>。</p><p>先考虑<strong>合并</strong>两个有序数组，基本思路是两个输入数组A和B，一个输出数组C，以及3个计数器ai、bi、ci，他们的初始置于对应数组的开始端。A[ai]和B[bi]中的最小者被拷贝到C中的下一个位置，相关的计数器向前推进一步。当两个输入表有一个用完时，则将另一个表剩余部分拷贝到C中。</p><p>再考虑<strong>递归分解</strong>，基本思路是将数组分解成<code>left</code>和<code>right</code>，如果这两个数组内部数据是有序的，那么就可以用上面的合并数组方式将这两个数组合并排序。如何让这两个数组内部有序？可以再二分，直至分解出的小组含有一个元素为止，此时认为该小组内部已有序，然后<strong>合并</strong>排序相邻两个小组即可。</p></li><li><p>排序演示</p><ol><li><p>动图演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE.gif" alt="归并排序动图"></p></li><li><p>排序过程</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">before sort= 5 9 4 3 2 6 10 1 7 8 </div><div class="line">-------------------</div><div class="line">left[0:0]  = 5 </div><div class="line">                    ====&gt; 5 9 0 0 0 0 0 0 0 0 </div><div class="line">right[1:1] = 9 </div><div class="line">-------------------</div><div class="line">left[0:1]  = 5 9 </div><div class="line">                    ====&gt; 4 5 9 0 0 0 0 0 0 0 </div><div class="line">right[2:2] = 4 </div><div class="line">-------------------</div><div class="line">left[3:3]  = 3 </div><div class="line">                    ====&gt; 4 5 9 2 3 0 0 0 0 0 </div><div class="line">right[4:4] = 2 </div><div class="line">-------------------</div><div class="line">left[0:2]  = 4 5 9 </div><div class="line">                    ====&gt; 2 3 4 5 9 0 0 0 0 0 </div><div class="line">right[3:4] = 2 3 </div><div class="line">-------------------</div><div class="line">left[5:5]  = 6 </div><div class="line">                    ====&gt; 2 3 4 5 9 6 10 0 0 0  </div><div class="line">right[6:6] = 10 </div><div class="line">-------------------</div><div class="line">left[5:6]  = 6 10 </div><div class="line">                    ====&gt; 2 3 4 5 9 1 6 10 0 0  </div><div class="line">right[7:7] = 1 </div><div class="line">-------------------</div><div class="line">left[8:8]  = 7 </div><div class="line">                    ====&gt; 2 3 4 5 9 1 6 10 7 8 </div><div class="line">right[9:9] = 8 </div><div class="line">-------------------</div><div class="line">left[5:7]  = 1 6 10 </div><div class="line">                    ====&gt; 2 3 4 5 9 1 6 7 8 10</div><div class="line">right[8:9] = 7 8 </div><div class="line">-------------------</div><div class="line">left[0:4]  = 2 3 4 5 9 </div><div class="line">                    ====&gt; 1 2 3 4 5 6 7 8 9 10 </div><div class="line">right[5:9] = 1 6 7 8 10 </div><div class="line">-------------------</div><div class="line"></div><div class="line">after sort = 1 2 3 4 5 6 7 8 9 10</div></pre></td></tr></table></figure></li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] tmpArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</div><div class="line">        sort(array, tmpArray, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</div><div class="line">            sort(array, tmp, left, center);</div><div class="line">            sort(array, tmp, center + <span class="number">1</span>, right);</div><div class="line">            merge(array, tmp, left, center + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] tmpArray, <span class="keyword">int</span> leftStart, <span class="keyword">int</span> rightStart, <span class="keyword">int</span> rightEnd)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> leftEnd = rightStart - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> tmpStart = leftStart;</div><div class="line">        <span class="keyword">int</span> numElements = rightEnd - leftStart + <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (leftStart &lt;= leftEnd &amp;&amp; rightStart &lt;= rightEnd) &#123;</div><div class="line">            <span class="keyword">if</span> (array[leftStart] &lt;= array[rightStart]) &#123;</div><div class="line">                tmpArray[tmpStart++] = array[leftStart++];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tmpArray[tmpStart++] = array[rightStart++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*将left剩余元素复制到tmp中*/</span></div><div class="line">        <span class="keyword">while</span> (leftStart &lt;= leftEnd) &#123;</div><div class="line">            tmpArray[tmpStart++] = array[leftStart++];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/*将right剩余元素复制到tmp中*/</span></div><div class="line">        <span class="keyword">while</span> (rightStart &lt;= rightEnd) &#123;</div><div class="line">            tmpArray[tmpStart++] = array[rightStart++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++, rightEnd--) &#123;</div><div class="line">            array[rightEnd] = tmpArray[rightEnd];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>结论</p><ol><li>归并排序是经典的分治策略，它将问题<strong>分（divide）</strong>成一些小问题然后递归求解，而<strong>治（conquer）</strong>的阶段则将分的阶段解得的各答案修补在一起。</li><li>最差的情况下，归并排序的运行时间是\(O(NlogN)\)，但是有一个明显的问题，整个算法还要花费将数据拷贝到临时数组再拷贝回来这样一个附加的工作，明显减慢了排序的速度。</li><li>归并排序使用所有流行排序算法中最少的比较次数。</li></ol></li></ol><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><ol><li><p>排序思想</p><p>将数组中的相邻元素两两配对，构成\(N/2\)个长度为2的排好序的子数组，然后再将他们排序成长度为4的子数组段，如此下去，直至整个数组排好序。</p></li><li><p>排序演示</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序非递归图解"></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 非递归排序</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = <span class="number">1</span>, len = array.length, tmpIndex, leftStart, leftEnd, rightStart, rightEnd; gap &lt; len; gap *= <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (tmpIndex = <span class="number">0</span>, leftStart = <span class="number">0</span>; leftStart &lt; len - gap; leftStart = rightEnd) &#123;</div><div class="line">                <span class="keyword">if</span> ((rightEnd = ((rightStart = leftEnd = leftStart + gap) + gap)) &gt; len) &#123;</div><div class="line">                    rightEnd = len;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (leftStart &lt; leftEnd &amp;&amp; rightStart &lt; rightEnd) &#123;</div><div class="line">                    tmp[tmpIndex++] = array[leftStart] &gt; array[rightStart] ? array[rightStart++] : array[leftStart++];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (leftStart &lt; leftEnd) &#123;</div><div class="line">                    array[--rightStart] = array[--leftEnd];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (tmpIndex &gt; <span class="number">0</span>) &#123;</div><div class="line">                    array[--rightStart] = tmp[--tmpIndex];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="排序综合比较"><a href="#排序综合比较" class="headerlink" title="排序综合比较"></a>排序综合比较</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">最差时间复杂度</th><th style="text-align:center">最优时间复杂度</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">辅助空间</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">二分插入排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">\(O(NlogN)-O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N^{1.3})\)</td><td style="text-align:center">\(O(NlogN)-O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(1)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快排序</td><td style="text-align:center">\(O(N^2)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(logN)-O(N)\)</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(NlogN)\)</td><td style="text-align:center">\(O(N)\)</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">\(O(N+K)\)</td><td style="text-align:center">\(O(N+K)\)</td><td style="text-align:center">\(O(N+K)\)</td><td style="text-align:center">\(O(K)\)</td><td style="text-align:center">稳定</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://segmentfault.com/a/1190000002595152#articleHeader18" target="_blank" rel="external">常用排序算法总结（性能+代码）</a></li><li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">经典排序算法总结与实现</a></li><li><a href="http://blog.csdn.net/morewindows/article/details/7961256" target="_blank" rel="external">白话经典算法系列</a></li><li><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="external">排序算法可视化</a></li><li><a href="http://blog.csdn.net/super_chris/article/details/4581900" target="_blank" rel="external">所谓堆和堆排序</a></li><li><a href="http://6924918.blog.51cto.com/6914918/1260860" target="_blank" rel="external">几种经典排序算法</a></li><li><a href="https://www.byvoid.com/zhs/blog/sort-radix" target="_blank" rel="external">三种线性排序算法 计数排序、桶排序与基数排序</a></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文是对8大排序算法总结，包括其排序思想、动图演示、代码实现和结论。
    
    </summary>
    
      <category term="算法" scheme="http://www.vibrancy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="8大排序算法" scheme="http://www.vibrancy.cn/tags/8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java8 HashMap原理分析</title>
    <link href="http://www.vibrancy.cn/repository/Java8%20HashMap%20principle%20analysis.html"/>
    <id>http://www.vibrancy.cn/repository/Java8 HashMap principle analysis.html</id>
    <published>2017-05-03T04:55:16.000Z</published>
    <updated>2017-05-14T00:34:52.072Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 14 2017 08:37:37 GMT+0800 (马来西亚半岛标准时间) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</li><li>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li>映射中的key是不可变对象，不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</li></ol><h3 id="类继承关系图"><a href="#类继承关系图" class="headerlink" title="类继承关系图"></a>类继承关系图</h3><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/diagram.svg" alt="hashmap"></p><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="几个重要的属性"><a href="#几个重要的属性" class="headerlink" title="几个重要的属性"></a>几个重要的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">transient Node&lt;K, V&gt;[] table; </div><div class="line">int threshold;</div><div class="line">final float loadFactor;</div><div class="line">transient int size; </div><div class="line">transient int modCount;</div><div class="line">static final int TREEIFY_THRESHOLD = 8;</div></pre></td></tr></table></figure><ol><li><p>table</p><ul><li>哈希桶数组</li><li>初始化长度length默认为16，长度必须为2的n次方（合数）。</li><li>常规设计是把length设计为<strong>素数</strong>，来减少hash冲突的概率。而HashMap在此是为了在<strong>取模和扩容</strong>的时候做优化，同时也为了减少冲突。</li></ul></li><li><p>loadFactor</p><ul><li>负载因子，是table中<strong>元素数量</strong>和<strong>table长度</strong>的比值。</li><li>默认值是0.75</li></ul></li><li><p>threshold</p><ul><li>HashMap所能容纳的最大数据量的Node(键值对)个数；</li><li>计算公式：<code>threshold = table.length * loadFactor</code>，结合公式可知，threshold是负载因子和数组长度对应下允许的最大元素数目，如果超过这个数目，那么就得重新扩容（resize），扩容后的容量是之前容量的2倍。</li><li>如果<strong>内存空间大</strong>而又对<strong>时间效率要求很高</strong>，可以<strong>降低</strong>负载因子Load factor的值。</li><li>如果<strong>内存空间紧张</strong>而对<strong>时间效率要求不高</strong>，可以<strong>增加</strong>负载因子loadFactor的值，这个值可以大于1。</li></ul></li><li><p>size</p><ul><li>HashMap中实际存在的键值对数量；</li><li>注意与<code>table.length</code>、<code>threshold</code>的区别。</li></ul></li><li><p>modCount</p><ul><li>记录HashMap内部结构发生变化的次数；</li><li>用于迭代的快速失败。</li></ul></li><li><p>TREEIFY_THRESHOLD</p><ul><li>链表转红黑树的长度阈值。</li></ul></li></ol><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>从结构实现来讲，HashMap是<strong>数组+链表+红黑树</strong>来实现的。</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/hashmap-inner-structure.png" alt="image"></p><p>从源码可知，<code>HashMap类</code>中有一个非常重要的字段，就是<code>Node[] table</code>，即上图中的<strong>哈希桶数组table</strong>，是一个<code>Node类型</code>的数组。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;</div><div class="line">    final int hash; //用来定位数组索引的位置</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K, V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry接口</code>，本质是就是一个映射(键值对)，上图中的每个黑色圆点就是一个<code>Node对象</code>。</p><p>HashMap就是使用<strong>哈希表</strong>来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题，Java中HashMap采用了<strong>链地址法</strong>，链地址法简单来说，就是数组加链表的结合。在每个数组元素上都对应一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p><p>如果<strong>哈希桶数组</strong>很大，即使较差的Hash算法也会比较分散；如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡。其实就是根据实际情况实行哈希数组的<strong>扩容或收缩</strong>，并在此基础上设计<strong>好的hash算法</strong>减少Hash碰撞。</p><p>负载因子和Hash算法设计的再合理，也免不了会出现链表过长的情况，一旦链表过长，则会严重影响HashMap的性能。当链表长度太长（默认超过<code>TREEIFY_THRESHOLD</code>）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><h3 id="核心方法分析"><a href="#核心方法分析" class="headerlink" title="核心方法分析"></a>核心方法分析</h3><h4 id="根据键值计算哈希桶数组的索引"><a href="#根据键值计算哈希桶数组的索引" class="headerlink" title="根据键值计算哈希桶数组的索引"></a>根据键值计算哈希桶数组的索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*</div><div class="line">* 根据key计算hash值</div><div class="line">*/</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    // h = key.hashCode(); 第一步、取 kek的hashCode值</div><div class="line">    // h ^ (h &gt;&gt;&gt; 16) 第二步、取hash的高位与hash参与异或运算</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 根据hash值和数组长度，计算key在table中的索引。</div><div class="line">* JDK8 中没有该方法，它直接在方法内部计算 hash &amp; (length - 1) 的值</div><div class="line">*/</div><div class="line">private static int indexFor(int hash, int length) &#123;</div><div class="line">    return hash &amp; (length - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不管是增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。对于任意给定的对象，只要hashCode相同，那么<code>hash()</code>方法返回的hash值总是相同的。一般情况下，将hash值与数组长度进行<strong>取模运算</strong>来得到数组索引，但是取模运算的消耗还是比较大的。在HashMap中，通过<code>indexFor()</code>方法来计算索引。</p><p><code>indexFor()</code>方法非常的巧妙，通过<code>hash &amp; (length-1)</code>得到对象的保存位置。因为HashMap底层数组的长度总是2的n次方，这时<code>hash &amp; (length-1)</code>运算等价于hash对length的取模，&amp;比%具有更高的效率。</p><p>画图说明<code>hash()</code>和<code>indexFor()</code>的运算过程:<br><img src="http://op87q3xru.bkt.clouddn.com/image/java/hash-indexfor.png" alt="image"></p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ol><li><p>put()流程</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/HashMap%20put%E6%B5%81%E7%A8%8B.jpg" alt="image"></p></li><li><p>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">               boolean evict) &#123;</div><div class="line">    Node&lt;K, V&gt;[] tab;</div><div class="line">    Node&lt;K, V&gt; p;</div><div class="line">    int n, i;</div><div class="line">    //table 是否为空 或者 长度为0</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0) &#123;</div><div class="line">        // resize 重新扩容</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    &#125;</div><div class="line">    //如果当前table索引上的值为空</div><div class="line">    if ((p = tab[i = hash &amp; (n - 1)]) == null)</div><div class="line">        //直接将值插入</div><div class="line">        tab[i] = newNode(hash, key, value, null);</div><div class="line">    else &#123;</div><div class="line">        Node&lt;K, V&gt; e;</div><div class="line">        K k;</div><div class="line">        // 如果 key 并且 hash 相同</div><div class="line">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            e = p;//直接覆盖value</div><div class="line">        else if (p instanceof TreeNode)</div><div class="line">            //如果是红黑树，则直接在树中插入键值对</div><div class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value);</div><div class="line">        else &#123;</div><div class="line">            //开始循环，遍历链表</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line"></div><div class="line">                if ((e = p.next) == null) &#123;</div><div class="line">                    //到了链表末尾</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div class="line">                        //链表长度大于8转换为红黑树进行处理</div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                // 如果 key 并且 hash 相同</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    //直接覆盖value</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        //超过最大容量 就扩容</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p><strong>扩容</strong>(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</p><p>下面举个例子说明下扩容过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;</div><div class="line">    HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(2);</div><div class="line">    printInfo(map, &quot;初始化HashMap的信息为：&quot;);</div><div class="line">    int[] values = &#123;3, 7, 5, 9&#125;;</div><div class="line">    for (int i = 0; i &lt; values.length; i++) &#123;</div><div class="line">        map.put(values[i], &quot;v&quot;);</div><div class="line">        printInfo(map, String.format(&quot;添加第%d个元素[%s=%s]后的info：&quot;, i + 1, values[i], &quot;v&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下图所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">初始化HashMap的信息为：</div><div class="line">size: 0</div><div class="line">tableLength: 0</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 2</div><div class="line">modCount: 0</div><div class="line">table:	null</div><div class="line"></div><div class="line">添加第1个元素[3=v]后的info：</div><div class="line">size: 1</div><div class="line">tableLength: 2</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 1</div><div class="line">modCount: 1</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [3=v]</div><div class="line"></div><div class="line">添加第2个元素[7=v]扩容后的info：</div><div class="line">size: 2</div><div class="line">tableLength: 4</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 3</div><div class="line">modCount: 2</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | null</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div><div class="line"></div><div class="line">添加第3个元素[5=v]后的info：</div><div class="line">size: 3</div><div class="line">tableLength: 4</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 3</div><div class="line">modCount: 3</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [5=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div><div class="line"></div><div class="line">添加第4个元素[9=v]扩容后的info：</div><div class="line">size: 4</div><div class="line">tableLength: 8</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 6</div><div class="line">modCount: 4</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v]</div><div class="line">	 4   | null</div><div class="line">	 5   | [5=v]</div><div class="line">	 6   | null</div><div class="line">	 7   | [7=v]</div></pre></td></tr></table></figure><p></p><p>经过观测可发现，HashMap的table数组长度使用的是2次幂的扩展（长度扩展为原来2倍），数组扩展后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置，扩展后对于<strong>元素新位置的判断</strong>对应的源码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">HashMap.resize():</div><div class="line"></div><div class="line">Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">Node&lt;K,V&gt; next;</div><div class="line">do &#123;</div><div class="line">    next = e.next;</div><div class="line">    if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">        if (loTail == null)</div><div class="line">            loHead = e;</div><div class="line">        else</div><div class="line">            loTail.next = e;</div><div class="line">        loTail = e;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (hiTail == null)</div><div class="line">            hiHead = e;</div><div class="line">        else</div><div class="line">            hiTail.next = e;</div><div class="line">        hiTail = e;</div><div class="line">    &#125;</div><div class="line">&#125; while ((e = next) != null);</div><div class="line">if (loTail != null) &#123;</div><div class="line">    loTail.next = null;</div><div class="line">    newTab[j] = loHead;</div><div class="line">&#125;</div><div class="line">if (hiTail != null) &#123;</div><div class="line">    hiTail.next = null;</div><div class="line">    newTab[j + oldCap] = hiHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接下来以<strong>添加第4个元素之后进行扩容</strong>的过程分析一下上面代码的原理</p><ol><li><p>以上4个元素的hash值分别为：</p><p>| key | hash |<br>| :—: | :—: |<br>| 3 | 3 |<br>| 7 | 7 |<br>| 5 | 5 |<br>| 9 | 9 |</p></li><li><p>当把第4个元素[9=v]添加进map之后，未扩容（未执行resize()）前的table为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [5=v] --&gt; [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div></pre></td></tr></table></figure></li></ol><ol><li><p>这时由于<code>++size &gt; threashold ==&gt; 4&gt;3</code> ，所以需要执行resize()方法</p><p>该过程为新建一个长度为原来2倍的数组，如果判断原来数组上的node是一个链表，那么会遍历链表，判断每个元素的<code>(e.hash &amp; oldCap)</code>的值是否为0，来决定链表中元素的新位置</p><p>| key | hash | (e.hash &amp; oldCap) | 是否为0 | 新索引 |<br>| :—: | :—: | :—————: | :—–: | :—-: |<br>| 3 | 3 | 0 | 是 | 3 |<br>| 7 | 7 | 4 | 否 | 3+4 |<br>| 5 | 5 | 4 | 是 | 1+4 |<br>| 9 | 9 | 0 | 否 | 1 |</p><p>根据上表的统计可以得出结论，如果<code>e.hash &amp; oldCap</code>为0，则位置索引不变；否则新的索引是<strong>原位置索引+oldCap</strong>的，那么扩容后的table为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v]</div><div class="line">	 4   | null</div><div class="line">	 5   | [5=v]</div><div class="line">	 6   | null</div><div class="line">	 7   | [7=v]</div></pre></td></tr></table></figure><p>该判断是JDK8的一个优化，不需要像JDK7那样重新计算hash，只需要判断元素的hash值与oldCap的与运算结果就好了。这样的设计省去了重新计算hash值的时间，并且能够均匀的把冲突的节点分散到新的table中去。另外，JDK8的HashMap在迁移链表的时候会保持链表元素的顺序不变。</p></li><li><p><code>resize()</code>方法的全部代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K, V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K, V&gt;[] oldTab = table;</div><div class="line">    int oldCapacity = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThreshold = threshold;</div><div class="line">    int newCapacity, newThreshold = 0;</div><div class="line">    if (oldCapacity &gt; 0) &#123;</div><div class="line">        if (oldCapacity &gt;= MAXIMUM_CAPACITY) &#123;//扩容前的数组大小如果已经达到最大(2^30)了</div><div class="line">            threshold = Integer.MAX_VALUE;//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</div><div class="line">            return oldTab;</div><div class="line">        &#125; else if ((newCapacity = oldCapacity &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                oldCapacity &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThreshold = oldThreshold &lt;&lt; 1; // 将容量和阈值在原来的基础上扩大2倍</div><div class="line">    &#125; else if (oldThreshold &gt; 0) // initial capacity was placed in threshold</div><div class="line">        newCapacity = oldThreshold;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCapacity = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThreshold = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThreshold == 0) &#123;</div><div class="line">        float ft = (float) newCapacity * loadFactor;</div><div class="line">        newThreshold = (newCapacity &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ?</div><div class="line">                (int) ft : Integer.MAX_VALUE);//修改阈值</div><div class="line">    &#125;</div><div class="line">    threshold = newThreshold;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</div><div class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCapacity];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCapacity; ++j) &#123;//遍历原来的哈希表数组</div><div class="line">            Node&lt;K, V&gt; current;</div><div class="line">            if ((current = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;//清空</div><div class="line">                if (current.next == null)//如果当前节点只有一个节点</div><div class="line">                    newTab[current.hash &amp; (newCapacity - 1)] = current;</div><div class="line">                else if (current instanceof TreeNode)//如果当前节点是红黑树</div><div class="line">                    ((TreeNode&lt;K, V&gt;) current).split(this, newTab, j, oldCapacity);</div><div class="line">                else &#123; // 当前是链表 ，保留顺序preserve order</div><div class="line">                    Node&lt;K, V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K, V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K, V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = current.next;</div><div class="line">                        if ((current.hash &amp; oldCapacity) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = current;</div><div class="line">                            else</div><div class="line">                                loTail.next = current;</div><div class="line">                            loTail = current;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = current;</div><div class="line">                            else</div><div class="line">                                hiTail.next = current;</div><div class="line">                            hiTail = current;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((current = next) != null);</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCapacity] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h3 id="并发的rehash过程"><a href="#并发的rehash过程" class="headerlink" title="并发的rehash过程"></a>并发的rehash过程</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，因为在并发的多线程使用场景中使用HashMap可能造成<strong>数据丢失</strong>。</p><ol><li><p>多线程测试HashMap的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(2, 0.75f);</div><div class="line">    AtomicInteger counter = new AtomicInteger(0);</div><div class="line">    map.put(5, &quot;C&quot;);</div><div class="line">    Runnable r1 = () -&gt; &#123;</div><div class="line">        map.put(7, &quot;B&quot;);</div><div class="line">        counter.incrementAndGet();</div><div class="line">    &#125;;</div><div class="line">    Runnable r2 = () -&gt; &#123;</div><div class="line">        map.put(3, &quot;A&quot;);</div><div class="line">        map.put(8, &quot;A&quot;);</div><div class="line">        counter.incrementAndGet();</div><div class="line">    &#125;;</div><div class="line">    new Thread(r1, &quot;thread1&quot;).start();</div><div class="line">    new Thread(r2, &quot;thread2&quot;).start();</div><div class="line">    while (true) &#123;</div><div class="line">        if (counter.get() == 2) &#123;</div><div class="line">            printInfo(map, &quot;&quot;);</div><div class="line">            System.out.println(map.get(7));</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过阻塞<code>thread1</code>的<code>resize()</code>，再让<code>thread2</code>执行，并进行<code>resize()</code>操作之后，最后打印的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">size: 4</div><div class="line">tableLength: 8</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 6</div><div class="line">modCount: 4</div><div class="line">table:索引 | 元素</div><div class="line">	 0   | [8=A]</div><div class="line">	 1   | null</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=A]</div><div class="line">	 4   | null</div><div class="line">	 5   | null</div><div class="line">	 6   | null</div><div class="line">	 7   | null</div><div class="line"></div><div class="line">null</div></pre></td></tr></table></figure><p>可见table的size为4，表明map经历了4次put过程，而实际上却只有两个元素，其他元素丢失了，那么接下来通过<code>IntellijIdea</code>的多线程断点调试来演示一下元素为什么丢失。</p></li><li><p>初始化一个调试环境</p><p><img src="http://op87q3xru.bkt.clouddn.com/gif/java%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E5%92%8C%E6%96%AD%E7%82%B9%E7%9A%84%E6%8C%82%E8%B5%B7%E6%A8%A1%E5%BC%8F.gif" alt="image"></p></li><li><p>用debug调试模拟多线程切换的流程</p><p><img src="http://op87q3xru.bkt.clouddn.com/gif/java%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug%E8%B0%83%E8%AF%95.gif" alt="image"></p><ol><li>点击debug按钮，这时断点会走到<code>thread1</code>处；</li><li>将<code>HashMap.resize(){next=e.next}</code>处打上断点，并设置挂起模式为thread。</li><li>接着开始执行thread1，这时thread1线程会停到刚才的断点处，相当于挂起thread1。</li><li>切换到thread2，并取消第2步设置的断点，让thread2能够一次性运行结束，并进行resize()过程。</li><li>thread2线程执行结束后，唤醒thread1，让thread1继续执行。</li><li>最后，通过打印的结果可知，数据丢失了。</li></ol></li><li><p>分析</p><p>通过分析<code>resize()</code>的源码可知，每次是让<code>table</code>指向一个<code>newTab</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">······</div><div class="line">threshold = newThr;</div><div class="line">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">table = newTab;</div><div class="line">······</div></pre></td></tr></table></figure><p>接着遍历<code>oldTab</code>，将原有的key-value存到<code>newTab</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line">                if ((e = oldTab[j]) != null) &#123;</div><div class="line">······</div><div class="line"></div><div class="line">if (loTail != null) &#123;</div><div class="line">    loTail.next = null;</div><div class="line">    newTab[j] = loHead;</div><div class="line">&#125;</div><div class="line">if (hiTail != null) &#123;</div><div class="line">    hiTail.next = null;</div><div class="line">    newTab[j + oldCap] = hiHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的<strong>第三步</strong>，<code>thread1</code>执行到<code>next = e.next</code>这挂起，接着唤醒<code>thread2</code>去执行，<code>thread2</code>把[8=A]放进map之后，也会执行resize()操作，这时会将 <code>table</code> 指向一个新的<code>newTab</code>，那么<code>thread1</code>的<code>newTab</code>将会失去引用，所以之前存储的值也就丢失了。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因此，在多线程环境中，使用<code>ConcurrentHashMap</code>替换<code>HashMap</code>，或者使用<code>Collections.synchronizedMap</code>将<code>HashMap</code>包装起来。</p><h2 id="JDK8和JDK7的HashMap性能对比"><a href="#JDK8和JDK7的HashMap性能对比" class="headerlink" title="JDK8和JDK7的HashMap性能对比"></a>JDK8和JDK7的HashMap性能对比</h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。</p><h3 id="Hash比较均匀的情况"><a href="#Hash比较均匀的情况" class="headerlink" title="Hash比较均匀的情况"></a>Hash比较均匀的情况</h3><ol><li><p>编写一个Key类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"> </div><div class="line">    private final int value;</div><div class="line"> </div><div class="line">    Key(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int compareTo(Key o) &#123;</div><div class="line">        return Integer.compare(this.value, o.value);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        if (this == o) return true;</div><div class="line">        if (o == null || getClass() != o.getClass())</div><div class="line">            return false;</div><div class="line">        Key key = (Key) o;</div><div class="line">        return value == key.value;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同。</p></li><li><p>创建Keys类，用于缓存Key，避免频繁的GC，而影响HashMap实际查找值的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Keys &#123;</div><div class="line"> </div><div class="line">    public static final int MAX_KEY = 10_000_000;</div><div class="line">    private static final Key[] KEYS_CACHE = new Key[MAX_KEY];</div><div class="line"> </div><div class="line">    static &#123;</div><div class="line">        for (int i = 0; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = new Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static Key of(int value) &#123;</div><div class="line">        return KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……、10000000）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void test(int mapSize) &#123;</div><div class="line"> </div><div class="line">       HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">       for (int i = 0; i &lt; mapSize; ++i) &#123;</div><div class="line">           map.put(Keys.of(i), i);</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       long beginTime = System.nanoTime(); //获取纳秒</div><div class="line">       for (int i = 0; i &lt; mapSize; i++) &#123;</div><div class="line">           map.get(Keys.of(i));</div><div class="line">       &#125;</div><div class="line">       long endTime = System.nanoTime();</div><div class="line">       System.out.println(endTime - beginTime);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">       for(int i=10;i&lt;= 1000 0000;i*= 10)&#123;</div><div class="line">           test(i);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li><li><p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响，结果如下：</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="image"></p><h3 id="hash极不均匀的情况"><a href="#hash极不均匀的情况" class="headerlink" title="hash极不均匀的情况"></a>hash极不均匀的情况</h3></li><li><p>假设我们有一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"> </div><div class="line">    //...</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>仍然执行main方法，得出的结果如下表所示</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="image"></p><p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，JDK1.8的HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要介绍了Java8 HashMap的实现原理、包括一些重要的成员变量、put方法分析，扩容分析、Java8与Java7HashMap性能对比。
    
    </summary>
    
      <category term="Java" scheme="http://www.vibrancy.cn/categories/Java/"/>
    
    
      <category term="java" scheme="http://www.vibrancy.cn/tags/java/"/>
    
      <category term="HashMap" scheme="http://www.vibrancy.cn/tags/HashMap/"/>
    
      <category term="红黑树" scheme="http://www.vibrancy.cn/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="散列表" scheme="http://www.vibrancy.cn/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android增量更新：服务器篇</title>
    <link href="http://www.vibrancy.cn/repository/android%20incremental%20update(server%20articles).html"/>
    <id>http://www.vibrancy.cn/repository/android incremental update(server articles).html</id>
    <published>2017-04-30T13:40:21.000Z</published>
    <updated>2017-05-14T00:34:18.905Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 14 2017 08:37:37 GMT+0800 (马来西亚半岛标准时间) --><h2 id="增量更新的原理"><a href="#增量更新的原理" class="headerlink" title="增量更新的原理"></a>增量更新的原理</h2><p>其实增量升级的原理很简单，即首先将应用的旧版本Apk与新版本Apk做差分，得到更新的部分的补丁，例如旧版本的APK有5M，新版的有8M，更新的部分则可能只有3M左右(这里需要说明的是，得到的差分包大小并不是简单的相减，因为其实需要包含一些上下文相关的东西——有时候旧版本10M，新版本8M，得到的差分包可能有5M)，使用差分升级的好处显而易见，那么你不需要下载完整的8M文件，只需要下载更新部分就可以，而更新部分可能只有3、4M，可以很大程度上减少流量的损失。</p><p>在用户下载了差分包之后，需要在手机端将他们组合起来。可以参考的做法是先将手机端的旧版本软件(多半在/data/下)，复制到SD卡或者cache中，将它们和之前的差分patch进行组合，得到一个新版本的apk应用，如果不出意外的话，这个生成的apk和你之前做差分的apk是一致的。</p><h2 id="增量更新实现"><a href="#增量更新实现" class="headerlink" title="增量更新实现"></a>增量更新实现</h2><h3 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h3><p>使用开源的二进制比较工具<a href="http://www.daemonology.net/bsdiff/" target="_blank" rel="external">bsdiff</a></p><p><img src="http://i.imgur.com/RBOUfG0.png" alt=""></p><p>及其依赖的<a href="http://www.bzip.org/downloads.html" target="_blank" rel="external">bzip2</a></p><p><img src="http://i.imgur.com/n4nI8zB.png" alt="bzip2"></p><p>下载完后，得到这样的目录结构：</p><p><img src="http://i.imgur.com/sxndK1G.png" alt=""></p><p><img src="http://i.imgur.com/Hgxvn4W.png" alt=""></p><p>其中bsdiff.c用于在服务端生成差分包，bspatch.c用于在客户端把旧版本apk与服务端生成的差分包进行合成为新版本apk。</p><h3 id="实现的步骤"><a href="#实现的步骤" class="headerlink" title="实现的步骤"></a>实现的步骤</h3><ol><li>在服务端，生成新旧版本的差分包</li><li>在客户端，使用已安装的旧版apk与这个差分包，合成为一个新版apk。</li><li>校验新合成的客户端文件是否完成，签名时候和已安装客户端一致，如一致，提示用户安装;</li></ol><h2 id="服务端生成差分包"><a href="#服务端生成差分包" class="headerlink" title="服务端生成差分包"></a>服务端生成差分包</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>由于服务器的不同，因此我们需要将以上的c/c++文件，build输出为动态链接库，以供java调用，其中Window环境生成名为libApkPatchLibraryServer.dll文件，Unix/Linux环境生成名为libApkPatchLibraryServer.so，OSX下生成名为libApkPatchLibraryServer.dylib的文件。下面具体讲一下在Windows服务器上怎么生成libApkPatchLibraryServer.dll文件的</p><h3 id="生成dll动态链接库"><a href="#生成dll动态链接库" class="headerlink" title="生成dll动态链接库"></a>生成dll动态链接库</h3><ol><li><p>下载开源工具</p><p>如果我们要生成dll动态链接库，那我们就不能用刚才下的bsdiff-4.3了（具体原因下面再说），我们需要在这里<a href="http://sites.inka.de/tesla/others.html#bsdiff" target="_blank" rel="external">bsdiff</a> 下载一个针对win32版本的bsdiff文件，下载页面如图所示：</p><p><img src="http://i.imgur.com/BaJoEl0.png" alt=""></p><p>下载得到的文件如图所示：</p><p><img src="http://i.imgur.com/pTbSJ1G.png" alt=""></p><p>里面已经包含了<code>bsdiff.cpp</code>，<code>bspatch.cpp</code>及其依赖的<code>bzlip</code>等文件。</p></li><li><p>改写bsdiff.cpp（生成差分包）</p><p>首先，在MyEclispe中声明一个native方法，如图所示：</p><p><img src="http://i.imgur.com/2kep1Su.png" alt=""></p><p>接着，为了生成的方便，将该类及完整的所在包复制到桌面上，我们利用javac 和javap命令将该native方法生成c/c++中对应的.h头文件：</p><p><img src="http://i.imgur.com/OytWPaJ.png" alt=""></p><p><img src="http://i.imgur.com/4k1bWXg.png" alt=""></p><p><img src="http://i.imgur.com/55agjAq.png" alt=""></p><p>这时，我们可以看到在桌面上生成了一个<code>com_cwc_smartupdate_util_DiffUtil.h</code>的头文件。打开头文件，如下图所示：</p><p><img src="http://i.imgur.com/H9elGXU.png" alt=""></p><p>以上代码需要说明一下，首先函数名的格式遵循如下规则：<code>Java_包名_类名_方法名</code>。其中，<code>JNIEXPORT</code>、<code>JNICALL</code>、<code>JNIEnv</code>和<code>jobject</code>都是JNI标准中定义的类型或者宏。</p></li><li><p>实现JNI方法</p><p>这里可以选用c或c++实现，我们这使用的是c++，因为在上文中下载win32版本的<code>bsdiff</code>中的<code>bsdiff.cpp</code>就是用c++实现的，接着我们打开该文件进行改写。（注意：我这以下的所有操作都是基于VS2013，因为涉及到很多c和h文件的引用，如果使用命令行的话，在连接阶段可能出现函数未定义的情况，为了简便本人直接使用了VS2013来生成dll文件）。</p><p>首先，利用vs2013新建一个dll项目，将<code>bsdiff4.3-win32-src.zip</code>解压得到的文件导入该项目中，并将bsdiff.cpp重新命名为<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>，另外，这里还需要三个头文件，分别是<code>jni.h</code>、<code>jni_md.h</code>（在两个在ndk里面找，可以在该ndk根文件夹子下全文搜索一下）和刚才生成的<code>com_cwc_smartupdate_util_DiffUtil.h</code>，最终得到的目录结构如下：</p><p><img src="http://i.imgur.com/gG7T8nm.png" alt=""></p><p>接着我们打开<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>文件，进行我们的改写操作，首先，引入头文件：</p><p><img src="http://i.imgur.com/V2AFD3j.png" alt=""><img src="http://i.imgur.com/uQiK24i.png" alt=""></p><p>之后，把<code>typedef long pid_t</code>注释掉，并添加<code>ftello</code>和<code>fseeko</code>两个函数宏定义，如图所示：</p><p><img src="http://i.imgur.com/NHRemD6.png" alt=""></p><p>接着，我们来实现<code>com_cwc_smartupdate_util_DiffUtil.h</code>中的函数，代码如下：</p><p><img src="http://i.imgur.com/G0Frtwr.png" alt=""></p><p>这段代码意思是将传入的三个字符串（新旧版本的文件路径和生成的差分包路径）分别放进一个<code>char* 类型</code>的指针数组里面，然后调用appDiff函数，生成差分包。那这个appDiff如何实现呢，我们找到该文件下的main方法，将该main方法重命名为appDiff：</p><p><img src="http://i.imgur.com/MckAKMJ.png" alt=""></p><p><img src="http://i.imgur.com/oCMUkUw.png" alt=""></p><p>接着，把该<code>appDiff函数</code>向下拖动，会看到这段代码，这段代码用于通过打开旧版本文件，将文件的数据读到名为old的内存当中，这段代码改写如下：</p><p><img src="http://i.imgur.com/e9f694c.png" alt=""></p><p>因为<code>lseek</code>，<code>open</code>等函数都是Linux里面的，如果在window下使用会出现打开文件失败的情况。改写的文件如下，其中stream是新定义的一个<code>FILE* stream</code>;文件类型指针：</p><p><img src="http://i.imgur.com/eDPNUHG.png" alt=""></p><p>通过这段代码可以将旧版本文件数据读取到<code>u_char* old</code>中。接着，我们改写读取新文件的这段代码，代码如下：</p><p><img src="http://i.imgur.com/8INJLrO.png" alt=""></p><p>改写成：</p><p><img src="http://i.imgur.com/quzwfPh.png" alt=""></p><p>到此为止，我们的所有操作就全部完成了，接下来我们生成dll文件，在生成的dll文件中也注意是32位的还是64位的，不然在java调用的时候会出现读取失败的情况。</p><h2 id="在服务端调用dll文件"><a href="#在服务端调用dll文件" class="headerlink" title="在服务端调用dll文件"></a>在服务端调用dll文件</h2></li></ol><p><img src="http://i.imgur.com/HSbsyVA.png" alt=""></p><p>其中，<code>DiffAppServer64</code>就是刚才生成的dll文件，由于<code>DiffAppServer64.dll</code>需要依赖其他的dll文件，我这需要依赖<code>msvcr100d</code>和<code>kernel32</code>，所以在这里也必须将两个文件导入才行。最后，这三个文件放置的位置如图所示：</p><p><img src="http://i.imgur.com/q7Sl981.png" alt=""></p><p>在tomcat根目录下的bin子目录下新建一个appdiff目录，然后把三个文件放到这里。当这些所有的操作完成之后，就可以在服务端生成差分包了。</p><h2 id="运行效果展示"><a href="#运行效果展示" class="headerlink" title="运行效果展示"></a>运行效果展示</h2><h3 id="apk文件上传页面面"><a href="#apk文件上传页面面" class="headerlink" title="apk文件上传页面面"></a>apk文件上传页面面</h3><p><img src="http://i.imgur.com/1PmCkic.png" alt=""></p><h3 id="旧版本文件上传"><a href="#旧版本文件上传" class="headerlink" title="旧版本文件上传"></a>旧版本文件上传</h3><p><img src="http://i.imgur.com/r0003FO.png" alt=""></p><h3 id="新版本文件上传"><a href="#新版本文件上传" class="headerlink" title="新版本文件上传"></a>新版本文件上传</h3><p><img src="http://i.imgur.com/3LUG2ic.png" alt=""></p><h3 id="当上传新版本后，服务端后台就自动开始生成差分包的工作了"><a href="#当上传新版本后，服务端后台就自动开始生成差分包的工作了" class="headerlink" title="当上传新版本后，服务端后台就自动开始生成差分包的工作了"></a>当上传新版本后，服务端后台就自动开始生成差分包的工作了</h3><p><img src="http://i.imgur.com/FeEghkb.png" alt=""></p><p><img src="http://i.imgur.com/sSoD3Wd.png" alt=""></p><p>那么又涉及到另外一个问题，由于比较生成差分包在底层进行，并且非常的耗时，大概需要1分多钟，那么如何显示进度，生成差分包的工作进行到哪一步了？这就需要利用jni调用java方法，将底层的信息传到java代码层。</p><h2 id="jni调用java方法，回传底层的进度信息"><a href="#jni调用java方法，回传底层的进度信息" class="headerlink" title="jni调用java方法，回传底层的进度信息"></a>jni调用java方法，回传底层的进度信息</h2><ol><li><p>在声明genDiff 这个native方法的的类中<code>java.cwc.smartupdate.util.DiffUtil</code>声明一个静态的方法：</p><p><img src="http://i.imgur.com/EHppmhA.png" alt=""></p><p>这个方法表示，在c底层进行调用该方法，传递整型state参数，通过对比不同的整型数据，找到底层对应的执行进度。</p></li><li><p>让我们返回到<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>文件中，找到我们在上文中实现的本地方法对应的函数：</p><p><img src="http://i.imgur.com/Llrwt4j.png" alt=""></p><p>为了方便演示，在这个函数上面定义一个用于发布进度的函数：</p><p><img src="http://i.imgur.com/KFULVhk.png" alt=""></p><p>这段函数的意思就是通过反射来调用DiffUtil类内的静态方法publishProgress，然后在appDiff函数内部，就可以在关键的地方调用该函数用来发布当前执行任务的状态了，（注意定义的函数需要在该文件头部声明，不然出现找不到函数的错误提示），另外还有一点需要注意，publishProgress需要调用不止一次，因此不可能每次都通过反射来创建DiffUtil的类对象(创建一次就够了)，因此，我们需要将上面的函数整理为以下格式：</p><p><img src="http://i.imgur.com/70bdDfk.png" alt=""></p></li><li><p>服务端的java代码层</p><p>由于publishProgress传递的是整型数据，我们可以自定义一些整型常量来映射出对应的任务状态。还可以在该DiffUtil定义一个内部接口，这样其他类实现了该接口，就可以接收到底层返回的进度。</p><p><img src="http://i.imgur.com/oOEXgk0.png" alt=""></p><p><img src="http://i.imgur.com/ZhwlIHh.png" alt=""></p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>到此为止，整个增量更新的服务端是实现就结束了，总结一下：</p><ul><li>我们首先在java中定义了一个本地native方法，通过javac和javap命令生成了对应的h头文件；</li><li>然后改写bsdiff.cpp文件，实现刚才生成的头文件中的函数，并针对windows服务器改写bsdiff.cpp的函数内部的细节；</li><li>最后进行将生成的dll文件放到了tomcat服务器中，利用System.loadLibrary函数加载dll文件，如果缺少依赖dll的话，就添加对应的dll文件；</li><li>最后为了实现进度的显示，我们又定义了publishProgress方法，并在底层实现了该函数，在java端的DiffUtil类中定义了一个接口，让其他实现该接口的类可以接收到底层发布的进度。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要是对增量更新服务器端如果实现进行详细的介绍。
    
    </summary>
    
      <category term="Android" scheme="http://www.vibrancy.cn/categories/Android/"/>
    
    
      <category term="增量更新" scheme="http://www.vibrancy.cn/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    
      <category term="android" scheme="http://www.vibrancy.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>到底什么时候该使用MQ</title>
    <link href="http://www.vibrancy.cn/repository/when%20to%20use%20MQ%20.html"/>
    <id>http://www.vibrancy.cn/repository/when to use MQ .html</id>
    <published>2017-04-29T22:23:39.000Z</published>
    <updated>2017-05-14T00:34:18.795Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 14 2017 08:37:37 GMT+0800 (马来西亚半岛标准时间) --><h2 id="MQ的用途"><a href="#MQ的用途" class="headerlink" title="MQ的用途"></a>MQ的用途</h2><p>消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。</p><p>在互联网架构中，MQ是一种非常常见的上下游“<strong>逻辑解耦+物理解耦</strong>”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，逻辑上和物理上都不用依赖其他服务。</p><p><img src="http://op87q3xru.bkt.clouddn.com/message%20queue.png" alt="mq"></p><h2 id="不使用MQ的情况"><a href="#不使用MQ的情况" class="headerlink" title="不使用MQ的情况"></a>不使用MQ的情况</h2><p>MQ作为互联网分层架构中的解耦利器，那为什么不是所有通讯都使用MQ呢？因为，调用与被调用的关系，是无法被MQ取代的。<strong>调用方实时依赖执行结果的业务场景，请使用调用，而不是MQ</strong>。</p><h3 id="MQ的缺陷"><a href="#MQ的缺陷" class="headerlink" title="MQ的缺陷"></a>MQ的缺陷</h3><ul><li>系统更复杂，多了一个MQ组件；</li><li>消息传递路径更长，延时增加；</li><li>消息<strong>可靠性</strong>和<strong>重复性</strong>互为矛盾，消息不丢不重难以同时保证；</li><li>上游无法知道下游的执行结果，这一点是很致命的。</li></ul><h2 id="什么时候使用MQ"><a href="#什么时候使用MQ" class="headerlink" title="什么时候使用MQ"></a>什么时候使用MQ</h2><h3 id="场景一：数据驱动的任务依赖"><a href="#场景一：数据驱动的任务依赖" class="headerlink" title="场景一：数据驱动的任务依赖"></a>场景一：数据驱动的任务依赖</h3><ol><li><p>什么是任务依赖</p><p>互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，比如：</p><ul><li>task3需要使用task2的输出作为输入；</li><li><p>task2需要使用task1的输出作为输入；</p><p>这样的话，tast1,task2,task3之间就有任务依赖关系，必须task1先执行，再task2执行，载task3执行。</p></li></ul></li><li><p>使用cron人工排执行时间表</p><ol><li>task1，0:00执行，经验执行时间为50分钟</li><li>task2，1:00执行（为task1预留10分钟buffer），经验执行时间也是50分钟</li><li>task3，2:00执行（为task2预留10分钟buffer）</li></ol></li><li><p>使用cron的缺点</p><ul><li>如果有一个任务<strong>执行时间超过了预留buffer的时间，将会得到错误的结果</strong>，因为后置任务不清楚前置任务是否执行成功，此时要手动重跑任务，还有可能要调整排班表。</li><li>总任务的<strong>执行时间很长</strong>，总是要预留很多buffer，如果前置任务提前完成，后置任务不会提前开始。</li><li>如果一个任务被多个任务依赖，这个任务将会称为<strong>关键路径</strong>，排班表很难体现依赖关系，容易出错。</li><li>如果有一个任务的执行时间要调整，将会有<strong>多个任务的执行时间要调整</strong></li></ul></li><li><p>采用MQ解耦方案</p><ol><li>task1准时开始，结束后发一个“task1 done”的消息</li><li>task2订阅“task1 done”的消息，收到消息后第一时间启动执行，结束后发一个“task2done”的消息。</li><li>task3同理</li></ol></li><li><p>采用MQ的优点</p><ul><li>不需要预留buffer，上游任务执行完，<strong>下游任务总会在第一时间被执行。</strong></li><li>依赖多个任务，被多个任务依赖都很好处理，<strong>只需要订阅相关消息</strong>即可</li><li>有任务执行时间变化，下游任务都<strong>不需要调整执行时间</strong>。</li></ul></li><li><p>MQ使用注意</p><p>MQ只用来传递上游任务<strong>执行完成的消息</strong>，并不用于传递真正的<strong>输入输出</strong>数据。</p></li></ol><h3 id="典型场景二：上游不关心执行结果"><a href="#典型场景二：上游不关心执行结果" class="headerlink" title="典型场景二：上游不关心执行结果"></a>典型场景二：上游不关心执行结果</h3><ol><li><p>58同城的很多下游需要关注“用户发布帖子”这个事件</p><p>比如招聘用户发布帖子后，招聘业务要奖励58豆，房产用户发布帖子后，房产业务要送2个置顶，二手用户发布帖子后，二手业务要修改用户统计数据。</p></li><li><p>采用调用关系解决</p><p>帖子发布服务执行完成之后，调用下游招聘业务、房产业务、二手业务，来完成消息的通知，但事实上，这个通知是否正常正确的执行，帖子发布服务根本不关注。</p></li><li><p>采用调用的缺陷</p><ul><li>帖子发布流程的执行时间增加了</li><li>下游服务宕机，可能导致帖子发布服务受影响，上下游逻辑+物理依赖严重。</li><li>每当增加一个需要知道“帖子发布成功”信息的下游，修改代码的是帖子发布服务，这一点是最恶心的，属于<strong>架构设计中典型的依赖倒转</strong>，谁用过谁痛谁知道。</li></ul></li><li><p>采用MQ解耦方案</p><ul><li>帖子发布成功后，向MQ发一个消息</li><li>哪个下游关注“帖子发布成功”的消息，主动去MQ订阅</li></ul></li><li><p>采用MQ的优点</p><ul><li>上游<strong>执行时间短</strong></li><li><strong>上下游逻辑+物理解耦</strong>，除了与MQ有物理连接，模块之间都不相互依赖</li><li><strong>新增一个下游消息关注方，上游不需要修改任何代码</strong>。</li></ul></li></ol><h3 id="典型场景三：上游关注执行结果，但执行时间很长"><a href="#典型场景三：上游关注执行结果，但执行时间很长" class="headerlink" title="典型场景三：上游关注执行结果，但执行时间很长"></a>典型场景三：上游关注执行结果，但执行时间很长</h3><ol><li><p>微信支付</p><p>跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果，此时一般怎么玩呢？</p><p><img src="http://op87q3xru.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5.png" alt="image"></p></li></ol><ol><li>采用“回调网关+MQ”方案来解耦：<ol><li>调用方直接跨公网调用微信接口</li><li>微信返回调用成功，此时并不代表返回成功</li><li>微信执行完成后，回调统一网关</li><li>网关将返回结果通知MQ</li><li>请求方收到结果通知</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么时候不使用MQ？"><a href="#什么时候不使用MQ？" class="headerlink" title="什么时候不使用MQ？"></a>什么时候不使用MQ？</h3><p>上游实时关注执行结果</p><h3 id="什么时候使用MQ？"><a href="#什么时候使用MQ？" class="headerlink" title="什么时候使用MQ？"></a>什么时候使用MQ？</h3><ol><li>数据驱动的任务依赖</li><li>上游不关心多下游执行结果</li><li>异步返回执行时间长</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要介绍了消息队列的使用场景
    
    </summary>
    
      <category term="架构师" scheme="http://www.vibrancy.cn/categories/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
    
      <category term="架构" scheme="http://www.vibrancy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="消息队列" scheme="http://www.vibrancy.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat多实例单应用部署方案</title>
    <link href="http://www.vibrancy.cn/repository/Tomcat%20multi-instance%20single%20application%20deployment%20plan.html"/>
    <id>http://www.vibrancy.cn/repository/Tomcat multi-instance single application deployment plan.html</id>
    <published>2017-04-29T02:20:53.000Z</published>
    <updated>2017-05-14T00:34:18.948Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 14 2017 08:37:37 GMT+0800 (马来西亚半岛标准时间) --><h2 id="Tomcat部署的场景分析"><a href="#Tomcat部署的场景分析" class="headerlink" title="Tomcat部署的场景分析"></a>Tomcat部署的场景分析</h2><h3 id="单实例单应用"><a href="#单实例单应用" class="headerlink" title="单实例单应用"></a>单实例单应用</h3><p>如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。</p><h3 id="单实例多应用"><a href="#单实例多应用" class="headerlink" title="单实例多应用"></a>单实例多应用</h3><p>是把多个应用程序的war包放在同一个tomcat的webapps目录，这样一来，关闭和启动tomcat会影响所有项目。</p><h3 id="多实例单应用"><a href="#多实例单应用" class="headerlink" title="多实例单应用"></a>多实例单应用</h3><p>各个tomcat都运行同一个应用程序，对应地需要修改不同的监听端口，这种方式通常会和apache httpd或者nginx整合使用，做一些负载均衡的处理。</p><h3 id="多实例多应用"><a href="#多实例多应用" class="headerlink" title="多实例多应用"></a>多实例多应用</h3><p>相当于第一种场景的复数形式，除了修改不同的监听端口，没有本质区别。</p><h2 id="Windows服务器下多实例单应用设置流程"><a href="#Windows服务器下多实例单应用设置流程" class="headerlink" title="Windows服务器下多实例单应用设置流程"></a>Windows服务器下多实例单应用设置流程</h2><h3 id="分离目录"><a href="#分离目录" class="headerlink" title="分离目录"></a>分离目录</h3><ol><li><p>刚解压出来的tomcat目录结构</p><ul><li>bin：主要存放脚本文件，例如比较常用的windows和linux系统中启动和关闭脚本</li><li>conf：主要存放配置文件，其中最重要的两个配置文件是server.xml和web.xml</li><li>lib：主要存放tomcat运行所依赖的包</li><li>logs：主要存放运行时产生的日志文件，例如catalina.{date}.log等</li><li>temp：存放tomcat运行时产生的临时文件，例如开启了hibernate缓存的应用程序，会在该目录下生成一些文件</li><li>webapps：部署web应用程序的默认目录</li><li>work：主要存放由JSP文件生成的servlet（java文件以及最终编译生成的class文件）</li></ul></li><li><p>将解压出来的tomcat文件拆分出的目录结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">F:/DevLibs/Tomcat</div><div class="line">├─applications</div><div class="line">│  ├─backend  # 主要部署后端模块代码</div><div class="line">│  │  │  shutdown.bat</div><div class="line">│  │  │  startup.bat</div><div class="line">│  │  ├─conf</div><div class="line">│  │  ├─logs</div><div class="line">│  │  ├─temp</div><div class="line">│  │  ├─webapps   </div><div class="line">│  │  └─work</div><div class="line">│  └─officals-website # 主要部署前端代码，如官方网站</div><div class="line">│     │  shutdown.bat</div><div class="line">│     │  startup.bat</div><div class="line">│     ├─conf</div><div class="line">│     ├─logs</div><div class="line">│     ├─temp</div><div class="line">│     ├─webapps</div><div class="line">│     └─work</div><div class="line">├─bin</div><div class="line">└─lib</div></pre></td></tr></table></figure></li></ol><h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><ol><li><p>环境变量说明</p><ul><li>CATALINA_HOME：即指向<strong>Tomcat安装路径</strong>的系统变量</li><li><p>CATALINA_BASE：即指向<strong>活跃配置路径</strong>的系统变量</p><p>通过设置这两个变量，就可以将tomcat的<strong>安装目录和工作目录</strong>分离，从而<strong>实现tomcat多实例的部署</strong>。</p></li></ul></li><li><p>环境变量设置</p><ul><li>新建变量名：<code>CATALINA_HOME</code>，变量值：<code>F:/DevLibs/Tomcat</code></li><li>不需要增加<code>CATALINA_BASE</code>，该变量在脚本中动态设置。</li><li>打开PATH，添加变量值：<code>%CATALINA_HOME%\lib;%CATALINA_HOME%\bin</code></li></ul></li></ol><h3 id="修改server-xml"><a href="#修改server-xml" class="headerlink" title="修改server.xml"></a>修改server.xml</h3><ol><li>修改官方网站（officals-website）web应用的server.xml配置（<strong>端口号8081</strong>）。<ul><li>将第22行的<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code> 修改为 <code>&lt;Server port=&quot;8015&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></li><li>将第69行的<code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</code> 修改为 <code>&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;</code></li><li>将第91行的<code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>修改为<code>&lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></li><li>将第123行的<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code>修改为<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt;</code></li></ul></li><li>修改后端（backend）web应用的server.xml配置（<strong>端口号8082</strong>）。<ul><li>将第22行的<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code> 修改为 <code>&lt;Server port=&quot;8025&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></li><li>将第69行的<code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</code> 修改为 <code>&lt;Connector port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot;</code></li><li>将第91行的<code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>修改为<code>&lt;Connector port=&quot;8029&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></li><li>将第123行的<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code>修改为<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt;</code></li></ul></li></ol><h3 id="修改启动和停止脚本"><a href="#修改启动和停止脚本" class="headerlink" title="修改启动和停止脚本"></a>修改启动和停止脚本</h3><ol><li>将初始tomcat的bin目录下的<code>startup.bat</code> 和<code>shutdown.bat</code> 这两个脚本分别拷贝到<code>backend</code> 和 <code>offical-website</code> 目录下</li><li><p>编辑<code>startup.bat</code>脚本，增加一行语句，用于设置<code>CATALINA_BASE</code>变量。（backend和offical-website需要同时修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">setlocal</div><div class="line"></div><div class="line">rem Guess CATALINA_HOME if not defined</div><div class="line">set &quot;CURRENT_DIR=%cd%&quot;</div><div class="line">## 在这里将CATALINA_BASE 设置为脚本所在目录</div><div class="line">set &quot;CATALINA_BASE=%cd%&quot; </div><div class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</div><div class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</div><div class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</div><div class="line">cd ..</div><div class="line">set &quot;CATALINA_HOME=%cd%&quot;</div><div class="line">cd &quot;%CURRENT_DIR%&quot;</div><div class="line">:gotHome</div></pre></td></tr></table></figure></li><li><p>编辑shutdown.bat脚本，增加一行语句，用于设置<code>CATALINA_BASE</code>变量。（backend和offical-website需要同时修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setlocal</div><div class="line"></div><div class="line">rem Guess CATALINA_HOME if not defined</div><div class="line">set &quot;CURRENT_DIR=%cd%&quot;</div><div class="line">## 在这里将CATALINA_BASE 设置为脚本所在目录</div><div class="line">set &quot;CATALINA_BASE=%cd%&quot;</div><div class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</div><div class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</div><div class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</div><div class="line">cd ..</div><div class="line">set &quot;CATALINA_HOME=%cd%&quot;</div><div class="line">cd &quot;%CURRENT_DIR%&quot;</div><div class="line">:gotHome</div></pre></td></tr></table></figure></li></ol><h2 id="启动tomcats"><a href="#启动tomcats" class="headerlink" title="启动tomcats"></a>启动tomcats</h2><ol><li>分别在backend和officals-website目录，用Dos执行startup.bat脚本。</li><li>在浏览器输入loalhost:8081和loalhost:8082就可以访问tomcat管理页面了。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://blog.jobbole.com/109347/" target="_blank" rel="external">Tomcat多实例单应用部署方案</a></li><li><a href="http://xafc2370.iteye.com/blog/1683187" target="_blank" rel="external">一个tomcat部署多个应用实例总结</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      本文主要介绍了如何在一个服务器中运行多个Tomcat实例，保证部署在单服务器中的多个项目不会相互影响。
    
    </summary>
    
      <category term="Tomcat" scheme="http://www.vibrancy.cn/categories/Tomcat/"/>
    
    
      <category term="tomcat" scheme="http://www.vibrancy.cn/tags/tomcat/"/>
    
  </entry>
  
</feed>
