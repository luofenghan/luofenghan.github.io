<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心之所至、意之使然</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.vibrancy.cn/"/>
  <updated>2017-04-30T23:08:03.147Z</updated>
  <id>http://www.vibrancy.cn/</id>
  
  <author>
    <name>落枫寒</name>
    <email>luofenghan_cwc@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android增量更新：服务器篇</title>
    <link href="http://www.vibrancy.cn/2017/04/30/Android%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/"/>
    <id>http://www.vibrancy.cn/2017/04/30/Android增量更新：服务器篇/</id>
    <published>2017-04-30T13:40:21.000Z</published>
    <updated>2017-04-30T23:08:03.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="增量更新的原理"><a href="#增量更新的原理" class="headerlink" title="增量更新的原理"></a>增量更新的原理</h2><p>其实增量升级的原理很简单，即首先将应用的旧版本Apk与新版本Apk做差分，得到更新的部分的补丁，例如旧版本的APK有5M，新版的有8M，更新的部分则可能只有3M左右(这里需要说明的是，得到的差分包大小并不是简单的相减，因为其实需要包含一些上下文相关的东西——有时候旧版本10M，新版本8M，得到的差分包可能有5M)，使用差分升级的好处显而易见，那么你不需要下载完整的8M文件，只需要下载更新部分就可以，而更新部分可能只有3、4M，可以很大程度上减少流量的损失。</p>
<p>在用户下载了差分包之后，需要在手机端将他们组合起来。可以参考的做法是先将手机端的旧版本软件(多半在/data/下)，复制到SD卡或者cache中，将它们和之前的差分patch进行组合，得到一个新版本的apk应用，如果不出意外的话，这个生成的apk和你之前做差分的apk是一致的。<br><a id="more"></a></p>
<h2 id="增量更新实现"><a href="#增量更新实现" class="headerlink" title="增量更新实现"></a>增量更新实现</h2><h3 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h3><p>使用开源的二进制比较工具<a href="http://www.daemonology.net/bsdiff/" target="_blank" rel="external">bsdiff</a></p>
<p><img src="http://i.imgur.com/RBOUfG0.png" alt=""></p>
<p>及其依赖的<a href="http://www.bzip.org/downloads.html" target="_blank" rel="external">bzip2</a></p>
<p><img src="http://i.imgur.com/n4nI8zB.png" alt="bzip2"></p>
<p>下载完后，得到这样的目录结构：</p>
<p><img src="http://i.imgur.com/sxndK1G.png" alt=""></p>
<p><img src="http://i.imgur.com/Hgxvn4W.png" alt=""></p>
<p>其中bsdiff.c用于在服务端生成差分包，bspatch.c用于在客户端把旧版本apk与服务端生成的差分包进行合成为新版本apk。</p>
<h3 id="实现的步骤"><a href="#实现的步骤" class="headerlink" title="实现的步骤"></a>实现的步骤</h3><ol>
<li>在服务端，生成新旧版本的差分包</li>
<li>在客户端，使用已安装的旧版apk与这个差分包，合成为一个新版apk。</li>
<li>校验新合成的客户端文件是否完成，签名时候和已安装客户端一致，如一致，提示用户安装;</li>
</ol>
<h2 id="服务端生成差分包"><a href="#服务端生成差分包" class="headerlink" title="服务端生成差分包"></a>服务端生成差分包</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>由于服务器的不同，因此我们需要将以上的c/c++文件，build输出为动态链接库，以供java调用，其中Window环境生成名为libApkPatchLibraryServer.dll文件，Unix/Linux环境生成名为libApkPatchLibraryServer.so，OSX下生成名为libApkPatchLibraryServer.dylib的文件。下面具体讲一下在Windows服务器上怎么生成libApkPatchLibraryServer.dll文件的</p>
<h3 id="生成dll动态链接库"><a href="#生成dll动态链接库" class="headerlink" title="生成dll动态链接库"></a>生成dll动态链接库</h3><ol>
<li><p>下载开源工具</p>
<p> 如果我们要生成dll动态链接库，那我们就不能用刚才下的bsdiff-4.3了（具体原因下面再说），我们需要在这里<a href="http://sites.inka.de/tesla/others.html#bsdiff" target="_blank" rel="external">bsdiff</a> 下载一个针对win32版本的bsdiff文件，下载页面如图所示：</p>
<p> <img src="http://i.imgur.com/BaJoEl0.png" alt=""></p>
<p> 下载得到的文件如图所示：</p>
<p> <img src="http://i.imgur.com/pTbSJ1G.png" alt=""></p>
<p> 里面已经包含了<code>bsdiff.cpp</code>，<code>bspatch.cpp</code>及其依赖的<code>bzlip</code>等文件。</p>
</li>
<li><p>改写bsdiff.cpp（生成差分包）</p>
<p> 首先，在MyEclispe中声明一个native方法，如图所示：</p>
<p> <img src="http://i.imgur.com/2kep1Su.png" alt=""></p>
<p> 接着，为了生成的方便，将该类及完整的所在包复制到桌面上，我们利用javac 和javap命令将该native方法生成c/c++中对应的.h头文件：</p>
<p> <img src="http://i.imgur.com/OytWPaJ.png" alt=""></p>
<p> <img src="http://i.imgur.com/4k1bWXg.png" alt=""></p>
<p> <img src="http://i.imgur.com/55agjAq.png" alt=""></p>
<p> 这时，我们可以看到在桌面上生成了一个<code>com_cwc_smartupdate_util_DiffUtil.h</code>的头文件。打开头文件，如下图所示：</p>
<p> <img src="http://i.imgur.com/H9elGXU.png" alt=""></p>
<p> 以上代码需要说明一下，首先函数名的格式遵循如下规则：<code>Java_包名_类名_方法名</code>。其中，<code>JNIEXPORT</code>、<code>JNICALL</code>、<code>JNIEnv</code>和<code>jobject</code>都是JNI标准中定义的类型或者宏。</p>
</li>
<li><p>实现JNI方法</p>
<p> 这里可以选用c或c++实现，我们这使用的是c++，因为在上文中下载win32版本的<code>bsdiff</code>中的<code>bsdiff.cpp</code>就是用c++实现的，接着我们打开该文件进行改写。（注意：我这以下的所有操作都是基于VS2013，因为涉及到很多c和h文件的引用，如果使用命令行的话，在连接阶段可能出现函数未定义的情况，为了简便本人直接使用了VS2013来生成dll文件）。</p>
<p> 首先，利用vs2013新建一个dll项目，将<code>bsdiff4.3-win32-src.zip</code>解压得到的文件导入该项目中，并将bsdiff.cpp重新命名为<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>，另外，这里还需要三个头文件，分别是<code>jni.h</code>、<code>jni_md.h</code>（在两个在ndk里面找，可以在该ndk根文件夹子下全文搜索一下）和刚才生成的<code>com_cwc_smartupdate_util_DiffUtil.h</code>，最终得到的目录结构如下：</p>
<p> <img src="http://i.imgur.com/gG7T8nm.png" alt=""></p>
<p> 接着我们打开<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>文件，进行我们的改写操作，首先，引入头文件：</p>
<p> <img src="http://i.imgur.com/V2AFD3j.png" alt=""><img src="http://i.imgur.com/uQiK24i.png" alt=""></p>
<p> 之后，把<code>typedef long pid_t</code>注释掉，并添加<code>ftello</code>和<code>fseeko</code>两个函数宏定义，如图所示：</p>
<p> <img src="http://i.imgur.com/NHRemD6.png" alt=""></p>
<p> 接着，我们来实现<code>com_cwc_smartupdate_util_DiffUtil.h</code>中的函数，代码如下：</p>
<p> <img src="http://i.imgur.com/G0Frtwr.png" alt=""></p>
<p> 这段代码意思是将传入的三个字符串（新旧版本的文件路径和生成的差分包路径）分别放进一个<code>char* 类型</code>的指针数组里面，然后调用appDiff函数，生成差分包。那这个appDiff如何实现呢，我们找到该文件下的main方法，将该main方法重命名为appDiff：</p>
<p> <img src="http://i.imgur.com/MckAKMJ.png" alt=""></p>
<p> <img src="http://i.imgur.com/oCMUkUw.png" alt=""></p>
<p> 接着，把该<code>appDiff函数</code>向下拖动，会看到这段代码，这段代码用于通过打开旧版本文件，将文件的数据读到名为old的内存当中，这段代码改写如下：</p>
<p> <img src="http://i.imgur.com/e9f694c.png" alt=""></p>
<p> 因为<code>lseek</code>，<code>open</code>等函数都是Linux里面的，如果在window下使用会出现打开文件失败的情况。改写的文件如下，其中stream是新定义的一个<code>FILE* stream</code>;文件类型指针：</p>
<p> <img src="http://i.imgur.com/eDPNUHG.png" alt=""></p>
<p> 通过这段代码可以将旧版本文件数据读取到<code>u_char* old</code>中。接着，我们改写读取新文件的这段代码，代码如下：</p>
<p> <img src="http://i.imgur.com/8INJLrO.png" alt=""></p>
<p> 改写成：</p>
<p> <img src="http://i.imgur.com/quzwfPh.png" alt=""></p>
<p> 到此为止，我们的所有操作就全部完成了，接下来我们生成dll文件，在生成的dll文件中也注意是32位的还是64位的，不然在java调用的时候会出现读取失败的情况。</p>
<h2 id="在服务端调用dll文件"><a href="#在服务端调用dll文件" class="headerlink" title="在服务端调用dll文件"></a>在服务端调用dll文件</h2></li>
</ol>
<p><img src="http://i.imgur.com/HSbsyVA.png" alt=""></p>
<p>其中，<code>DiffAppServer64</code>就是刚才生成的dll文件，由于<code>DiffAppServer64.dll</code>需要依赖其他的dll文件，我这需要依赖<code>msvcr100d</code>和<code>kernel32</code>，所以在这里也必须将两个文件导入才行。最后，这三个文件放置的位置如图所示：</p>
<p><img src="http://i.imgur.com/q7Sl981.png" alt=""></p>
<p>在tomcat根目录下的bin子目录下新建一个appdiff目录，然后把三个文件放到这里。当这些所有的操作完成之后，就可以在服务端生成差分包了。</p>
<h2 id="运行效果展示"><a href="#运行效果展示" class="headerlink" title="运行效果展示"></a>运行效果展示</h2><h3 id="apk文件上传页面面"><a href="#apk文件上传页面面" class="headerlink" title="apk文件上传页面面"></a>apk文件上传页面面</h3><p><img src="http://i.imgur.com/1PmCkic.png" alt=""></p>
<h3 id="旧版本文件上传"><a href="#旧版本文件上传" class="headerlink" title="旧版本文件上传"></a>旧版本文件上传</h3><p><img src="http://i.imgur.com/r0003FO.png" alt=""></p>
<h3 id="新版本文件上传"><a href="#新版本文件上传" class="headerlink" title="新版本文件上传"></a>新版本文件上传</h3><p><img src="http://i.imgur.com/3LUG2ic.png" alt=""></p>
<h3 id="当上传新版本后，服务端后台就自动开始生成差分包的工作了"><a href="#当上传新版本后，服务端后台就自动开始生成差分包的工作了" class="headerlink" title="当上传新版本后，服务端后台就自动开始生成差分包的工作了"></a>当上传新版本后，服务端后台就自动开始生成差分包的工作了</h3><p><img src="http://i.imgur.com/FeEghkb.png" alt=""></p>
<p><img src="http://i.imgur.com/sSoD3Wd.png" alt=""></p>
<p>那么又涉及到另外一个问题，由于比较生成差分包在底层进行，并且非常的耗时，大概需要1分多钟，那么如何显示进度，生成差分包的工作进行到哪一步了？这就需要利用jni调用java方法，将底层的信息传到java代码层。</p>
<h2 id="jni调用java方法，回传底层的进度信息"><a href="#jni调用java方法，回传底层的进度信息" class="headerlink" title="jni调用java方法，回传底层的进度信息"></a>jni调用java方法，回传底层的进度信息</h2><ol>
<li><p>在声明genDiff 这个native方法的的类中<code>java.cwc.smartupdate.util.DiffUtil</code>声明一个静态的方法：</p>
<p> <img src="http://i.imgur.com/EHppmhA.png" alt=""></p>
<p> 这个方法表示，在c底层进行调用该方法，传递整型state参数，通过对比不同的整型数据，找到底层对应的执行进度。</p>
</li>
<li><p>让我们返回到<code>com_cwc_smartupdate_util_DiffUtil.cpp</code>文件中，找到我们在上文中实现的本地方法对应的函数：</p>
<p> <img src="http://i.imgur.com/Llrwt4j.png" alt=""></p>
<p> 为了方便演示，在这个函数上面定义一个用于发布进度的函数：</p>
<p> <img src="http://i.imgur.com/KFULVhk.png" alt=""></p>
<p> 这段函数的意思就是通过反射来调用DiffUtil类内的静态方法publishProgress，然后在appDiff函数内部，就可以在关键的地方调用该函数用来发布当前执行任务的状态了，（注意定义的函数需要在该文件头部声明，不然出现找不到函数的错误提示），另外还有一点需要注意，publishProgress需要调用不止一次，因此不可能每次都通过反射来创建DiffUtil的类对象(创建一次就够了)，因此，我们需要将上面的函数整理为以下格式：</p>
<p> <img src="http://i.imgur.com/70bdDfk.png" alt=""></p>
</li>
<li><p>服务端的java代码层</p>
<p> 由于publishProgress传递的是整型数据，我们可以自定义一些整型常量来映射出对应的任务状态。还可以在该DiffUtil定义一个内部接口，这样其他类实现了该接口，就可以接收到底层返回的进度。</p>
<p> <img src="http://i.imgur.com/oOEXgk0.png" alt=""></p>
<p> <img src="http://i.imgur.com/ZhwlIHh.png" alt=""></p>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>到此为止，整个增量更新的服务端是实现就结束了，总结一下：</p>
<ul>
<li>我们首先在java中定义了一个本地native方法，通过javac和javap命令生成了对应的h头文件；</li>
<li>然后改写bsdiff.cpp文件，实现刚才生成的头文件中的函数，并针对windows服务器改写bsdiff.cpp的函数内部的细节；</li>
<li>最后进行将生成的dll文件放到了tomcat服务器中，利用System.loadLibrary函数加载dll文件，如果缺少依赖dll的话，就添加对应的dll文件；</li>
<li>最后为了实现进度的显示，我们又定义了publishProgress方法，并在底层实现了该函数，在java端的DiffUtil类中定义了一个接口，让其他实现该接口的类可以接收到底层发布的进度。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;增量更新的原理&quot;&gt;&lt;a href=&quot;#增量更新的原理&quot; class=&quot;headerlink&quot; title=&quot;增量更新的原理&quot;&gt;&lt;/a&gt;增量更新的原理&lt;/h2&gt;&lt;p&gt;其实增量升级的原理很简单，即首先将应用的旧版本Apk与新版本Apk做差分，得到更新的部分的补丁，例如旧版本的APK有5M，新版的有8M，更新的部分则可能只有3M左右(这里需要说明的是，得到的差分包大小并不是简单的相减，因为其实需要包含一些上下文相关的东西——有时候旧版本10M，新版本8M，得到的差分包可能有5M)，使用差分升级的好处显而易见，那么你不需要下载完整的8M文件，只需要下载更新部分就可以，而更新部分可能只有3、4M，可以很大程度上减少流量的损失。&lt;/p&gt;
&lt;p&gt;在用户下载了差分包之后，需要在手机端将他们组合起来。可以参考的做法是先将手机端的旧版本软件(多半在/data/下)，复制到SD卡或者cache中，将它们和之前的差分patch进行组合，得到一个新版本的apk应用，如果不出意外的话，这个生成的apk和你之前做差分的apk是一致的。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.vibrancy.cn/categories/Android/"/>
    
    
      <category term="增量更新" scheme="http://www.vibrancy.cn/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    
      <category term="android" scheme="http://www.vibrancy.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>到底什么时候该使用MQ</title>
    <link href="http://www.vibrancy.cn/2017/04/30/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8MQ/"/>
    <id>http://www.vibrancy.cn/2017/04/30/到底什么时候该使用MQ/</id>
    <published>2017-04-29T22:23:39.000Z</published>
    <updated>2017-04-30T23:08:29.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ的用途"><a href="#MQ的用途" class="headerlink" title="MQ的用途"></a>MQ的用途</h2><p>消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。</p>
<p>在互联网架构中，MQ是一种非常常见的上下游“<strong>逻辑解耦+物理解耦</strong>”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，逻辑上和物理上都不用依赖其他服务。<br><a id="more"></a></p>
<p><img src="http://op87q3xru.bkt.clouddn.com/message%20queue.png" alt="mq"></p>
<h2 id="不使用MQ的情况"><a href="#不使用MQ的情况" class="headerlink" title="不使用MQ的情况"></a>不使用MQ的情况</h2><p>MQ作为互联网分层架构中的解耦利器，那为什么不是所有通讯都使用MQ呢？因为，调用与被调用的关系，是无法被MQ取代的。<strong>调用方实时依赖执行结果的业务场景，请使用调用，而不是MQ</strong>。</p>
<h3 id="MQ的缺陷"><a href="#MQ的缺陷" class="headerlink" title="MQ的缺陷"></a>MQ的缺陷</h3><ul>
<li>系统更复杂，多了一个MQ组件；</li>
<li>消息传递路径更长，延时增加；</li>
<li>消息<strong>可靠性</strong>和<strong>重复性</strong>互为矛盾，消息不丢不重难以同时保证；</li>
<li>上游无法知道下游的执行结果，这一点是很致命的。</li>
</ul>
<h2 id="什么时候使用MQ"><a href="#什么时候使用MQ" class="headerlink" title="什么时候使用MQ"></a>什么时候使用MQ</h2><h3 id="场景一：数据驱动的任务依赖"><a href="#场景一：数据驱动的任务依赖" class="headerlink" title="场景一：数据驱动的任务依赖"></a>场景一：数据驱动的任务依赖</h3><ol>
<li><p>什么是任务依赖</p>
<p> 互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，比如：</p>
<ul>
<li>task3需要使用task2的输出作为输入；</li>
<li><p>task2需要使用task1的输出作为输入；</p>
<p>这样的话，tast1,task2,task3之间就有任务依赖关系，必须task1先执行，再task2执行，载task3执行。</p>
</li>
</ul>
</li>
<li><p>使用cron人工排执行时间表</p>
<ol>
<li>task1，0:00执行，经验执行时间为50分钟</li>
<li>task2，1:00执行（为task1预留10分钟buffer），经验执行时间也是50分钟</li>
<li>task3，2:00执行（为task2预留10分钟buffer）</li>
</ol>
</li>
<li><p>使用cron的缺点</p>
<ul>
<li>如果有一个任务<strong>执行时间超过了预留buffer的时间，将会得到错误的结果</strong>，因为后置任务不清楚前置任务是否执行成功，此时要手动重跑任务，还有可能要调整排班表。</li>
<li>总任务的<strong>执行时间很长</strong>，总是要预留很多buffer，如果前置任务提前完成，后置任务不会提前开始。</li>
<li>如果一个任务被多个任务依赖，这个任务将会称为<strong>关键路径</strong>，排班表很难体现依赖关系，容易出错。</li>
<li>如果有一个任务的执行时间要调整，将会有<strong>多个任务的执行时间要调整</strong></li>
</ul>
</li>
<li><p>采用MQ解耦方案</p>
<ol>
<li>task1准时开始，结束后发一个“task1 done”的消息</li>
<li>task2订阅“task1 done”的消息，收到消息后第一时间启动执行，结束后发一个“task2done”的消息。</li>
<li>task3同理</li>
</ol>
</li>
<li><p>采用MQ的优点</p>
<ul>
<li>不需要预留buffer，上游任务执行完，<strong>下游任务总会在第一时间被执行。</strong></li>
<li>依赖多个任务，被多个任务依赖都很好处理，<strong>只需要订阅相关消息</strong>即可</li>
<li>有任务执行时间变化，下游任务都<strong>不需要调整执行时间</strong>。</li>
</ul>
</li>
<li><p>MQ使用注意</p>
<p> MQ只用来传递上游任务<strong>执行完成的消息</strong>，并不用于传递真正的<strong>输入输出</strong>数据。</p>
</li>
</ol>
<h3 id="典型场景二：上游不关心执行结果"><a href="#典型场景二：上游不关心执行结果" class="headerlink" title="典型场景二：上游不关心执行结果"></a>典型场景二：上游不关心执行结果</h3><ol>
<li><p>58同城的很多下游需要关注“用户发布帖子”这个事件</p>
<p> 比如招聘用户发布帖子后，招聘业务要奖励58豆，房产用户发布帖子后，房产业务要送2个置顶，二手用户发布帖子后，二手业务要修改用户统计数据。</p>
</li>
<li><p>采用调用关系解决</p>
<p> 帖子发布服务执行完成之后，调用下游招聘业务、房产业务、二手业务，来完成消息的通知，但事实上，这个通知是否正常正确的执行，帖子发布服务根本不关注。</p>
</li>
<li><p>采用调用的缺陷</p>
<ul>
<li>帖子发布流程的执行时间增加了</li>
<li>下游服务宕机，可能导致帖子发布服务受影响，上下游逻辑+物理依赖严重。</li>
<li>每当增加一个需要知道“帖子发布成功”信息的下游，修改代码的是帖子发布服务，这一点是最恶心的，属于<strong>架构设计中典型的依赖倒转</strong>，谁用过谁痛谁知道。</li>
</ul>
</li>
<li><p>采用MQ解耦方案</p>
<ul>
<li>帖子发布成功后，向MQ发一个消息</li>
<li>哪个下游关注“帖子发布成功”的消息，主动去MQ订阅</li>
</ul>
</li>
<li><p>采用MQ的优点</p>
<ul>
<li>上游<strong>执行时间短</strong></li>
<li><strong>上下游逻辑+物理解耦</strong>，除了与MQ有物理连接，模块之间都不相互依赖</li>
<li><strong>新增一个下游消息关注方，上游不需要修改任何代码</strong>。</li>
</ul>
</li>
</ol>
<h3 id="典型场景三：上游关注执行结果，但执行时间很长"><a href="#典型场景三：上游关注执行结果，但执行时间很长" class="headerlink" title="典型场景三：上游关注执行结果，但执行时间很长"></a>典型场景三：上游关注执行结果，但执行时间很长</h3><ol>
<li><p>微信支付</p>
<p> 跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果，此时一般怎么玩呢？</p>
<p> <img src="http://op87q3xru.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%BB%93%E6%9E%9C%E9%80%9A%E7%9F%A5.png" alt="image"></p>
</li>
</ol>
<ol>
<li>采用“回调网关+MQ”方案来解耦：<ol>
<li>调用方直接跨公网调用微信接口</li>
<li>微信返回调用成功，此时并不代表返回成功</li>
<li>微信执行完成后，回调统一网关</li>
<li>网关将返回结果通知MQ</li>
<li>请求方收到结果通知</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么时候不使用MQ？"><a href="#什么时候不使用MQ？" class="headerlink" title="什么时候不使用MQ？"></a>什么时候不使用MQ？</h3><p>上游实时关注执行结果</p>
<h3 id="什么时候使用MQ？"><a href="#什么时候使用MQ？" class="headerlink" title="什么时候使用MQ？"></a>什么时候使用MQ？</h3><ol>
<li>数据驱动的任务依赖</li>
<li>上游不关心多下游执行结果</li>
<li>异步返回执行时间长</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MQ的用途&quot;&gt;&lt;a href=&quot;#MQ的用途&quot; class=&quot;headerlink&quot; title=&quot;MQ的用途&quot;&gt;&lt;/a&gt;MQ的用途&lt;/h2&gt;&lt;p&gt;消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。&lt;/p&gt;
&lt;p&gt;在互联网架构中，MQ是一种非常常见的上下游“&lt;strong&gt;逻辑解耦+物理解耦&lt;/strong&gt;”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，逻辑上和物理上都不用依赖其他服务。&lt;br&gt;
    
    </summary>
    
      <category term="架构师" scheme="http://www.vibrancy.cn/categories/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
    
      <category term="架构" scheme="http://www.vibrancy.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="消息队列" scheme="http://www.vibrancy.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat多实例单应用部署方案</title>
    <link href="http://www.vibrancy.cn/2017/04/29/Tomcat%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%8D%95%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>http://www.vibrancy.cn/2017/04/29/Tomcat多实例单应用部署方案/</id>
    <published>2017-04-29T02:20:53.000Z</published>
    <updated>2017-04-30T23:10:26.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat部署的场景分析"><a href="#Tomcat部署的场景分析" class="headerlink" title="Tomcat部署的场景分析"></a>Tomcat部署的场景分析</h2><h3 id="单实例单应用"><a href="#单实例单应用" class="headerlink" title="单实例单应用"></a>单实例单应用</h3><p>如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。<br><a id="more"></a></p>
<h3 id="单实例多应用"><a href="#单实例多应用" class="headerlink" title="单实例多应用"></a>单实例多应用</h3><p>是把多个应用程序的war包放在同一个tomcat的webapps目录，这样一来，关闭和启动tomcat会影响所有项目。</p>
<h3 id="多实例单应用"><a href="#多实例单应用" class="headerlink" title="多实例单应用"></a>多实例单应用</h3><p>各个tomcat都运行同一个应用程序，对应地需要修改不同的监听端口，这种方式通常会和apache httpd或者nginx整合使用，做一些负载均衡的处理。</p>
<h3 id="多实例多应用"><a href="#多实例多应用" class="headerlink" title="多实例多应用"></a>多实例多应用</h3><p>相当于第一种场景的复数形式，除了修改不同的监听端口，没有本质区别。</p>
<h2 id="Windows服务器下多实例单应用设置流程"><a href="#Windows服务器下多实例单应用设置流程" class="headerlink" title="Windows服务器下多实例单应用设置流程"></a>Windows服务器下多实例单应用设置流程</h2><h3 id="分离目录"><a href="#分离目录" class="headerlink" title="分离目录"></a>分离目录</h3><ol>
<li><p>刚解压出来的tomcat目录结构</p>
<ul>
<li>bin：主要存放脚本文件，例如比较常用的windows和linux系统中启动和关闭脚本</li>
<li>conf：主要存放配置文件，其中最重要的两个配置文件是server.xml和web.xml</li>
<li>lib：主要存放tomcat运行所依赖的包</li>
<li>logs：主要存放运行时产生的日志文件，例如catalina.{date}.log等</li>
<li>temp：存放tomcat运行时产生的临时文件，例如开启了hibernate缓存的应用程序，会在该目录下生成一些文件</li>
<li>webapps：部署web应用程序的默认目录</li>
<li>work：主要存放由JSP文件生成的servlet（java文件以及最终编译生成的class文件）</li>
</ul>
</li>
<li><p>将解压出来的tomcat文件拆分出的目录结构如下所示：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">F:/DevLibs/Tomcat</div><div class="line">├─applications</div><div class="line">│  ├─backend  # 主要部署后端模块代码</div><div class="line">│  │  │  shutdown.bat</div><div class="line">│  │  │  startup.bat</div><div class="line">│  │  ├─conf</div><div class="line">│  │  ├─logs</div><div class="line">│  │  ├─temp</div><div class="line">│  │  ├─webapps   </div><div class="line">│  │  └─work</div><div class="line">│  └─officals-website # 主要部署前端代码，如官方网站</div><div class="line">│     │  shutdown.bat</div><div class="line">│     │  startup.bat</div><div class="line">│     ├─conf</div><div class="line">│     ├─logs</div><div class="line">│     ├─temp</div><div class="line">│     ├─webapps</div><div class="line">│     └─work</div><div class="line">├─bin</div><div class="line">└─lib</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><ol>
<li><p>环境变量说明</p>
<ul>
<li>CATALINA_HOME：即指向<strong>Tomcat安装路径</strong>的系统变量</li>
<li><p>CATALINA_BASE：即指向<strong>活跃配置路径</strong>的系统变量</p>
<p>通过设置这两个变量，就可以将tomcat的<strong>安装目录和工作目录</strong>分离，从而<strong>实现tomcat多实例的部署</strong>。</p>
</li>
</ul>
</li>
<li><p>环境变量设置</p>
<ul>
<li>新建变量名：<code>CATALINA_HOME</code>，变量值：<code>F:/DevLibs/Tomcat</code></li>
<li>不需要增加<code>CATALINA_BASE</code>，该变量在脚本中动态设置。</li>
<li>打开PATH，添加变量值：<code>%CATALINA_HOME%\lib;%CATALINA_HOME%\bin</code></li>
</ul>
</li>
</ol>
<h3 id="修改server-xml"><a href="#修改server-xml" class="headerlink" title="修改server.xml"></a>修改server.xml</h3><ol>
<li>修改官方网站（officals-website）web应用的server.xml配置（<strong>端口号8081</strong>）。<ul>
<li>将第22行的<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code> 修改为 <code>&lt;Server port=&quot;8015&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></li>
<li>将第69行的<code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</code> 修改为 <code>&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;</code></li>
<li>将第91行的<code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>修改为<code>&lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></li>
<li>将第123行的<code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code>修改为<code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt;</code></li>
</ul>
</li>
<li>修改后端（backend）web应用的server.xml配置（<strong>端口号8082</strong>）。<ul>
<li>将第22行的<code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code> 修改为 <code>&lt;Server port=&quot;8025&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></li>
<li>将第69行的<code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</code> 修改为 <code>&lt;Connector port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot;</code></li>
<li>将第91行的<code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code>修改为<code>&lt;Connector port=&quot;8029&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></li>
<li>将第123行的<code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code>修改为<code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot;&gt;</code></li>
</ul>
</li>
</ol>
<h3 id="修改启动和停止脚本"><a href="#修改启动和停止脚本" class="headerlink" title="修改启动和停止脚本"></a>修改启动和停止脚本</h3><ol>
<li>将初始tomcat的bin目录下的<code>startup.bat</code> 和<code>shutdown.bat</code> 这两个脚本分别拷贝到<code>backend</code> 和 <code>offical-website</code> 目录下</li>
<li><p>编辑<code>startup.bat</code>脚本，增加一行语句，用于设置<code>CATALINA_BASE</code>变量。（backend和offical-website需要同时修改）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">setlocal</div><div class="line"></div><div class="line">rem Guess CATALINA_HOME if not defined</div><div class="line">set &quot;CURRENT_DIR=%cd%&quot;</div><div class="line">## 在这里将CATALINA_BASE 设置为脚本所在目录</div><div class="line">set &quot;CATALINA_BASE=%cd%&quot; </div><div class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</div><div class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</div><div class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</div><div class="line">cd ..</div><div class="line">set &quot;CATALINA_HOME=%cd%&quot;</div><div class="line">cd &quot;%CURRENT_DIR%&quot;</div><div class="line">:gotHome</div></pre></td></tr></table></figure>
</li>
<li><p>编辑shutdown.bat脚本，增加一行语句，用于设置<code>CATALINA_BASE</code>变量。（backend和offical-website需要同时修改）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">setlocal</div><div class="line"></div><div class="line">rem Guess CATALINA_HOME if not defined</div><div class="line">set &quot;CURRENT_DIR=%cd%&quot;</div><div class="line">## 在这里将CATALINA_BASE 设置为脚本所在目录</div><div class="line">set &quot;CATALINA_BASE=%cd%&quot;</div><div class="line">if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome</div><div class="line">set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;</div><div class="line">if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome</div><div class="line">cd ..</div><div class="line">set &quot;CATALINA_HOME=%cd%&quot;</div><div class="line">cd &quot;%CURRENT_DIR%&quot;</div><div class="line">:gotHome</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="启动tomcats"><a href="#启动tomcats" class="headerlink" title="启动tomcats"></a>启动tomcats</h2><ol>
<li>分别在backend和officals-website目录，用Dos执行startup.bat脚本。</li>
<li>在浏览器输入loalhost:8081和loalhost:8082就可以访问tomcat管理页面了。</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://blog.jobbole.com/109347/" target="_blank" rel="external">Tomcat多实例单应用部署方案</a></li>
<li><a href="http://xafc2370.iteye.com/blog/1683187" target="_blank" rel="external">一个tomcat部署多个应用实例总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Tomcat部署的场景分析&quot;&gt;&lt;a href=&quot;#Tomcat部署的场景分析&quot; class=&quot;headerlink&quot; title=&quot;Tomcat部署的场景分析&quot;&gt;&lt;/a&gt;Tomcat部署的场景分析&lt;/h2&gt;&lt;h3 id=&quot;单实例单应用&quot;&gt;&lt;a href=&quot;#单实例单应用&quot; class=&quot;headerlink&quot; title=&quot;单实例单应用&quot;&gt;&lt;/a&gt;单实例单应用&lt;/h3&gt;&lt;p&gt;如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。&lt;br&gt;
    
    </summary>
    
      <category term="Tomcat" scheme="http://www.vibrancy.cn/categories/Tomcat/"/>
    
    
      <category term="tomcat" scheme="http://www.vibrancy.cn/tags/tomcat/"/>
    
  </entry>
  
</feed>
