<!-- build time:Wed Jul 05 2017 13:13:27 GMT+0800 (马来西亚半岛标准时间) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="hadoop,rpc,动态代理,NIO,"><link rel="alternate" href="/atom.xml" title="唯有日月不灭" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="主要介绍了Hadoop RPC的实现，包括远程过程调用的基础知识、Java动态代理、NIO和Hadoop RPC的具体实现。"><meta name="keywords" content="hadoop,rpc,动态代理,NIO"><meta property="og:type" content="article"><meta property="og:title" content="Hadoop中的远程过程调用"><meta property="og:url" content="http://www.vibrancy.cn/repository/hadoop-rpc.html"><meta property="og:site_name" content="唯有日月不灭"><meta property="og:description" content="主要介绍了Hadoop RPC的实现，包括远程过程调用的基础知识、Java动态代理、NIO和Hadoop RPC的具体实现。"><meta property="og:image" content="http://image18-c.poco.cn/mypoco/myphoto/20170411/09/18510550620170411095052030_640.jpg?544x397_130"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/Dynamic%20Proxy%20invoke%20process.svg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/buffer%20%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/%E5%9F%BA%E4%BA%8EHadoop%20RPC%E7%9A%84%E5%9B%BE%E4%B9%A6%E6%9F%A5%E8%AF%A2.svg"><meta property="og:updated_time" content="2017-06-19T07:31:44.562Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hadoop中的远程过程调用"><meta name="twitter:description" content="主要介绍了Hadoop RPC的实现，包括远程过程调用的基础知识、Java动态代理、NIO和Hadoop RPC的具体实现。"><meta name="twitter:image" content="http://image18-c.poco.cn/mypoco/myphoto/20170411/09/18510550620170411095052030_640.jpg?544x397_130"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.vibrancy.cn/repository/hadoop-rpc.html"><title>Hadoop中的远程过程调用 | 唯有日月不灭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">唯有日月不灭</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://www.vibrancy.cn/repository/hadoop-rpc.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="落枫寒"><meta itemprop="description" content=""><meta itemprop="image" content="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="唯有日月不灭"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Hadoop中的远程过程调用</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T13:03:50+08:00">2017-06-19 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hadoop/" itemprop="url" rel="index"><span itemprop="name">hadoop</span></a></span></span><div class="post-description">主要介绍了Hadoop RPC的实现，包括远程过程调用的基础知识、Java动态代理、NIO和Hadoop RPC的具体实现。</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="远程过程调用RPC"><a href="#远程过程调用RPC" class="headerlink" title="远程过程调用RPC"></a>远程过程调用RPC</h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC就是允许程序<strong>调用位于其它机器上的过程</strong>（或者同一台机器的不同进程），主要功能目标是让构建分布式计算（应用）更容易，使两个进程间能够基于<strong>传统过程调用中的控制流模型</strong>来进行交互，在提供强大的远程调用能力时不损失<strong>本地调用的语义简洁性</strong>。</p><h3 id="RPC的具体执行流程"><a href="#RPC的具体执行流程" class="headerlink" title="RPC的具体执行流程"></a>RPC的具体执行流程</h3><p><img src="http://image18-c.poco.cn/mypoco/myphoto/20170411/09/18510550620170411095052030_640.jpg?544x397_130" alt="image"></p><ol><li>当客户端调用<code>remoteF()</code>后，<strong>客户端存根</strong>只是简单的将参数打包成一个消息，并请求将此消息发送到服务器，然后<strong>客户端存根</strong>通过调用<code>receive()</code>方法，随即阻塞自己，直到收到响应消息。</li><li><strong>服务器骨架</strong>先调用<code>receive()</code>，然后阻塞，等待消息输入。</li><li><strong>服务器骨架</strong>收到消息后，先将<strong>参数</strong>从消息中提取出来，然后以常规的方式调用服务器上的相应方法<code>removeF()</code>。</li><li>服务器本地的<code>removeF()</code>执行完后，将结果返回到<strong>服务器骨架</strong>，由骨架打包成消息返回给<strong>客户端存根</strong>，接着<strong>服务器骨架</strong>再次调用<code>receive()</code>，等待下一条消息。</li><li><strong>客户端存根</strong>收到消息后，<strong>检查消息并解包返回参数</strong>，通过return将结果传递到客户端。</li><li>客户端调用者在<code>remoteF()</code>结束后重新获得控制权，它唯一知道的就是已经获得了结果数据，但并不清楚操作是本地方法进行的还是远程完成的。</li></ol><h3 id="RPC的优点"><a href="#RPC的优点" class="headerlink" title="RPC的优点"></a>RPC的优点</h3><p>客户端可以简单地忽略不需要关心的内容，只需要调用一个普通的、本地的过程，就可以访问远程服务，不需要<strong>调用send或receive这些底层操作</strong>，所有的消息传递细节都<strong>隐藏在RPC的库过程</strong>中，就如同传统库中隐藏了执行实际系统调用细节一样。</p><h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p>动态代理的用途是在不改变已有代码结构的情况下增强或控制对象的行为，也叫作<strong>横切面编程</strong>。</p><h3 id="Proxy类介绍"><a href="#Proxy类介绍" class="headerlink" title="Proxy类介绍"></a>Proxy类介绍</h3><p><code>java.lang.reflect.Proxy</code> 类提供用于创建<strong>动态代理类</strong>和实例的静态方法，她还是由这些方法创建的所有动态代理类的<strong>超类</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) <span class="keyword">throws</span> IllegalArgumentException&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;&#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li><code>getProxyClass()</code>方法用于获得<strong>代理类</strong>的<code>java.lang.Class</code>对象，该代理类将定义在指定的<strong>类加载器中</strong>，并实现参数<code>interfaces</code>所指定的所有接口。获得的代理类都包含一个构造函数，用于初始化<code>java.lang.reflect.InvocationHandler</code>实例；</li><li><code>newProxyInstance()</code>方法用于返回一个或多个指定接口的代理类实例，在该接口方法上的调用，将指派到调用处理器（InvocationHandler）上；</li><li><code>isProxyClass()</code>方法判断某个Class对象是否为代理类；</li><li><code>getInvocationHandler()</code>方法用于获取代理实例对应的调用处理器。</li></ol><h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * <span class="doctag">@param</span> proxy 代理对象本身</div><div class="line">    * <span class="doctag">@param</span> method 用户调用的代理对象上的方法</div><div class="line">    * <span class="doctag">@param</span> args 传递给该方法的参数</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>InvocationHandler实例也叫<strong>调用句柄实例</strong>，它是一个接口，只有一个<code>invoke()</code>方法，当用户调用<code>newProxyInstance()</code>返回的代理对象上的方法时，代理对象将方法调用转发给调用句柄实例，即调用<code>InvocationHandler.invoke()</code>方法。</p><h3 id="典型的动态代理创建对象过程"><a href="#典型的动态代理创建对象过程" class="headerlink" title="典型的动态代理创建对象过程"></a>典型的动态代理创建对象过程</h3><ol><li><p>通过实现InvocationHandler接口创建自己的调用处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>通过为Proxy类指定ClassLoader对象和一组interfaces创建<strong>动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; subjectProxyClass = getProxyClass0(classLoader, interfaces);</div></pre></td></tr></table></figure></li><li><p>通过反射机制获取<strong>动态代理类</strong>的构造函数，其参数类型是<strong>调用处理器接口类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Constructor&lt;?&gt; cons = subjectProxyClass.getConstructor(<span class="keyword">new</span> Class[]&#123;InvocationHandler.class&#125;);</div></pre></td></tr></table></figure></li><li><p>通过构造函数创建<strong>代理类实例</strong>，此时需将调用处理器对象作为参数被传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Subject subject = (Subject)constructor.newInstance(<span class="keyword">new</span> Object[] &#123;subjectProxyHandler&#125;);</div></pre></td></tr></table></figure></li></ol><h3 id="动态代理调用过程时序图"><a href="#动态代理调用过程时序图" class="headerlink" title="动态代理调用过程时序图"></a>动态代理调用过程时序图</h3><p><img src="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/Dynamic%20Proxy%20invoke%20process.svg" alt=""></p><h3 id="典型动态代理简单实例"><a href="#典型动态代理简单实例" class="headerlink" title="典型动态代理简单实例"></a>典型动态代理简单实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"call doSomething()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject subject;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxyHandler</span><span class="params">(Subject subject)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subject = subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//在转调具体目标对象之前，可以执行一些功能处理</span></div><div class="line">        System.out.println(<span class="string">"前置通知"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//转调具体目标对象的方法</span></div><div class="line">        Object result = method.invoke(subject, args);</div><div class="line"></div><div class="line">        <span class="comment">//在转调具体目标对象之后，可以执行一些功能处理</span></div><div class="line">        System.out.println(<span class="string">"后置通知"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectDynamicProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createProxyClassFile</span><span class="params">()</span> </span>&#123;</div><div class="line">        String name = <span class="string">"ProxySubject"</span>;</div><div class="line">        <span class="keyword">byte</span>[] data = ProxyGenerator.generateProxyClass(name, <span class="keyword">new</span> Class[]&#123;Subject.class&#125;);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(name + <span class="string">".class"</span>);</div><div class="line">            out.write(data);</div><div class="line">            out.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxyInstance</span><span class="params">(Subject subject)</span> </span>&#123;</div><div class="line">        ClassLoader classLoader = subject.getClass().getClassLoader();</div><div class="line"></div><div class="line">        Class&lt;?&gt;[] interfaces = subject.getClass().getInterfaces();</div><div class="line"></div><div class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> SubjectProxyHandler(subject);</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Subject proxySubject = SubjectDynamicProxy.getProxyInstance(<span class="keyword">new</span> RealSubject());</div><div class="line">        proxySubject.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>非阻塞是NIO实现的重要功能之一，为了实现非阻塞，NIO引入了选择器（Selector）和通道（Channel）的概念。通道表示实体，如设备、文件等程序组件的开放连接。</p><h3 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h3><p>NIO中一个主要的特性是<code>java.nio.Bufer</code>，缓冲区（Buffer）提供了一个比流抽象的、更高效的和可预测的I/O。Buffer代表了一个有限容量的容器——本质是一个数组，通道Channel使用Buffer实例来传递数据。</p><p>流和通道的区别在于流是基于字节的，而通道是基于块的。</p><ol><li><p>Buffer索引介绍</p><ul><li><strong>capacity</strong>：缓冲区元素的总数，通过capacity()获取，该总数不可修改；</li><li><strong>position</strong>：缓冲区的位置，是下一个要读取或写入元素的索引，该位置可以由position()方法和position(int)方法获得。</li><li><strong>limit</strong>：缓冲区的限制，即第一个不应该读取或写入的元素的索引，limit()方法用于获取元素限制索引，limit(int)方法用于设置缓冲区的限制。</li><li><p><strong>mark</strong>：缓冲区的位置设置标记，通过mark()方法设置一个位置，然后利用reset()方法将position重置为mark()标记的位置。</p><p>以上四个索引遵循的不变式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</div></pre></td></tr></table></figure></li></ul></li><li><p>Buffer主要方法介绍</p><ul><li><strong>allocate()</strong>：用于直接创建缓冲区(position=0, limit=capacity)。</li><li><strong>wrap()</strong>：用于在某个字节数组上创建缓冲区，对该数组的修改，都将改变缓冲区的数据(position=offset, limit = offset+length)。</li><li><strong>get()/put()</strong>：返回基于目前缓冲区position位置的当前值，从下一个位置读取或存放数据，并为执行position++操作。</li><li><strong>get(int)/put(int)</strong>：基于绝对位置的，必须提供写入/读出的位置，该方式的读写操作不改变position的值。</li><li><strong>clear()</strong>：用于清空缓冲区，将position设为0，limit设置为capacity，但是buffer数组中的数据还存在。</li><li><strong>flip()</strong>：将<strong>写模式</strong>转为<strong>读模式</strong>，该方法将limit设置为position后，将position设为0。后续的<code>get()/write()</code>方法将从缓冲区的第一个元素开始传出数据，直到位于limit位置。</li><li><strong>compact()</strong>：将<strong>读模式</strong>转为<strong>写模式</strong>，当缓冲区还有未写出的数据时，为读入数据准备空间。在write()方法调用后和添加新数据的read()方法前调用compact()方法，将未写出的“剩余”数据移动到缓冲区前面，为后面的read()方法提供空间。</li><li><strong>rewind()</strong>：用于需要多次读取缓冲区里的数据，将position设为0，但不改变limit的值。</li><li>使用缓冲区读取数据的时候，必须先确认缓冲区的position、limit处于正确的位置。</li><li><p>clear()，flip()，rewind()，compact()方法对索引position、limit的影响：</p><p><img src="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/buffer%20%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="image"></p></li></ul></li></ol><h3 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h3><p>Channel实例代表一个和设备的连接，通过它可以进行输入输出操作。</p><p>Channel对于TCP协议来说，有ServerSocketChannel和SocketChannel，针对其他设备还有其他类型的Channel，如文件设备FileChannel。</p><ol><li><p>创建通道</p><p>ServerSocketChannel 和 SocketChannel 通过工厂方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><p>SocketChannel创建后，通过connect()连接到远程机器，通过close()关闭连接。</p></li><li><p>建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlocking</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><p>非阻塞式SocketChannel和阻塞时Channel有些不同，如非阻塞的SocketChannel的connect()方法会立即返回，用户必须通过isConnected()判断连接是否已经建立，或者通过finishConnect()方法在非阻塞套接字上<strong>阻塞等待</strong>连接成功；</p><p>非阻塞的read()，在Socket上没有数据的时候，立即返回（0），不会等待。</p><p>非阻塞的accept()，如果没有等待的连接，将返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></li><li><p>读写数据</p><p>SocketChannel 在读写数据的时候，使用Buffer作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dests)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span></span>;</div></pre></td></tr></table></figure></li></ol><pre><code>ServerSocketChannel提供了accept()方法、close()等方法，accept()方法返回一个SocketChannel对象。ServerSocketChannel不提供bind()方法，绑定socket到某端口需要使用底层的bind，即`serverChannel.socket().bind(port)`
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> ServerSocket <span class="title">socket</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
</code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>在任何时刻，服务器只有少量的请求需要处理，这就需要一种方法阻塞等待，直到至少一个Channel可以进行IO操作，并指出是哪个通道。NIO的选择器就是为这个功能设计的，一个Selector实例可以同时检查一组通道的IO状态。</p><ol><li><p>选择器的使用方法</p><ul><li><p>通过静态工厂方法创建Selector实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></li><li><p>通过Channel的注册方法，将Selector实例注册到想要监控的Channel上；</p></li><li>调用选择器的<code>select()</code>方法，该方法会阻塞等待，直到有一个或多个通道准备好IO操作或者超时。<code>select()</code>方法会返回可操作IO的数量。在一个单独的线程中，就可以检查多个通道是否可以进行IO操作，不需要为每一个通道准备一个线程。</li></ul></li><li><p>选择器与通道事件的关联</p><p>选择器与通道的关联是多对多的关联，关联信息保存在<code>java.nio.channels.SelectionKey</code>实例中。选择器注册标记SelectionKey维护了一个通道上感兴趣的事件类型信息，包括4种类型：</p><ul><li>OP_READ(通道上有数据可读)</li><li>OP_WRITE(通道已经可写)</li><li>OP_CONNECT(通道连接已建立)</li><li><p>OP_ACCEPT(通道上有连接请求)</p><p>以上类型都保存在SelectionKey实例中，通过interestOps()方法获取和设置这些标志位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interestOps</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;</div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Hadoop的远程过程调用"><a href="#Hadoop的远程过程调用" class="headerlink" title="Hadoop的远程过程调用"></a>Hadoop的远程过程调用</h2><p>Hadoop自己实现了一条独有的节点间通信机制，理由是和Hadoop使用Writabl形式的序列化机制有关，有效的IPC（Inter-Process Communication）对于Hadoop来书至关重要，Hadoop需要精确控制进程间通信中比如连接、超时、缓存等通信细节。</p><h3 id="基于Hadoop-RPC的简易图书查询"><a href="#基于Hadoop-RPC的简易图书查询" class="headerlink" title="基于Hadoop RPC的简易图书查询"></a>基于Hadoop RPC的简易图书查询</h3><ol><li><p>UML类图</p><p><img src="http://op87q3xru.bkt.clouddn.com/hadoop/image/rpc/%E5%9F%BA%E4%BA%8EHadoop%20RPC%E7%9A%84%E5%9B%BE%E4%B9%A6%E6%9F%A5%E8%AF%A2.svg" alt=""></p><ul><li><strong>Library</strong>：定义了IPC服务器对外提供的功能，使用Book作为queryBook()方法的返回值。</li><li><strong>LibraryImpl</strong>：实现了接口中定义的功能，BookQueryServer利用LibraryImpl的实例，构造并运行IPC服务器。</li><li><strong>BookQueryClient</strong>：作为客户端，使用IPC访问服务器提供的 Library 查询书的功能。</li></ul></li><li><p>代码实现</p><ul><li><p>定义一个IPC协议接口 Library</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Library</span> <span class="keyword">extends</span> <span class="title">VersionedProtocol</span> </span>&#123;</div><div class="line">    <span class="function">Book <span class="title">queryBook</span><span class="params">(String bookName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Hadoop远程调用中，Hadoop IPC接口必须继承自<code>org.apache.hadoop.ipc.VersionedProtocol</code>，该接口输入参数是<strong>协议接口的类名</strong>和<strong>客户端的版本号</strong>，返回了服务器的协议接口版本号，用于验证客户端与服务器的版本是否一致。</p></li><li><p>IPC协议接口 Library实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LibraryImpl</span> <span class="keyword">implements</span> <span class="title">Library</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">queryBook</span><span class="params">(String bookName)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(bookName, <span class="string">"落枫寒"</span>, <span class="number">23</span>);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getProtocolVersion</span><span class="params">(String protocol, <span class="keyword">long</span> clientVersion)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            System.out.println(protocol);</div><div class="line">            <span class="keyword">return</span> BookQueryServer.IPC_VER;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ```  </div><div class="line"></div><div class="line">* 定义IPC接口的返回值类型，该返回值类型必须是Writable类型</div><div class="line">    ```java</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> Text author;</div><div class="line">        <span class="keyword">private</span> Text bookName;</div><div class="line">        <span class="keyword">private</span> IntWritable price;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</div><div class="line">            author = <span class="keyword">new</span> Text();</div><div class="line">            bookName = <span class="keyword">new</span> Text();</div><div class="line">            price = <span class="keyword">new</span> IntWritable();</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String bookName, String author, <span class="keyword">int</span> price)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.author = <span class="keyword">new</span> Text(author);</div><div class="line">            <span class="keyword">this</span>.bookName = <span class="keyword">new</span> Text(bookName);</div><div class="line">            <span class="keyword">this</span>.price = <span class="keyword">new</span> IntWritable(price);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(Text author)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.author = author;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> Text <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> bookName;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">            Book book = (Book) o;</div><div class="line">    </div><div class="line">            <span class="keyword">if</span> (author != <span class="keyword">null</span> ? !author.equals(book.author) : book.author != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (bookName != <span class="keyword">null</span> ? !bookName.equals(book.bookName) : book.bookName != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> price != <span class="keyword">null</span> ? price.equals(book.price) : book.price == <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> result = author != <span class="keyword">null</span> ? author.hashCode() : <span class="number">0</span>;</div><div class="line">            result = <span class="number">31</span> * result + (bookName != <span class="keyword">null</span> ? bookName.hashCode() : <span class="number">0</span>);</div><div class="line">            result = <span class="number">31</span> * result + (price != <span class="keyword">null</span> ? price.hashCode() : <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</div><div class="line">                    <span class="string">"author="</span> + author +</div><div class="line">                    <span class="string">", bookName="</span> + bookName +</div><div class="line">                    <span class="string">", price="</span> + price +</div><div class="line">                    <span class="string">'&#125;'</span>;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            author.write(out);</div><div class="line">            bookName.write(out);</div><div class="line">            price.write(out);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            author.readFields(in);</div><div class="line">            bookName.readFields(in);</div><div class="line">            price.readFields(in);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ```    </div><div class="line"></div><div class="line">* 构建IPC服务器</div><div class="line"></div><div class="line">    ```java</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookQueryServer</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUERY_PORT = <span class="number">33121</span>;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> IPC_VER = <span class="number">5473L</span>;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Library library = <span class="keyword">new</span> LibraryImpl();</div><div class="line">    </div><div class="line">                Server server = RPC.getServer(library, <span class="string">"0.0.0.0"</span>, QUERY_PORT, <span class="keyword">new</span> Configuration());</div><div class="line">                server.start();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul></li></ol><pre><code>    * 通过RPC静态方法getServer()，通过传入IPC接口的实例，监听地址、端口和配置类，就可以建立服务器。
    * &quot;0.0.0.0&quot;表示在所有的地址上监听。    

* 访问IPC服务器的客户端代码
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookQueryClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, BookQueryServer.QUERY_PORT);</div><div class="line">        Library query = (Library) RPC.getProxy(Library.class, BookQueryServer.IPC_VER, address, <span class="keyword">new</span> Configuration());</div><div class="line"></div><div class="line">        Book book = query.queryBook(<span class="string">"Hadoop权威指南"</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"查到的书为："</span> + book.toString());</div><div class="line"></div><div class="line">        RPC.stopProxy(query);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

    通过调用RPC.getProxy()获得一个IPC客户端接口的代理实例，通过这个实例对象进行远程过程调用，调用会转发到服务器执行。
</code></pre><h3 id="Hadoop-IPC的代码结构"><a href="#Hadoop-IPC的代码结构" class="headerlink" title="Hadoop IPC的代码结构"></a>Hadoop IPC的代码结构</h3><p>org.apache.hadoop.ipc包下的类介绍:</p><ol><li><strong>RemoteException</strong>：远程异常，应用于IPC客户端，表示远程过程调用中的错误。</li><li><strong>Status</strong>：是一个枚举类，定义了远程过程调用的返回结果状态，包括SUCCESS、ERROR和FATAL三种情况。</li><li><strong>VersionedProtocol</strong>：Hadoop IPC的远程接口都扩展自VersionedProtocol。</li><li><strong>ConnectionHeader</strong>：IPC客户端与服务器建立连接时发送的<strong>消息头</strong>。</li><li><strong>Client</strong>：是对IPC客户的抽象，它包含的内部类可分为，IPC连接相关的（Client.Connection和Client.ConnectionId），远程调用相关的（Client.Call、Client.ParallecCall）等。</li><li><strong>Server</strong>：实现了一个IPC服务器的抽象，它包含的内部类可分为，IPC连接相关的（Server.Connection和Server.Call），而对远程调用Call处理是由Listener、Handler和Responder配合完成，他们都继承自Thread，在各自的线程中完成。</li><li><strong>RPC</strong>：在Client和Server的基础上实现了Hadoop IPC，其功能主要分为两个部分：<ul><li>与客户端相关的功能包括RPC.ClientCache、RPC.Invocker和RPC.Invocation，其中RPC.Invocker继承自InvocationHandler。</li><li>与服务器相关的内部类只有RPC.Server，它是IPC服务器抽象类（Server）的一个子类。</li></ul></li></ol></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/hadoop/" rel="tag"># hadoop</a> <a href="/tags/rpc/" rel="tag"># rpc</a> <a href="/tags/动态代理/" rel="tag"># 动态代理</a> <a href="/tags/NIO/" rel="tag"># NIO</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/repository/multi-thread-knowledge-self-concurrent-structured-concurrent-application.html" rel="next" title="多线程知识自查表——结构化并发应用程序"><i class="fa fa-chevron-left"></i> 多线程知识自查表——结构化并发应用程序</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/repository/jdk8-abstractqueuedsynchronizer.html" rel="prev" title="AbstractQueuedSynchronizer源码分析">AbstractQueuedSynchronizer源码分析 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png" alt="落枫寒"><p class="site-author-name" itemprop="name">落枫寒</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">12</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">22</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#远程过程调用RPC"><span class="nav-number">1.</span> <span class="nav-text">远程过程调用RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是RPC"><span class="nav-number">1.1.</span> <span class="nav-text">什么是RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC的具体执行流程"><span class="nav-number">1.2.</span> <span class="nav-text">RPC的具体执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC的优点"><span class="nav-number">1.3.</span> <span class="nav-text">RPC的优点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java动态代理"><span class="nav-number">2.</span> <span class="nav-text">Java动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy类介绍"><span class="nav-number">2.1.</span> <span class="nav-text">Proxy类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InvocationHandler"><span class="nav-number">2.2.</span> <span class="nav-text">InvocationHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型的动态代理创建对象过程"><span class="nav-number">2.3.</span> <span class="nav-text">典型的动态代理创建对象过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理调用过程时序图"><span class="nav-number">2.4.</span> <span class="nav-text">动态代理调用过程时序图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型动态代理简单实例"><span class="nav-number">2.5.</span> <span class="nav-text">典型动态代理简单实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-NIO"><span class="nav-number">3.</span> <span class="nav-text">Java NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区Buffer"><span class="nav-number">3.1.</span> <span class="nav-text">缓冲区Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道Channel"><span class="nav-number">3.2.</span> <span class="nav-text">通道Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择器"><span class="nav-number">3.3.</span> <span class="nav-text">选择器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hadoop的远程过程调用"><span class="nav-number">4.</span> <span class="nav-text">Hadoop的远程过程调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于Hadoop-RPC的简易图书查询"><span class="nav-number">4.1.</span> <span class="nav-text">基于Hadoop RPC的简易图书查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hadoop-IPC的代码结构"><span class="nav-number">4.2.</span> <span class="nav-text">Hadoop IPC的代码结构</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="author" itemprop="copyrightHolder"><a href="http://www.vibrancy.cn">落枫寒</a>&nbsp;版权所有</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html><!-- rebuild by neat -->