<!-- build time:Sat Jun 17 2017 20:44:15 GMT+0800 (马来西亚半岛标准时间) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="java,多线程,"><link rel="alternate" href="/atom.xml" title="唯有日月不灭" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="Java多线程基础知识部分，介绍了并发性和线程安全性的基本概念，以及构建线程安全类的方法和类库提供的并发构建块的原理及使用"><meta name="keywords" content="java,多线程"><meta property="og:type" content="article"><meta property="og:title" content="多线程知识自查表——并发基础理论"><meta property="og:url" content="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-basic-theory.html"><meta property="og:site_name" content="唯有日月不灭"><meta property="og:description" content="Java多线程基础知识部分，介绍了并发性和线程安全性的基本概念，以及构建线程安全类的方法和类库提供的并发构建块的原理及使用"><meta property="og:updated_time" content="2017-06-13T11:25:32.605Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="多线程知识自查表——并发基础理论"><meta name="twitter:description" content="Java多线程基础知识部分，介绍了并发性和线程安全性的基本概念，以及构建线程安全类的方法和类库提供的并发构建块的原理及使用"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-basic-theory.html"><title>多线程知识自查表——并发基础理论 | 唯有日月不灭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">唯有日月不灭</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-basic-theory.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="落枫寒"><meta itemprop="description" content=""><meta itemprop="image" content="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="唯有日月不灭"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">多线程知识自查表——并发基础理论</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-13T16:44:55+08:00">2017-06-13 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span></span><div class="post-description">Java多线程基础知识部分，介绍了并发性和线程安全性的基本概念，以及构建线程安全类的方法和类库提供的并发构建块的原理及使用</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="什么是对象的状态"><a href="#什么是对象的状态" class="headerlink" title="什么是对象的状态"></a>什么是对象的状态</h2><p>对象的状态是指存储在<strong>实例</strong>或<strong>静态域</strong>中的数据。</p><ul><li>如果对象中所有的域都是<strong>基本类型的变量</strong>，那么这些域将构成对象的全部状态；</li><li>如果对象中的域<strong>引用了其他的对象</strong>，那么该对象的状态将包含被引用对象的域。例如，LinkedList对象的状态包括该链表中所有节点对象的状态。</li></ul><p>一个对象是否线程安全的，取决于它是否被多个线程访问。当有多个线程访问某个<strong>状态变量</strong>并且其中有一个线程执行写入操作时，那么必须采用<strong>同步机制</strong>来协同这些线程对变量的访问。</p><h2 id="对象的哪些域不属于对象状态的一部分"><a href="#对象的哪些域不属于对象状态的一部分" class="headerlink" title="对象的哪些域不属于对象状态的一部分"></a>对象的哪些域不属于对象状态的一部分</h2><p>如果以某个对象为根节点构造一张对象图，那么该<strong>对象状态</strong>将是对象图中的所有对象包含的域的<strong>一个子集</strong>。也就是说，在定义哪些变量将构成对象的状态时，<strong>只考虑对象拥有的数据</strong>。所有权意味着控制权，然而，<strong>如果发布了某个可变对象的引用，那么就不再拥有独占的控制权</strong>，最多是“<strong>共享控制权</strong>”。对于从构造函数中传递进来的对象，类通常并不拥有这些对象。</p><p><strong>容器类</strong>通常表现出一种“所有权分离”的形式，其中容器类拥有自身的状态，客户代码则拥有容器中各个对象的状态。</p><h2 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h2><p>当多个线程访问某个类时，这个类<strong>始终</strong>都能表现出<strong>正确的行为</strong>，那么就称这个类是线程安全的。</p><p><strong>无状态对象一定是线程安全的</strong>。因为它既<strong>不包含任何域</strong>，又不包含任何对<strong>其他类中的域的引用</strong>。</p><p>方法中的临时变量一定是线程安全的，因为计算过程中的临时状态仅存在于线程栈上的局部变量表中，并且只能由正在执行的线程访问。</p><h2 id="线程安全核心是什么"><a href="#线程安全核心是什么" class="headerlink" title="线程安全核心是什么"></a>线程安全核心是什么</h2><p>线程安全核心在于要对<strong>状态访问操作</strong>进行管理，其中的状态主要包括以下两种状态：</p><ol><li><strong>共享的</strong>（Shared）：变量可以由多个线程同时访问；</li><li><strong>可变的</strong>（Mutable）：变量的值在其生命周期内可以发生变化。</li></ol><h2 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h2><p>例如，在一个计数器程序中，定义一个int类型的实例变量用于统计某个方法的访问次数，该方法每调用一次，就执行<code>i++</code>操作，但该操作并不是线程安全的。因为看上去<code>i++</code>是一个非常紧凑的语法，但是该操作<strong>并不是原子的</strong>。实际上，它包括了三个独立的操作：读取i的值，将值+1，然后将计算结果写入i。也就是说，这是一个<strong>读取——修改——写入</strong>的操作序列，其<strong>结果状态依赖于之前的状态</strong>。</p><p>所以，一个操作的原子性是指该操作是不可分割的，其他线程只能在修改操作完成之前或之后读取和修改状态，而不能在修改状态的过程中。</p><h2 id="什么是竞态条件"><a href="#什么是竞态条件" class="headerlink" title="什么是竞态条件"></a>什么是竞态条件</h2><p>在并发编程中，当某个计算取决于<strong>多线程的交替执行时序</strong>时，那么就会发生<strong>竞态条件</strong>（Race Condition）。多数情况下，竞态条件不一定会发生错误，还需要某种<strong>不恰当的执行时序</strong>。</p><p>竞态条件的常见情况</p><ol><li><strong>延迟初始化</strong></li><li><strong>基于对象之前的状态来定义对象状态的转换</strong></li></ol><p>解决竞态条件的方法就是需要包含一组以原子方式执行的操作。可以使用<code>java.util.concurrent.atomic</code>包中的一些原子变量类，用于实现在数值和对象引用上的原子状态转换。或者使用锁将保护的代码路径以<strong>串行方式</strong>来访问，使复合操作成为原子操作。</p><h2 id="Java提供了哪些同步机制"><a href="#Java提供了哪些同步机制" class="headerlink" title="Java提供了哪些同步机制"></a>Java提供了哪些同步机制</h2><p>主要的同步机制是关键字<code>synchronized</code>，它提供了一种独占的加锁方式。另外，还包括<code>volatile</code>类型的变量，<strong>显式锁</strong>以及<strong>原子变量</strong>。</p><h2 id="什么是synchronized"><a href="#什么是synchronized" class="headerlink" title="什么是synchronized"></a>什么是synchronized</h2><p>Java提供了一种内置锁来支持原子性：<strong>同步代码块</strong>。同步代码块包括两个部分，一个作为<strong>锁的对象引用</strong>，一个作为这个锁<strong>保护的代码块</strong>。</p><p>以<code>synchronized</code>来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的<strong>对象</strong>，静态的<code>synchronized</code>方法以Class对象作为锁。</p><p>Java内置锁相当于一种互斥体，意味着最多只有一个线程能够持有这种锁，其他线程必须等待或阻塞，直到持有这个锁的线程释放锁。</p><p>如果某个线程视图已经获得某个对象的锁，那么持有锁的过程中，也可以访问该对象的其他<code>synchronized</code>来修饰的方法，这个称作锁的<strong>可重入</strong>。<strong>重入</strong>意味着获取锁的操作的粒度是<strong>线程</strong>，而不是<strong>调用</strong>。假设没有可重入的锁，那么就会发生死锁。因此，重入避免了这种死锁的发生。</p><p>另外，仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调多线程对某个变量的访问，那么在访问这个变量的<strong>所有位置都需要使用同步</strong>，而且该同步锁必须是<strong>同一把锁</strong>。</p><p>如果不加区别的将每个方法都加上锁，这可能会导致<strong>活跃性问题</strong>或<strong>性能问题</strong>。如果该加锁的方法是一个耗时操作，那么其他所有的线程都必须等待。当执行时间较长的计算或者可能无法快速完成的操作时，一定不要持有锁。</p><p>因此，可以缩小同步代码块的范围，做到既保证并发性，同时又维护线程安全性。不过，要确保同步代码块不要太小，并且不要将本应是原子的操作拆分到多个同步代码块中。尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去。</p><h2 id="什么是volatile关键字"><a href="#什么是volatile关键字" class="headerlink" title="什么是volatile关键字"></a>什么是volatile关键字</h2><ol><li><p>用途</p><p>volatile修饰的变量可用来确保<strong>该变量的更新操作</strong>会通知到其他线程。访问volatile变量的时候不会执行加锁操作，也就不会线程阻塞。因此，volatile变量是一种比sychronized关键字更轻量级的同步机制。从<strong>内存可见性</strong>的角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</p></li><li><p>应用场景</p><p>volatile变量通常用作于某个<strong>操作完成、发生中断或者状态的标志</strong>。</p></li><li><p>使用条件</p><ul><li>对变量的写入操作不依赖当前的值（避免出现竞态条件），或者能够确保只有单个线程更新变量的值；</li><li>该变量不会与其他状态变量一起纳入不变性条件中；</li><li>在访问变量时不需要加锁。</li></ul></li><li><p>与Synchronized的区别</p><p><strong>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性</strong>。因为volatile的语义不足以确保<strong>递增操作</strong>的原子性，除非能够保证只有一个线程对变量执行写操作。</p></li></ol><h2 id="什么是对象的发布"><a href="#什么是对象的发布" class="headerlink" title="什么是对象的发布"></a>什么是对象的发布</h2><p><strong>发布</strong>（Publish）一个对象是指使对象能够在<strong>当前作用域之外</strong>的代码中使用。例如，将一个指向对象的引用保存到其他代码可以访问的地方；或者将引用传递到其他类的方法中。</p><h2 id="什么是对象的逃逸"><a href="#什么是对象的逃逸" class="headerlink" title="什么是对象的逃逸"></a>什么是对象的逃逸</h2><p>逃逸是指当发布一个对象时，在该对象的<strong>非私有域中引用的所有对象</strong>同样会被发布。某个对象逃逸之后，必须假设有某个类或线程可能会误用该对象。</p><p>另一种特殊的逃逸是指<strong>this引用逃逸</strong>，是指<strong>对象还没有构造完成，它的this引用就会被发布出去</strong>。这会危及到线程安全，因为其他线程可以通过这个逸出的引用访问到<strong>初始化了一半</strong>的对象。其结果就是，某些线程看到该对象的状态是<strong>没初始化完的状态</strong>，而另外一些线程看到的却是已经初始化完的状态，这种不一致性是不确定的，程序也会产生一些无法预知的并发错误。</p><p>this引用逃逸逃逸发生要满足两个条件:</p><ol><li>在构造函数中创建内部类；</li><li>在构造函数中就把这个内部类给发布出去了。</li></ol><p>因此，要防止this引用逸出的方法就是<strong>避免让这两个条件同时出现</strong>。</p><h2 id="什么是线程封闭"><a href="#什么是线程封闭" class="headerlink" title="什么是线程封闭"></a>什么是线程封闭</h2><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。<strong>将某个对象封闭在线程中</strong>，将会自动实现线程安全性，即使被封闭的对象本身不是线程安全的，这种技术被称为<strong>线程封闭</strong>。</p><blockquote><p>线程封闭技术的一个常见应用是JDBC的Connection对象。JDBC规范并不要求Connection对象是安全的。在典型的服务器应用程序中，线程从连接池获得一个Connection对象，并且用该对象来处理请求，使用完对象后再将对象返还给连接池。由于大多数请求都是由单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池<strong>不会再将它分配给其他线程</strong>。因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。</p></blockquote><h2 id="线程封闭有哪些实现"><a href="#线程封闭有哪些实现" class="headerlink" title="线程封闭有哪些实现"></a>线程封闭有哪些实现</h2><ol><li><p><strong>栈封闭</strong></p><p>在栈封闭中，只能通过局部变量才能访问对象，局部变量的特性就是封闭在执行线程中，他们位于执行线程的栈中，其他线程无法访问这个栈。</p><p>另外，在维持对象引用的栈封闭性时，需要保证被引用的对象不会逸出。</p></li><li><p><strong>ThreadLocal</strong></p><p>ThreadLocal类能够使线程的<strong>某个值</strong>与<strong>保存该值的线程对象</strong>关联起来。ThreadLocal提供了get和set等方法，这些方法使每个使用该变量的线程都存有一个独立的副本，因此<strong>get总是返回由当前执行线程在调用set设置的最新值</strong>。</p><p>当某个线程初次调用<code>ThreadLocal.get</code>方法时，就会调用<code>initialValue</code>来获取初始值。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = </div><div class="line">            ThreadLocal.withInitial(() -&gt; DriverManager.getConnecton(DB_URL));</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> connectionHolder.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果此时需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象，可以维持线程安全性，从而<strong>避免了</strong>对可变的<strong>单实例变量</strong>或<strong>全局变量</strong>进行共享。</p><p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望在每次执行时都重新分配该临时对象，就可以使用该技术。</p></li></ol><h2 id="什么是不可变性"><a href="#什么是不可变性" class="headerlink" title="什么是不可变性"></a>什么是不可变性</h2><p>首先不可变对象一定是<strong>线程安全</strong>的。其次，不可变对象需要满足以下条件：</p><ul><li>对象创建后其状态<strong>不能被修改</strong>；</li><li>对象的所有域都是<strong>final类型</strong>；</li><li>对象是<strong>正确创建</strong>的（对象创建期间，this引用没有逸出）。</li></ul><h2 id="final的特点"><a href="#final的特点" class="headerlink" title="final的特点"></a>final的特点</h2><p>用于构造不可变对象，final类型的域是不能被修改的。它会保证不受限制的访问不可变对象，并在共享这些对象是无需同步。</p><p>在编程中，除非需要某个域是可变的，否则应该将其声明为final域；</p><p>当访问和更新多个相关变量时出现竞争条件问题时，可以通过将这些变量全部封装在一个不可变对象中来消除竞争。如果是一个可变对象，那么就<strong>必须使用锁来确保原子性</strong>。如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程会修改对象的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> BigInteger[] service(BigInteger num) &#123;</div><div class="line">        BigInteger[] lastFactors = cache.getFactors(num);</div><div class="line">        <span class="keyword">if</span> (lastFactors == <span class="keyword">null</span>) &#123;</div><div class="line">            lastFactors = factor(num);</div><div class="line">            cache = <span class="keyword">new</span> OneValueCache(num, lastFactors);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lastFactors;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger lastNumber, BigInteger[] lastFactors)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.lastNumber = lastNumber;</div><div class="line">            <span class="keyword">this</span>.lastFactors = Arrays.copyOf(lastFactors, lastFactors.length);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</div><div class="line">            <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何去安全发布一个对象"><a href="#如何去安全发布一个对象" class="headerlink" title="如何去安全发布一个对象"></a>如何去安全发布一个对象</h2><ol><li><p>对象的发布需求取决于它的可变性</p><ul><li>不可变对象可以通过任意机制来发布；</li><li>事实不可变的对象必须通过安全方式发布；</li><li>可变对象必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来。</li></ul></li><li><p>要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布：</p><ul><li>在<strong>静态初始化函数</strong>中初始化一个对象引用；</li><li>将对象的引用保存到<strong>volatile类型</strong>的域或者AtomicReference对象中；</li><li>将对象的引用保存到某个正确构造对象的<strong>final类型域</strong>中；</li><li>将对象的引用保存到一个由<strong>锁保护的域</strong>中。</li></ul></li><li><p>在并发程序中<strong>使用</strong>和<strong>共享</strong>对象时，可以使用一些使用的策略</p><ul><li><strong>线程封闭</strong>：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由该线程修改；</li><li><strong>只读共享</strong>：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括<strong>不可变对象</strong>和<strong>事实不可变对象</strong></li><li><strong>线程安全共享</strong>：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li><li><strong>保护对象</strong>：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li></ul></li></ol><h2 id="什么是不变性条件和后验条件，以及他们的用途"><a href="#什么是不变性条件和后验条件，以及他们的用途" class="headerlink" title="什么是不变性条件和后验条件，以及他们的用途"></a>什么是不变性条件和后验条件，以及他们的用途</h2><ol><li><p>不变性条件</p><p>用于判断状态是有效还是无效的，不变式表达了对状态的约束，这些状态应该符合这个约束的值的组合。</p></li><li><p>后验条件</p><p>用来判断状态迁移是否有效，规定了调用方法后必须为真的条件。</p></li><li><p>用途</p><p>类的<strong>不变性条件</strong>和<strong>后验条件</strong>约束了对象上有哪些状态和状态转换是<strong>有效的</strong>。如果不了解对象的<strong>不变性条件和后验条件</strong>，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于<strong>原子性</strong>和<strong>封装性</strong>。</p></li></ol><h2 id="什么是同步策略"><a href="#什么是同步策略" class="headerlink" title="什么是同步策略"></a>什么是同步策略</h2><p>同步策略（Synchronization Policy）定义了如何在不违背对象<strong>不变性条件</strong>或<strong>后验条件</strong>的情况下，对状态的访问操作进行协同。同时，同步策略还规定了如何将<strong>不可变性</strong>、<strong>线程封闭</strong>与<strong>加锁机制</strong>等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。</p><h2 id="什么是依赖状态的操作"><a href="#什么是依赖状态的操作" class="headerlink" title="什么是依赖状态的操作"></a>什么是依赖状态的操作</h2><p>在某些对象的方法中包含了一些<strong>基于状态的先验条件</strong>。例如，不能从空队列中删除一个元素，在删除一个元素之前，必须保证队列处于<strong>非空状态</strong>。因此，如果某个操作包含基于状态的先验条件，那么这个操作就称为<strong>依赖状态的操作</strong>。</p><p>在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由其他线程的执行而变为真，在并发程序中要一直等到先验条件成立在执行该操作。要想实现某个等待先验条件为真时才执行的操作，一种更为简单的方法就是通过现有类库（<strong>阻塞队列</strong>[BlockingQueue]）或者<strong>信号量</strong>来实现依赖状态的行为。</p><h2 id="如何设计线程安全的类"><a href="#如何设计线程安全的类" class="headerlink" title="如何设计线程安全的类"></a>如何设计线程安全的类</h2><p>在设计线程安全的类中，需要包含以下三个基本要素：</p><ol><li>找出<strong>构成</strong>对象状态的所有变量；</li><li>找出<strong>约束</strong>对象状态的不变性条件；</li><li>建立对象状态的并发访问管理策略。</li></ol><p><strong>委托</strong>是创建线程安全类的一个最有效的策略，只需让现有的线程安全类管理所有的状态即可。</p><h2 id="如何以线程安全的方式访问非线程安全对象"><a href="#如何以线程安全的方式访问非线程安全对象" class="headerlink" title="如何以线程安全的方式访问非线程安全对象"></a>如何以线程安全的方式访问非线程安全对象</h2><p>可以使用<strong>实例封闭机制</strong>（Instance Confinement），当对象被封闭到另一个对象中时，能够访问被封装对象的所有<strong>代码路径都是已知</strong>的。通过将<strong>封闭机制</strong>与<strong>合适的加锁策略</strong>结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p><p>实例封闭是构建线程安全的一个最简单的方式，简化了线程安全类的实现过程。还使得在<strong>锁策略上的选择</strong>拥有了更多的灵活性，使得不同的状态变量可以由不同的锁策略来保护。</p><p>Java平台类库中，由很多实例封闭的示例，有些类的唯一用途就是将非线程安全的类转换为线程安全的类。例如，包装器工厂方法（Collections.synchronizedList及同族的方法），使得这些非线程安全的类可以安全地用于多线程环境。这些工厂方法利用装饰器模式，使用一个同步的包装器对象包装容器；包装器将相关接口的每个方法实现为同步方法，并将请求转发到下层的容器对象上。只要包装器对象占有着对下层容器唯一的可触及的引用（底层容器限制于包装器内），包装器对象就是线程安全的。</p><h2 id="使用私有的锁对象而不是内置锁的好处"><a href="#使用私有的锁对象而不是内置锁的好处" class="headerlink" title="使用私有的锁对象而不是内置锁的好处"></a>使用私有的锁对象而不是内置锁的好处</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="comment">//修改变量的状态</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>私有的锁可以将被封装起来，使客户端代码无法得到锁；</li><li>但客户端代码可以通过<strong>公有方法来访问锁</strong>，以便正确的参与到它的同步策略中。</li><li>实现更加细粒度的加锁策略来提高可伸缩性。</li></ul><h2 id="如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？"><a href="#如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？" class="headerlink" title="如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？"></a>如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？</h2><p>如果一个类是由多个<strong>独立</strong>且<strong>线程安全的状态变量</strong>组成，并且在所有的操作中都<strong>不包含无效状态转换</strong>，那么可以将线程安全性委托给底层的状态变量，不需要在封装类中再增加一个额外的安全层。</p><p>类似于volatile变量的规则：仅当一个变量参与到包含其他状态变量的不变性条件时，才可以声明为volatile类型。</p><p>例如，在NumberRange使用了两个AtomicInteger来管理状态，并且含有一个约束条件，即第一个数值要小于第二个数值。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger lower = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger upper = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i &gt; upper.get()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">        lower.set(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i &lt; lower.get()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">        upper.set(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInRange</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>然而，NumberRange并不是线程安全的，如果一个线程调用setLower(5)，另一个线程调用setUpper(4)，那么在一些<strong>错误的执行时序</strong>中，这两个调用将会通过检查，并都能执行成功，但结果状态是一个无效的状态。</p><p>因为没有维持对下界和上界进行约束的不变性条件。setLower和setUpper都是“先检查后执行”的操作，但他们<strong>没有使用足够的加锁机制来保证这些操作的原子性</strong>。虽然AtomicInteger是线程安全的，但经过组合得到的类却不是，由于<strong>状态变量lower和upper不是彼此独立的</strong>，因此NumberRange不能将线程安全性委托给它的线程安全状态变量。因此，NumberRange必须通过<strong>加锁机制</strong>来维护不变性条件以确保线程安全性，此外，还必须<strong>避免发布</strong>lower和upper，从而防止客户端代码破坏其不变性条件。</p><h2 id="当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？"><a href="#当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？" class="headerlink" title="当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？"></a>当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？</h2><p>如果一个状态变量是<strong>线程安全</strong>的，并且<strong>没有任何不变性条件</strong>来约束它的值，在变量的操作上也<strong>不存在任何不允许的状态转换</strong>，那么就可以安全的发布这个变量。</p><ol><li><p>线程安全且可变的Point类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafePoint</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafePoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span>[] get() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>安全发布底层状态的车辆追踪器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishingVehicleTracker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, SafePoint&gt; locations;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublishingVehicleTracker</span><span class="params">(ConcurrentHashMap&lt;String, SafePoint&gt; locations)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.locations = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(locations);</div><div class="line">        <span class="keyword">this</span>.unmodifiableMap = Collections.unmodifiableMap(locations);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, SafePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unmodifiableMap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SafePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> locations.get(id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (locations.replace(id, <span class="keyword">new</span> SafePoint(x, y)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="谈谈对ConcurrentHashMap的了解"><a href="#谈谈对ConcurrentHashMap的了解" class="headerlink" title="谈谈对ConcurrentHashMap的了解"></a>谈谈对ConcurrentHashMap的了解</h2><p>ConcurrentHashMap也是一个基于<strong>散列</strong>的Map，但他使用了一个完全不同的<strong>加锁策略</strong>来提供更高的<strong>并发性</strong>和<strong>伸缩性</strong>。ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种<strong>粒度更细的加锁机制</strong>来实现更大程度的共享，这种机制称为<strong>分段锁</strong>（Lock Striping）。在这种机制中，任意数量的读取线程可以并发的访问Map，执行<strong>读取操作</strong>的线程和执行<strong>写入操作</strong>的线程可以并发地访问Map。ConcurrentHashMap带来的结果就是，在并发访问环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。</p><p>ConcurrentHashMap提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。ConcurrentHashMap返回的迭代器具有<strong>弱一致性</strong>，而并非<strong>及时失败</strong>。弱一致性可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器被构造后将修改操作反映给容器。</p><p>ConcurrentHashMap尽管有这些改进，但仍有一些需要权衡的因素，对于一些需要在<strong>整个Map上进行计算</strong>的方法，例如<strong>size和isEmpty</strong>，这些方法的语义被略微减弱以反映整个容器的并发性。由于size返回的结果在计算时可能已经过期，但他实际上只是一个估计值，因此允许size返回<strong>一个近似值而不是一个精确值</strong>。但是，事实上size和isEmpty这样的方法在并发过程中的用处很小，因为他们的返回值总是不断变化。因此，这些操作的需求被弱化，以换取对其他更重要操作的性能优化。</p><p>ConcurrentHashMap不能被加锁来执行独占的访问，因此无法在客户端加锁来创建新的原子操作。一些常见的复合操作，例如<strong>若没有则添加</strong>、<strong>若相等则移除</strong>、<strong>若相等则替换</strong>，都已实现为原子操作并且在ConcurrentMap接口中声明。如果你需要在现有的同步Map中添加这样的功能，那么就是用<strong>ConcurrentMap接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(K key, V value)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V newValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="谈谈对CopyOnWriteArrayList的了解"><a href="#谈谈对CopyOnWriteArrayList的了解" class="headerlink" title="谈谈对CopyOnWriteArrayList的了解"></a>谈谈对CopyOnWriteArrayList的了解</h2><ol><li><p>基本原理</p><p>CopyOnWrite容器即<strong>写时复制</strong>的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><p>不过在<code>CopyOnWriteArrayList</code>中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p><p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p></li><li><p>应用场景</p><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p></li><li><p>使用注意</p><ul><li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li><li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</li></ul></li><li><p>CopyOnWrite的缺点</p><ul><li>内存占用问题：有可能造成频繁的Yong GC和Full GC</li><li>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li></ul></li></ol><h2 id="基于阻塞队列生产者和消费者模式"><a href="#基于阻塞队列生产者和消费者模式" class="headerlink" title="基于阻塞队列生产者和消费者模式"></a>基于阻塞队列生产者和消费者模式</h2><ol><li><p>什么是生产者——消费者模式</p><p><strong>生产者——消费者</strong>模式将“<strong>找出需要完成的工作</strong>”与“<strong>执行工作</strong>”这两个过程分离开来，并把工作项放入一个“<strong>待完成</strong>”列表中以便在随后处理，而不是找出后立即处理。生产者和消费者模式简化了开发过程，因为它消除了生产者类和消费者类之间的代码依赖性，此外，该模式还将生产数据的过程和使用数据的过程解耦开来以简化工作负载的管理。</p></li><li><p>什么是阻塞队列</p><p>阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法将阻塞直到有空间可用；如果队列为空，那么take方法将会阻塞直到有元素可用。</p></li><li><p>阻塞队列在生产者——消费者模式的运用</p><p>如果生产者生成工作的速率比消费者处理工作的速率快，那么工作项会在队列中累计起来，并最终消耗内存。同样，put方法的阻塞特性极大的简化了生产者的编码。如果使用<strong>有界队列</strong>，那么当队列充满时，生产者将阻塞并且不能继续生成工作，而消费者就有时间赶上工作处理进度。因此，有界队列是一种强大的资源管理工具：<strong>能够抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮</strong>。</p><p>阻塞队列同样提供一个offer方法，如果数据项不能被添加到队列中，那么将返回一个失败状态。这样你就能够创建更多灵活性的策略来处理负荷过载的情况。例如减轻负重，将多余的工作项序列化并写入磁盘，减少生产者线程数量，或通过某种方式抑制生产者线程。</p></li><li><p>阻塞队列的具体实现以及应用</p><p>在类库中包含了BlockingQueue的多种实现，其中LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，二者分别于LinkedList和ArrayList类似，但比同步List拥有更好的并发性。</p><p><strong>PriorityBlockingQueue</strong>是一个按优先级排序的队列，如果希望按照某种顺序而不是FIFO来处理元素时，该队列非常有用。</p><p><strong>SynchronousQueue</strong>不会为队列中的元素维护存储空间，它会维护一组线程。当任务到达的时候，会直接交付工作给某一个线程去执行，从而降低了将数据从生产者移动到消费者的延迟。这就好比，将文件直接交给同事，还是将文件放到他的邮箱并希望他能尽快拿到文件。SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备参与到交付过程中。仅当有足够的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p></li></ol><h2 id="什么是双端队列和工作密取"><a href="#什么是双端队列和工作密取" class="headerlink" title="什么是双端队列和工作密取"></a>什么是双端队列和工作密取</h2><p>Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。</p><p>在生产者——消费者设计中，所有消费者有一个共享的工作队列，而在工作密取设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者各自的双端<strong>队列末尾</strong>秘密地获取工作。</p><p>密取工作模式比传统的生产者——消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。大多数时候，只在访问自己的双端队列，从而极大的减少了竞争。</p><p>工作密取非常适用于既是消费者也是生产者的问题——当执行某个工作可能导致更多的工作。例如，在网页爬虫程序处理一个页面时，通常会发现有更多的页面需要处理。当一个工作线程找到新的任务单元时，它将会放到自己队列的末尾。当双端队列为空时，它会在另一个线程的队列队尾查找新的任务，从而确保每个线程都保持忙碌状态。</p><h2 id="同步工具类用途"><a href="#同步工具类用途" class="headerlink" title="同步工具类用途"></a>同步工具类用途</h2><p>同步工具类可以是任何一个对象，只要它可以<strong>根据其自身的状态来协调线程的控制流</strong>。阻塞队列可以作为同步工具类，其他类型的同步工具还包括信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch）。</p><p>所有的同步工具类都有一些<strong>特定的结构化属性</strong>：封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待。</p><h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><ol><li><p>什么是闭锁</p><p>闭锁是一种同步工具类，可以延迟线程的工作进度直到其到达终止状态。</p></li><li><p>闭锁的作用</p><p>相当于一扇门：在闭锁达到结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当达到结束状态时，这扇门会打开并允许所有线程通过。当闭锁达到结束状态之后，将不会再改变状态，因此这扇门将永远保持打开状态。总而言之，闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。</p></li><li><p>CountDownLatch</p><p>CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的时间都已经发生。如果计数器值非零，那么await会一直阻塞直到计数器为零，或者等待线程中断，或者等待超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</div><div class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    startGate.await();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        task.run();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        endGate.countDown();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        startGate.countDown();</div><div class="line">        endGate.await();</div><div class="line">        <span class="keyword">long</span> end = System.nanoTime();</div><div class="line">        <span class="keyword">return</span> end - start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用于测试n个线程并发执行某个任务是需要的时间，如果在创建线程后立即启动他们，那么先启动的线程会领先后启动的线程，并且活跃线程数量会随着时间的推移而增加或减少，竞争程度也在不断发生变化。</p><p>启动门将使得主线程能够<strong>同时释放所有的工作线程</strong>，而结束门则使主线程能够等待<strong>最后一个线程执行完成</strong>，而不是顺序等待每个线程执行完成。</p></li></ol><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask也可以用作闭锁，表示一种抽象的可生成结果的计算。FutureTask表示的计算是通过Callable来实现，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：<strong>等待运行、正在运行和运行完成</strong>。当FutureTask进入完成状态之后，它会永远停止在这个状态。</p><p>Future.get的行为取决于任务的状态，如果任务已经完成，那么可以立即返回结果，否则将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。FutureTask将计算结果从<strong>执行计算的线程传递到获取这个结果的线程</strong>，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。</p><p>Callable表示的任务可抛出受检查的或未受检查的异常，并且任何代码都可能抛出一个Error。无论任务代码抛出什么异常，都会封装到一个ExecutionException中，并在Future.get中被重新抛出。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p><p>Semaphore中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。在执行操作时候可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，acquire将阻塞直到有许可。release方法将返回一个许可给信号量。</p><p>计算信号量的一种简化形式是<strong>二值信号量</strong>，即初始值为1的Semaphore。二值信号量可以用作互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个许可，谁就拥有了互斥锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;(bound));</div><div class="line">        <span class="keyword">this</span>.sem = <span class="keyword">new</span> Semaphore(bound);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sem.acquire();</div><div class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wasAdded = set.add(o);</div><div class="line">            <span class="keyword">return</span> wasAdded;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</div><div class="line">                sem.release();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T o)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</div><div class="line">        <span class="keyword">if</span> (wasRemoved) &#123;</div><div class="line">            sem.release();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wasRemoved;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>栅栏（Barrier）类似于闭锁，他能阻塞一组线程直到某个事件发生。</p><p><strong>栅栏与闭锁的关键区别</strong>在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议，例如几个家庭决定要在某个地方集合：“所有人6:00在麦当劳碰头，到了以后要等其他人，之后在讨论下一步要做的事情”。</p><p>CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集，他在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列互相独立的子问题。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到<strong>所有线程都到达栅栏位置</strong>。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有的线程将释放，而栅栏将被重置以便下次使用。</p><h2 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, V&gt; func;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer</span><span class="params">(Function&lt;A, V&gt; func)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.func = func;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">apply</span><span class="params">(A arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Future&lt;V&gt; f = cache.get(arg);</div><div class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">                FutureTask&lt;V&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;V&gt;(() -&gt; func.apply(arg));</div><div class="line">                f = cache.putIfAbsent(arg, futureTask);</div><div class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">                    f = futureTask;</div><div class="line">                    futureTask.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> f.get();</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                cache.remove(arg, f);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="comment">//other </span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"># java</a> <a href="/tags/多线程/" rel="tag"># 多线程</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/repository/classic-sort.html" rel="next" title="8大经典排序算法总结"><i class="fa fa-chevron-left"></i> 8大经典排序算法总结</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/repository/jvm-knowledge-self-java-memory-area.html" rel="prev" title="JVM知识自查表——Java内存区域">JVM知识自查表——Java内存区域 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png" alt="落枫寒"><p class="site-author-name" itemprop="name">落枫寒</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是对象的状态"><span class="nav-number">1.</span> <span class="nav-text">什么是对象的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的哪些域不属于对象状态的一部分"><span class="nav-number">2.</span> <span class="nav-text">对象的哪些域不属于对象状态的一部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程安全性"><span class="nav-number">3.</span> <span class="nav-text">什么是线程安全性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全核心是什么"><span class="nav-number">4.</span> <span class="nav-text">线程安全核心是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是原子性"><span class="nav-number">5.</span> <span class="nav-text">什么是原子性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是竞态条件"><span class="nav-number">6.</span> <span class="nav-text">什么是竞态条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java提供了哪些同步机制"><span class="nav-number">7.</span> <span class="nav-text">Java提供了哪些同步机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是synchronized"><span class="nav-number">8.</span> <span class="nav-text">什么是synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是volatile关键字"><span class="nav-number">9.</span> <span class="nav-text">什么是volatile关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是对象的发布"><span class="nav-number">10.</span> <span class="nav-text">什么是对象的发布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是对象的逃逸"><span class="nav-number">11.</span> <span class="nav-text">什么是对象的逃逸</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程封闭"><span class="nav-number">12.</span> <span class="nav-text">什么是线程封闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程封闭有哪些实现"><span class="nav-number">13.</span> <span class="nav-text">线程封闭有哪些实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是不可变性"><span class="nav-number">14.</span> <span class="nav-text">什么是不可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final的特点"><span class="nav-number">15.</span> <span class="nav-text">final的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何去安全发布一个对象"><span class="nav-number">16.</span> <span class="nav-text">如何去安全发布一个对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是不变性条件和后验条件，以及他们的用途"><span class="nav-number">17.</span> <span class="nav-text">什么是不变性条件和后验条件，以及他们的用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是同步策略"><span class="nav-number">18.</span> <span class="nav-text">什么是同步策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是依赖状态的操作"><span class="nav-number">19.</span> <span class="nav-text">什么是依赖状态的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何设计线程安全的类"><span class="nav-number">20.</span> <span class="nav-text">如何设计线程安全的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何以线程安全的方式访问非线程安全对象"><span class="nav-number">21.</span> <span class="nav-text">如何以线程安全的方式访问非线程安全对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用私有的锁对象而不是内置锁的好处"><span class="nav-number">22.</span> <span class="nav-text">使用私有的锁对象而不是内置锁的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？"><span class="nav-number">23.</span> <span class="nav-text">如果类中的各个组件已经是线程安全的，是否需要再增加一个额外的安全层？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？"><span class="nav-number">24.</span> <span class="nav-text">当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能够修改他们呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈对ConcurrentHashMap的了解"><span class="nav-number">25.</span> <span class="nav-text">谈谈对ConcurrentHashMap的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈对CopyOnWriteArrayList的了解"><span class="nav-number">26.</span> <span class="nav-text">谈谈对CopyOnWriteArrayList的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于阻塞队列生产者和消费者模式"><span class="nav-number">27.</span> <span class="nav-text">基于阻塞队列生产者和消费者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是双端队列和工作密取"><span class="nav-number">28.</span> <span class="nav-text">什么是双端队列和工作密取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步工具类用途"><span class="nav-number">29.</span> <span class="nav-text">同步工具类用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭锁"><span class="nav-number">30.</span> <span class="nav-text">闭锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask"><span class="nav-number">31.</span> <span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量"><span class="nav-number">32.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栅栏"><span class="nav-number">33.</span> <span class="nav-text">栅栏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建高效且可伸缩的结果缓存"><span class="nav-number">34.</span> <span class="nav-text">构建高效且可伸缩的结果缓存</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="author" itemprop="copyrightHolder"><a href="http://www.vibrancy.cn">落枫寒</a>&nbsp;版权所有</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html><!-- rebuild by neat -->