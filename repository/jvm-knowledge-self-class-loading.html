<!-- build time:Sat Jun 17 2017 20:51:34 GMT+0800 (马来西亚半岛标准时间) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="java,jvm,类加载,"><link rel="alternate" href="/atom.xml" title="唯有日月不灭" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="主要介绍了Java虚拟机的类加载器、类加载过程;"><meta name="keywords" content="java,jvm,类加载"><meta property="og:type" content="article"><meta property="og:title" content="JVM知识自查表——类加载"><meta property="og:url" content="http://www.vibrancy.cn/repository/jvm-knowledge-self-class-loading.html"><meta property="og:site_name" content="唯有日月不灭"><meta property="og:description" content="主要介绍了Java虚拟机的类加载器、类加载过程;"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.svg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.svg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg"><meta property="og:updated_time" content="2017-06-17T12:50:06.387Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM知识自查表——类加载"><meta name="twitter:description" content="主要介绍了Java虚拟机的类加载器、类加载过程;"><meta name="twitter:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.svg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.vibrancy.cn/repository/jvm-knowledge-self-class-loading.html"><title>JVM知识自查表——类加载 | 唯有日月不灭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">唯有日月不灭</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://www.vibrancy.cn/repository/jvm-knowledge-self-class-loading.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="落枫寒"><meta itemprop="description" content=""><meta itemprop="image" content="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="唯有日月不灭"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM知识自查表——类加载</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-17T20:36:33+08:00">2017-06-17 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span></span><div class="post-description">主要介绍了Java虚拟机的类加载器、类加载过程;</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h2><p>类加载器不仅仅只用于实现类的加载动作，对于任意一个类，都需要由<strong>加载它的类加载器</strong>和这个类本身一同确立其在Java虚拟机中的<strong>唯一性</strong>。简单地说，比较两个类是否<strong>相等</strong>，只有在这两个类由<strong>同一个类加载器加载</strong>的前提之下才有意义。否则，即使这两个类来自于同一个Class文件，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p>这里所说的相等，包括代表类的Class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法返回的结果，也包括使用<code>instanceOf</code>关键字做对象所属关系判定等情况。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span> )+<span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</div><div class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</div><div class="line">                    is.read(b);</div><div class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Object obj = myLoader.loadClass(<span class="string">"com.cwc.test.jvm.classtest.ClassLoaderTest"</span>).newInstance();</div><div class="line">        System.out.println(obj.getClass());</div><div class="line">        System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">class com.cwc.test.jvm.classtest.ClassLoaderTest</div><div class="line">false</div></pre></td></tr></table></figure><p>由运行结果可以看到，这时虚拟机中存在了两个ClassLoaderTest类，一个是<strong>系统应用程序类加载器</strong>加载的，另一个是由<strong>自定义的类加载器</strong>加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查的时候结果自然为false。</p><h2 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h2><p>从虚拟机角度上讲，只存在两个不同的类加载器：一种是<strong>启动类加载器</strong>（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是<strong>所有其他的类加载器</strong>，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类<code>java.lang.ClassLoader</code>。</p><ol><li><p><strong>三种系统提供的类加载器</strong></p><ul><li><strong>启动类加载器</strong>（Bootstrap ClassLoader）：<ul><li>负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中，或者被<code>-Xbootclasspath</code>参数所指定的路径中，并且是虚拟机识别的类库加载到虚拟机内存中。</li><li><strong>启动类加载器无法被Java程序直接引用</strong>。</li></ul></li><li><strong>扩展类加载器</strong>（Extension ClassLoader）<ul><li>这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li><li><strong>开发者可以直接使用扩展类加载器</strong>。</li></ul></li><li><strong>应用程序类加载器</strong>（Application ClassLoader）<ul><li>这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。</li><li>该类加载器也是ClassLoader中<code>getSystemClassLoader()</code>方法的返回值，所以一般称为<strong>系统类加载器</strong>。</li><li>负责加载用户类路径（ClassPath）上所指定的类库。</li><li>开发者可以直接使用这个类加载器，如果应用程序没有自定义类加载器，一般情况下就是默认的类加载器。</li></ul></li></ul></li><li><p><strong>三种类加载器之间的关系如图所示</strong></p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.svg" alt="image"></p><p>上图所示的类加载器之间的层次关系，就称之为<strong>类加载器的双亲委派模型</strong>（Parent Delegation Model）。双亲委派模型除了要求顶层的启动类加载器外，其余的类加载器都有自己的父类加载器。这里的类加载器之间的父子关系并不以<strong>继承的关系</strong>实现，而是通过<strong>组合关系</strong>来复用父加载器代码的。</p></li><li><p><strong>双亲委派模型的工作过程</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（在他的<strong>搜索范围</strong>内没有找到所需的类），子类加载器才会去尝试自己去加载。</p><p>使用双亲委派模型的优点：随着他的类加载器一起具备了一种带有优先级的层次关系。例如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>包中，无论哪一个类加载器加载这个类，最终都是要委派给启动类加载器进行加载，因此Object类在程序的各类加载器环境中都是同一个类。</p></li></ol><h2 id="为什么Web服务器要自定义类加载器"><a href="#为什么Web服务器要自定义类加载器" class="headerlink" title="为什么Web服务器要自定义类加载器"></a>为什么Web服务器要自定义类加载器</h2><p>主流的Java Web服务器都实现了自己定义的类加载器（不止一个），因为一个功能健全的Web服务器，都需要解决如下几个问题：</p><ol><li><p>部署在同一个服务器上的两个Web应用程序所使用的<strong>Java类库可以实现相互隔离</strong>。这是最基本的要求，两个不同的应用程序可能会依赖同一个三方库的<strong>不同版本</strong>，不能要求一个类库在一个服务器中只能存在一份，因此，服务器应当可以保证<strong>两个应用程序的类库可以互相独立</strong>使用。</p></li><li><p>部署在同一个服务器上的两个Web应用程序所使用的<strong>Java类库可以互相共享</strong>。类库在使用的时候都需要被加载到服务器内存中，如果类库不能共享，虚拟机的方法区很容易就会出现过度膨胀的风险。</p></li><li><p><strong>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响</strong>。因为大多数主流的Java Web服务器自身也是使用Java语言来实现的，因此服务器本身也有类库依赖。因此，基于安全考虑，<strong>服务器所使用的类库</strong>应该与<strong>应用程序的类库</strong>互相独立。</p></li><li><p>支持JSP生成类的热替换（HotSwap功能）。</p></li></ol><p>由于存在上述问题，在部署Web应用时，单独的一个ClassPath就无法满足用户的需求，所以各种Web服务器都提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般都以“lib”或“classes”命名。<strong>被放置到不同路径中的类库，具备不同的访问范围和服务对象</strong>。通常每一个目录都会有一个<strong>相应的自定义类加载器</strong>去加载放置在里面的Java类库。</p><h2 id="Tomcat的类加载器结构"><a href="#Tomcat的类加载器结构" class="headerlink" title="Tomcat的类加载器结构"></a>Tomcat的类加载器结构</h2><p>在Tomcat目录结构中（老版本），有以下目录可以存放Java类库：</p><ul><li><strong>common/</strong>：类库可以被Tomcat和所有的Web应用程序功能使用；</li><li><strong>server/</strong>：类库可以被Tomcat使用，对所有的Web应用程序都不可见；</li><li><strong>shared/</strong>：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li><li><strong>webapp/WEB-INF/</strong>：类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li></ul><p>Tomcat自定义了多个类加载器，这些类加载器都按照<strong>经典的双亲委派模型</strong>来实现的。<strong>CommonClassLoader</strong>、<strong>CatalinaClassLoader</strong>、<strong>SharedClassLoader</strong> 和<strong>WebappClassLoader</strong>他们分别加载/common/、/server/、 /shared/ 、 和 /webapp/WEB-INF/中Java类库的逻辑。其中WebApp类加载器和Jsp类加载器通常会存在<strong>多个实例</strong></p><ul><li>每一个Web应用程序对应一个WebApp类加载器；</li><li>每个JSP文件对应一个Jsp类加载器。</li></ul><p>Tomcat多个类加载器之间的关系如图所示：</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.svg" alt="image"></p><p>从上图可以看出：</p><ul><li>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用；</li><li>CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</li><li>WebappClassLoader可以使用SharedClassLoader加载到的类，但各个WebappClassLoader实例之间相互隔离。</li><li>JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class，他出现的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过新创建一个JSP类加载器实现JSP文件的HotSqap功能。</li></ul><h2 id="哪些情况必须对类进行初始化"><a href="#哪些情况必须对类进行初始化" class="headerlink" title="哪些情况必须对类进行初始化"></a>哪些情况必须对类进行初始化</h2><ol><li>使用<strong>new关键字实例化对象</strong>的时候；读取或设置一个类的静态字段时；调用类的静态方法时。</li><li>当初始化一个类时，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>使用\(java.lang.reflect$`包的方法对类进行反射初始化的时候。</li><li>当虚拟机启动时，用户指定的执行主类（包含main()方法的类）。</li></ol><p><strong>接口的加载</strong>过程和<strong>类加载</strong>过程稍有不同：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部初始化完成，只有在真正使用到父接口的时候（如<strong>引用接口中定义的常量</strong>）才会初始初始化。</p><h2 id="哪些情况不会触发对类的初始化"><a href="#哪些情况不会触发对类的初始化" class="headerlink" title="哪些情况不会触发对类的初始化"></a>哪些情况不会触发对类的初始化</h2><ol><li><p><strong>通过子类引用父类的静态字段，不会导致子类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> vlaue = <span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(SubClass.vlaue);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">SuperClass init!</div><div class="line">123</div></pre></td></tr></table></figure><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类引用父类中定义的静态字段，只会触发父类的初始化。</p><p>不过，通过\(-XX:+TraceClassLoading$`参数可以看到此操作导致了子类的加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[Loaded com.cwc.test.jvm.classtest.SuperClass from file:/G:/DevelopmentTest/JavaSE/Test/out/production/Test/]</div><div class="line">[Loaded com.cwc.test.jvm.classtest.SubClass from file:/G:/DevelopmentTest/JavaSE/Test/out/production/Test/]</div><div class="line">SuperClass init!</div><div class="line">123</div></pre></td></tr></table></figure></li><li><p><strong>通过数组定义来引用类，不会触发此类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SuperClass[] superClasses = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">运行结果：</div></pre></td></tr></table></figure><p>运行之后没有发现输出\(SuperClass\ init!$<code>，不过\\(SuperClass$</code>进行了<strong>加载Loading</strong>。不过，这段代码中会触发另外一个名为\([Lcom.cwc.test.jvm.classtest.SuperClass$<code>的类的初始化，该类是由虚拟机自动生成的、直接继承于\\(java.lang.Object$</code>的子类，创建动作由字节码指令\(newarray$`触发。</p></li><li><p><strong>常量在编译阶段会存入==调用类的常量池==中，本质上没有直接引用到定义常量的类，因此不会触发定义常量类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VALUE = <span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(ConstClass.VALUE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">123</div></pre></td></tr></table></figure><p>虽然引用了\(ConstClass$<code>类中的常量VALUE，但是在编译阶段将此常量的值存储到了\\(NotInitialization$</code>类的常量池中，对常量\(ConstClass.VALUE$<code>的引用实际上都转化为\\(NotInitialization$</code>类对自身常量池的引用。</p></li></ol><h2 id="谈谈类加载的过程"><a href="#谈谈类加载的过程" class="headerlink" title="谈谈类加载的过程"></a>谈谈类加载的过程</h2><p>虚拟机把描述类的数据从Class文件<strong>加载到内存</strong>，并对数据进行<strong>校验</strong>、<strong>转换解析</strong>和<strong>初始化</strong>、最终形成可以被虚拟机直接使用的<strong>Java类型</strong>，这就是虚拟机的类加载机制。</p><p>在Java语言里，类型的<strong>加载和连接</strong>过程都是在程序运行期间完成的，虽然会增加一些性能开销，但是为<strong>运行期间动态加载</strong>和<strong>动态连接</strong>提供了可能。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="image"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是固定的，而<strong>解析阶段</strong>则不一定，在某些情况下可以在<strong>初始化阶段</strong>之后在开始，这是为了支持Java语言的<strong>运行时绑定</strong>。</p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p>在<strong>加载阶段</strong>，虚拟机需要完成以下三件事：</p><ol><li>通过一个类的<strong>全限定名</strong>来获取定义此类的<strong>二进制字节流</strong>。获取二进制字节流的来源包括：<ul><li>从JAR、EAR、WAR包中获取</li><li>从网络中获取</li><li>运行时计算生成，例如，动态代理技术</li><li>由其他文件生成，如JSP应用</li></ul></li><li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>。</li><li>在Java堆中生成一个代表这个类的\(java.lang.Class$`对象，作为方法区这些数据的访问入口。</li></ol><p><strong>加载阶段</strong>（加载阶段中<strong>获取类的二进制字节流的动作</strong>）也是开发期间<strong>可控性最强</strong>的阶段，因为加载阶段既可以使用系统提供的<strong>类加载器</strong>完成，也可以使用用户自定义的类加载器完成。</p><p>加载阶段和连接阶段的<strong>部分内容是交叉进行</strong>的（一部分字节码文件格式验证动作），加载阶段尚未完成，连接阶段可能已经开始，但这些夹杂在加载阶段之中进行的动作，仍然属于连接阶段的内容。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证的目的是为了确保<strong>Class文件的字节流</strong>中包含的信息流符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>不过Java语言是相对安全的语言，使用纯粹的Java代码不会访问诸如数组边界之外的数据、将一个对象转型为并为实现的类型、跳转到并不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。</p><p>Class二进制字节流的来源很多，并不一定要求Java源码编译而来。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p><p>验证阶段的检验过程主要包括：</p><ol><li><strong>文件格式验证</strong>：字节流是否符合Class文件格式的规范，保证输入的字节流能正确地解析并存储于方法区之内。<ul><li>是否以魔数<code>0xCAFEBABE</code>开头</li><li>主、次版本号是否在当前虚拟机处理范围内</li><li>常量池的常量是否有不被支持的常量类型。</li><li>指向常量池的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info类型的常量中是否有不符合UTF8编码的数据</li><li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息。</li><li>…</li></ul></li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求。<ul><li>这个类是否有父类；</li><li>这个类的父类是否继承了不允许被继承的类（如final修饰的类）；</li><li>如果这个类不是抽象类，是否实现了父类或接口中要求实现的方法；</li><li>类中的字段、方法是否与父类产生矛盾。</li><li>…</li></ul></li><li><strong>字节码验证</strong>：进行<strong>数据流</strong>和<strong>控制流</strong>分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。<strong>因为不能通过程序准确地检查出程序是否能在有限的时间之内结束运行</strong>。</li><li><p><strong>符号引用验证</strong>：将<strong>符合引用</strong>转化为<strong>直接引用</strong>，这个转化动作将在连接的第三阶段完成（解析阶段）。目的是保证<strong>解析动作</strong>能正常执行，如果无法通过符号引用验证，将会抛出一个\(java.lang.IncompatibleClassChangeError$<code>异常的子类，如\\(java.lang.NoSuchMethodError$</code>等。</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类；</li><li>在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段；</li><li><p>符合引用中的类、字段和方法的访问性是否可被当前类访问。</p><p>该阶段是一个非常重要，但非必须的阶段，如果所运行的代码都已经反复被使用和验证过，在实施阶段可以考虑使用\(-Xverify:none$`参数关闭大部分的类验证措施，缩短虚拟机类加载的时间。</p></li></ul></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段的目的是正式为<strong>类变量分配内存</strong>并设置<strong>类变量初始值</strong>的阶段，这些内存都将在<strong>方法区</strong>中分配。</p><p>该阶段进行内存分配的仅包括<strong>类变量</strong>（被static修饰的变量），而不包括实例变量，实例变量将在对象实例化时随着对象分配在Java堆中。</p><p>另外，设置类变量的初始值是0值，而不是用户初始化的值。例如，<code>public static int value=123;</code>在准备阶段过后，value的值为0，而不是123。如果类字段的字段属性表中存在final属性，那么准备阶段过后value就会被初始化<strong>为final属性</strong>所执行的值。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>方法调用</strong>并不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪个方法），暂时还不涉及方法内部的具体运行过程。</p><p>一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而<strong>不是</strong>方法在实际运行时内存布局的<strong>入口地址</strong>。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在<strong>类加载期间</strong>甚至到运行期间才能确定目标方法的直接引用。</p><p>解析阶段是虚拟机将常量池内的<strong>符号引用</strong>解析为<strong>直接引用</strong>的过程：</p><ul><li><strong>符号引用</strong>：以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用的时候能无歧义地定位到目标即可。符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li><li><strong>直接引用</strong>：直接引用可以是直接指向目标的<strong>指针</strong>、<strong>相对偏移量</strong>或是一个间接定位到<strong>目标的句柄</strong>。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p>解析的动作主要针对<strong>类或接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>四类符号引用进行解析。</p><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分<strong>符号引用转化为直接引用</strong>。而这种解析能成立的前提是：++方法在程序真真运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的++。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。</p><p>在Java语言中，符合“<strong>编译期可知，运行期不可变</strong>”这个要求的方法主要有<strong>静态方法</strong>和<strong>私有方法</strong>两大类，前者与类型直接相关，后者在外部不可被访问，这两个方法都不能通过继承或别的方式重写出其他版本，因此他们都适合在类加载阶段进行解析。</p><p>在Java虚拟机里面提供了四条方法调用字节码指令</p><ul><li><strong>invokestatic</strong>：调用静态方法；</li><li><strong>invokespecial</strong>：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法；</li><li><strong>invokevirtual</strong>：调用所有的虚方法；</li><li><strong>invokeinterface</strong>：调用接口方法，会在运行时再确定一个实现接口的对象。</li></ul><p>只要能够被invokestatic 和 invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有<strong>静态方法</strong>、<strong>私有方法</strong>、<strong>实例构造器</strong>和<strong>父类方法</strong>四类，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以成为非虚方法。与之相反，其他方法就称为虚方法（除final方法）。</p><p>Java中的非虚方法除了使用invokestatic 和 invokespecial指令调用之外，就是被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但由于他无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，或者说多态的选择结果是唯一的。Java规范中明确说明了final方法是一个中非虚方法。</p><p>解析调用一定是个<strong>静态过程</strong>，在编译期就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派，这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派和动态多分派四种情况。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化时类加载过程的最后一步，在该阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。或者可以理解为执行类构造器<code>&lt;clinit&gt;()</code>的过程。</p><ol><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<strong>类变变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的。编译器收集的==顺序==有语句在<strong>源文件中出现的顺序</strong>所决定，静态语句块中只能访问到在静态语句块之前的变量。</li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数（实例构造器<code>&lt;init&gt;()</code>方法）不同，他不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</li><li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        A=<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(Child.B);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">2</div></pre></td></tr></table></figure></li><li><p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法方法。</p></li><li>接口中不能使用静态语句块，但仍有变量初始化的赋值操作，因此接口与类一样会生成<code>&lt;clinit&gt;()</code>方法方法。但接口与类不同，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li><li>在多线程环境中，虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法被正确的加锁和同步。如果多个线程同时初始化一个类，那么只有一个线程执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li></ol><h2 id="什么是静态分派"><a href="#什么是静态分派" class="headerlink" title="什么是静态分派"></a>什么是静态分派</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human man)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, guy"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, man"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Women man)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, women"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human women = <span class="keyword">new</span> Women();</div><div class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</div><div class="line">        sd.sayHello(man);</div><div class="line">        sd.sayHello(women);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">hello, guy</div><div class="line">hello, guy</div></pre></td></tr></table></figure><p>在上面的代码中，Human称为变量的<strong>静态类型</strong>（Static Type）或者外观类型，后面的Man则称为变量的<strong>实际类型</strong>。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在<strong>使用时</strong>发生，变量本身的静态类型不会被改变，并且最终的静态类型是在<strong>编译期可知</strong>的；而<strong>实际类型</strong>变化的结果在<strong>运行期</strong>才可以确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实际类型变化</span></div><div class="line">Human man = <span class="keyword">new</span> Man();</div><div class="line">man = <span class="keyword">new</span> Women();</div><div class="line"><span class="comment">// 静态类型变化</span></div><div class="line">sd.sayHello((Man)man);</div><div class="line">sd.sayHello((Women)man);</div></pre></td></tr></table></figure><p>在<code>main()</code>方法的两次<code>sayHello()</code>方法调用中，在方法接收者已经确定对象“sd”的情况下，使用过哪个重载版本，就完全取决于不同的变量，但是虚拟机（编译器）在重载时是通过<strong>参数的静态类型</strong>而不是实际类型作为判定依据的。并且静态类型是编译器可知的。所以在编译阶段，javac编译器就根据参数的静态类型决定使用哪个重载版本，并把这个方法的符号引用写到了main()方法里的两条<code>invokevirtual</code>指令的参数中。</p><p>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用就是<strong>方法重载</strong>，静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p><h2 id="什么是动态分派"><a href="#什么是动态分派" class="headerlink" title="什么是动态分派"></a>什么是动态分派</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"man, say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"women, say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human women = <span class="keyword">new</span> Women();</div><div class="line"></div><div class="line">        man.sayHello();</div><div class="line">        women.sayHello();</div><div class="line"></div><div class="line">        man = <span class="keyword">new</span> Women();</div><div class="line">        man.sayHello();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">man, say hello</div><div class="line">women, say hello</div><div class="line">women, say hello</div></pre></td></tr></table></figure><p>变量man在两次调用中执行了不同的方法，很明显的原因是这个两个变量的实际类型不同，那么Java虚拟机是如何根据实际类型来分派方法执行版本的呢？其原因需要从<code>invokevirtual</code>指令的多态查找过程说起，<code>invokevirtual</code>指令的运行时解析过程的步骤为：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；</li><li>如果类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ol><p>由于<code>invokevirtual</code>指令执行的第一步是在运行期确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是java语言方法重写的本质。</p><p>并且把这种在运行期间根据实际类型确定方法执行版本的分派过程称为动态分派。</p></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"># java</a> <a href="/tags/jvm/" rel="tag"># jvm</a> <a href="/tags/类加载/" rel="tag"># 类加载</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/repository/jvm-knowledge-self-gc.html" rel="next" title="JVM知识自查表——垃圾收集"><i class="fa fa-chevron-left"></i> JVM知识自查表——垃圾收集</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png" alt="落枫寒"><p class="site-author-name" itemprop="name">落枫寒</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器的作用"><span class="nav-number">1.</span> <span class="nav-text">类加载器的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是双亲委派模型"><span class="nav-number">2.</span> <span class="nav-text">什么是双亲委派模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么Web服务器要自定义类加载器"><span class="nav-number">3.</span> <span class="nav-text">为什么Web服务器要自定义类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat的类加载器结构"><span class="nav-number">4.</span> <span class="nav-text">Tomcat的类加载器结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哪些情况必须对类进行初始化"><span class="nav-number">5.</span> <span class="nav-text">哪些情况必须对类进行初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哪些情况不会触发对类的初始化"><span class="nav-number">6.</span> <span class="nav-text">哪些情况不会触发对类的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈类加载的过程"><span class="nav-number">7.</span> <span class="nav-text">谈谈类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载阶段"><span class="nav-number">7.1.</span> <span class="nav-text">加载阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">7.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">7.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">7.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">7.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是静态分派"><span class="nav-number">8.</span> <span class="nav-text">什么是静态分派</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是动态分派"><span class="nav-number">9.</span> <span class="nav-text">什么是动态分派</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="author" itemprop="copyrightHolder"><a href="http://www.vibrancy.cn">落枫寒</a>&nbsp;版权所有</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html><!-- rebuild by neat -->