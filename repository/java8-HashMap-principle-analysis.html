<!-- build time:Sat Jun 17 2017 20:44:15 GMT+0800 (马来西亚半岛标准时间) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="java,HashMap,红黑树,散列表,"><link rel="alternate" href="/atom.xml" title="唯有日月不灭" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="本文主要介绍了Java8 HashMap的实现原理、包括一些重要的成员变量、put方法分析，扩容分析、Java8与Java7HashMap性能对比。"><meta name="keywords" content="java,HashMap,红黑树,散列表"><meta property="og:type" content="article"><meta property="og:title" content="Java8 HashMap原理分析"><meta property="og:url" content="http://www.vibrancy.cn/repository/java8-HashMap-principle-analysis.html"><meta property="og:site_name" content="唯有日月不灭"><meta property="og:description" content="本文主要介绍了Java8 HashMap的实现原理、包括一些重要的成员变量、put方法分析，扩容分析、Java8与Java7HashMap性能对比。"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/image/java/diagram.svg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/image/java/hashmap-inner-structure.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/image/java/hash-indexfor.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/image/java/HashMap%20put%E6%B5%81%E7%A8%8B.jpg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/gif/java%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E5%92%8C%E6%96%AD%E7%82%B9%E7%9A%84%E6%8C%82%E8%B5%B7%E6%A8%A1%E5%BC%8F.gif"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/gif/java%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug%E8%B0%83%E8%AF%95.gif"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png"><meta property="og:updated_time" content="2017-05-15T11:56:10.510Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java8 HashMap原理分析"><meta name="twitter:description" content="本文主要介绍了Java8 HashMap的实现原理、包括一些重要的成员变量、put方法分析，扩容分析、Java8与Java7HashMap性能对比。"><meta name="twitter:image" content="http://op87q3xru.bkt.clouddn.com/image/java/diagram.svg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.vibrancy.cn/repository/java8-HashMap-principle-analysis.html"><title>Java8 HashMap原理分析 | 唯有日月不灭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">唯有日月不灭</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://www.vibrancy.cn/repository/java8-HashMap-principle-analysis.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="落枫寒"><meta itemprop="description" content=""><meta itemprop="image" content="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="唯有日月不灭"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java8 HashMap原理分析</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T12:55:16+08:00">2017-05-03 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span><div class="post-description">本文主要介绍了Java8 HashMap的实现原理、包括一些重要的成员变量、put方法分析，扩容分析、Java8与Java7HashMap性能对比。</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</li><li>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li>映射中的key是不可变对象，不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</li></ol><h3 id="类继承关系图"><a href="#类继承关系图" class="headerlink" title="类继承关系图"></a>类继承关系图</h3><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/diagram.svg" alt="hashmap"></p><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="几个重要的属性"><a href="#几个重要的属性" class="headerlink" title="几个重要的属性"></a>几个重要的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">transient Node&lt;K, V&gt;[] table; </div><div class="line">int threshold;</div><div class="line">final float loadFactor;</div><div class="line">transient int size; </div><div class="line">transient int modCount;</div><div class="line">static final int TREEIFY_THRESHOLD = 8;</div></pre></td></tr></table></figure><ol><li><p>table</p><ul><li>哈希桶数组</li><li>初始化长度length默认为16，长度必须为2的n次方（合数）。</li><li>常规设计是把length设计为<strong>素数</strong>，来减少hash冲突的概率。而HashMap在此是为了在<strong>取模和扩容</strong>的时候做优化，同时也为了减少冲突。</li></ul></li><li><p>loadFactor</p><ul><li>负载因子，是table中<strong>元素数量</strong>和<strong>table长度</strong>的比值。</li><li>默认值是0.75</li></ul></li><li><p>threshold</p><ul><li>HashMap所能容纳的最大数据量的Node(键值对)个数；</li><li>计算公式：<code>threshold = table.length * loadFactor</code>，结合公式可知，threshold是负载因子和数组长度对应下允许的最大元素数目，如果超过这个数目，那么就得重新扩容（resize），扩容后的容量是之前容量的2倍。</li><li>如果<strong>内存空间大</strong>而又对<strong>时间效率要求很高</strong>，可以<strong>降低</strong>负载因子Load factor的值。</li><li>如果<strong>内存空间紧张</strong>而对<strong>时间效率要求不高</strong>，可以<strong>增加</strong>负载因子loadFactor的值，这个值可以大于1。</li></ul></li><li><p>size</p><ul><li>HashMap中实际存在的键值对数量；</li><li>注意与<code>table.length</code>、<code>threshold</code>的区别。</li></ul></li><li><p>modCount</p><ul><li>记录HashMap内部结构发生变化的次数；</li><li>用于迭代的快速失败。</li></ul></li><li><p>TREEIFY_THRESHOLD</p><ul><li>链表转红黑树的长度阈值。</li></ul></li></ol><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>从结构实现来讲，HashMap是<strong>数组+链表+红黑树</strong>来实现的。</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/hashmap-inner-structure.png" alt="image"></p><p>从源码可知，<code>HashMap类</code>中有一个非常重要的字段，就是<code>Node[] table</code>，即上图中的<strong>哈希桶数组table</strong>，是一个<code>Node类型</code>的数组。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;</div><div class="line">    final int hash; //用来定位数组索引的位置</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K, V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry接口</code>，本质是就是一个映射(键值对)，上图中的每个黑色圆点就是一个<code>Node对象</code>。</p><p>HashMap就是使用<strong>哈希表</strong>来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题，Java中HashMap采用了<strong>链地址法</strong>，链地址法简单来说，就是数组加链表的结合。在每个数组元素上都对应一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p><p>如果<strong>哈希桶数组</strong>很大，即使较差的Hash算法也会比较分散；如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡。其实就是根据实际情况实行哈希数组的<strong>扩容或收缩</strong>，并在此基础上设计<strong>好的hash算法</strong>减少Hash碰撞。</p><p>负载因子和Hash算法设计的再合理，也免不了会出现链表过长的情况，一旦链表过长，则会严重影响HashMap的性能。当链表长度太长（默认超过<code>TREEIFY_THRESHOLD</code>）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><h3 id="核心方法分析"><a href="#核心方法分析" class="headerlink" title="核心方法分析"></a>核心方法分析</h3><h4 id="根据键值计算哈希桶数组的索引"><a href="#根据键值计算哈希桶数组的索引" class="headerlink" title="根据键值计算哈希桶数组的索引"></a>根据键值计算哈希桶数组的索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*</div><div class="line">* 根据key计算hash值</div><div class="line">*/</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    // h = key.hashCode(); 第一步、取 kek的hashCode值</div><div class="line">    // h ^ (h &gt;&gt;&gt; 16) 第二步、取hash的高位与hash参与异或运算</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 根据hash值和数组长度，计算key在table中的索引。</div><div class="line">* JDK8 中没有该方法，它直接在方法内部计算 hash &amp; (length - 1) 的值</div><div class="line">*/</div><div class="line">private static int indexFor(int hash, int length) &#123;</div><div class="line">    return hash &amp; (length - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不管是增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。对于任意给定的对象，只要hashCode相同，那么<code>hash()</code>方法返回的hash值总是相同的。一般情况下，将hash值与数组长度进行<strong>取模运算</strong>来得到数组索引，但是取模运算的消耗还是比较大的。在HashMap中，通过<code>indexFor()</code>方法来计算索引。</p><p><code>indexFor()</code>方法非常的巧妙，通过<code>hash &amp; (length-1)</code>得到对象的保存位置。因为HashMap底层数组的长度总是2的n次方，这时<code>hash &amp; (length-1)</code>运算等价于hash对length的取模，&amp;比%具有更高的效率。</p><p>画图说明<code>hash()</code>和<code>indexFor()</code>的运算过程:<br><img src="http://op87q3xru.bkt.clouddn.com/image/java/hash-indexfor.png" alt="image"></p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ol><li><p>put()流程</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/HashMap%20put%E6%B5%81%E7%A8%8B.jpg" alt="image"></p></li><li><p>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">               boolean evict) &#123;</div><div class="line">    Node&lt;K, V&gt;[] tab;</div><div class="line">    Node&lt;K, V&gt; p;</div><div class="line">    int n, i;</div><div class="line">    //table 是否为空 或者 长度为0</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0) &#123;</div><div class="line">        // resize 重新扩容</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    &#125;</div><div class="line">    //如果当前table索引上的值为空</div><div class="line">    if ((p = tab[i = hash &amp; (n - 1)]) == null)</div><div class="line">        //直接将值插入</div><div class="line">        tab[i] = newNode(hash, key, value, null);</div><div class="line">    else &#123;</div><div class="line">        Node&lt;K, V&gt; e;</div><div class="line">        K k;</div><div class="line">        // 如果 key 并且 hash 相同</div><div class="line">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            e = p;//直接覆盖value</div><div class="line">        else if (p instanceof TreeNode)</div><div class="line">            //如果是红黑树，则直接在树中插入键值对</div><div class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value);</div><div class="line">        else &#123;</div><div class="line">            //开始循环，遍历链表</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line"></div><div class="line">                if ((e = p.next) == null) &#123;</div><div class="line">                    //到了链表末尾</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div class="line">                        //链表长度大于8转换为红黑树进行处理</div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                // 如果 key 并且 hash 相同</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    //直接覆盖value</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        //超过最大容量 就扩容</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p><strong>扩容</strong>(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</p><p>下面举个例子说明下扩容过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;</div><div class="line">    HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(2);</div><div class="line">    printInfo(map, &quot;初始化HashMap的信息为：&quot;);</div><div class="line">    int[] values = &#123;3, 7, 5, 9&#125;;</div><div class="line">    for (int i = 0; i &lt; values.length; i++) &#123;</div><div class="line">        map.put(values[i], &quot;v&quot;);</div><div class="line">        printInfo(map, String.format(&quot;添加第%d个元素[%s=%s]后的info：&quot;, i + 1, values[i], &quot;v&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下图所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">初始化HashMap的信息为：</div><div class="line">size: 0</div><div class="line">tableLength: 0</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 2</div><div class="line">modCount: 0</div><div class="line">table:	null</div><div class="line"></div><div class="line">添加第1个元素[3=v]后的info：</div><div class="line">size: 1</div><div class="line">tableLength: 2</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 1</div><div class="line">modCount: 1</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [3=v]</div><div class="line"></div><div class="line">添加第2个元素[7=v]扩容后的info：</div><div class="line">size: 2</div><div class="line">tableLength: 4</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 3</div><div class="line">modCount: 2</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | null</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div><div class="line"></div><div class="line">添加第3个元素[5=v]后的info：</div><div class="line">size: 3</div><div class="line">tableLength: 4</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 3</div><div class="line">modCount: 3</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [5=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div><div class="line"></div><div class="line">添加第4个元素[9=v]扩容后的info：</div><div class="line">size: 4</div><div class="line">tableLength: 8</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 6</div><div class="line">modCount: 4</div><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v]</div><div class="line">	 4   | null</div><div class="line">	 5   | [5=v]</div><div class="line">	 6   | null</div><div class="line">	 7   | [7=v]</div></pre></td></tr></table></figure><p></p><p>经过观测可发现，HashMap的table数组长度使用的是2次幂的扩展（长度扩展为原来2倍），数组扩展后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置，扩展后对于<strong>元素新位置的判断</strong>对应的源码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">HashMap.resize():</div><div class="line"></div><div class="line">Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">Node&lt;K,V&gt; next;</div><div class="line">do &#123;</div><div class="line">    next = e.next;</div><div class="line">    if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">        if (loTail == null)</div><div class="line">            loHead = e;</div><div class="line">        else</div><div class="line">            loTail.next = e;</div><div class="line">        loTail = e;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (hiTail == null)</div><div class="line">            hiHead = e;</div><div class="line">        else</div><div class="line">            hiTail.next = e;</div><div class="line">        hiTail = e;</div><div class="line">    &#125;</div><div class="line">&#125; while ((e = next) != null);</div><div class="line">if (loTail != null) &#123;</div><div class="line">    loTail.next = null;</div><div class="line">    newTab[j] = loHead;</div><div class="line">&#125;</div><div class="line">if (hiTail != null) &#123;</div><div class="line">    hiTail.next = null;</div><div class="line">    newTab[j + oldCap] = hiHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接下来以<strong>添加第4个元素之后进行扩容</strong>的过程分析一下上面代码的原理</p><ol><li><p>以上4个元素的hash值分别为：</p><p>| key | hash |<br>| :—: | :—: |<br>| 3 | 3 |<br>| 7 | 7 |<br>| 5 | 5 |<br>| 9 | 9 |</p></li><li><p>当把第4个元素[9=v]添加进map之后，未扩容（未执行resize()）前的table为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [5=v] --&gt; [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v] --&gt; [7=v]</div></pre></td></tr></table></figure></li></ol><ol><li><p>这时由于<code>++size &gt; threashold ==&gt; 4&gt;3</code> ，所以需要执行resize()方法</p><p>该过程为新建一个长度为原来2倍的数组，如果判断原来数组上的node是一个链表，那么会遍历链表，判断每个元素的<code>(e.hash &amp; oldCap)</code>的值是否为0，来决定链表中元素的新位置</p><p>| key | hash | (e.hash &amp; oldCap) | 是否为0 | 新索引 |<br>| :—: | :—: | :—————: | :—–: | :—-: |<br>| 3 | 3 | 0 | 是 | 3 |<br>| 7 | 7 | 4 | 否 | 3+4 |<br>| 5 | 5 | 4 | 是 | 1+4 |<br>| 9 | 9 | 0 | 否 | 1 |</p><p>根据上表的统计可以得出结论，如果<code>e.hash &amp; oldCap</code>为0，则位置索引不变；否则新的索引是<strong>原位置索引+oldCap</strong>的，那么扩容后的table为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">table:	索引 | 元素</div><div class="line">	 0   | null</div><div class="line">	 1   | [9=v]</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=v]</div><div class="line">	 4   | null</div><div class="line">	 5   | [5=v]</div><div class="line">	 6   | null</div><div class="line">	 7   | [7=v]</div></pre></td></tr></table></figure><p>该判断是JDK8的一个优化，不需要像JDK7那样重新计算hash，只需要判断元素的hash值与oldCap的与运算结果就好了。这样的设计省去了重新计算hash值的时间，并且能够均匀的把冲突的节点分散到新的table中去。另外，JDK8的HashMap在迁移链表的时候会保持链表元素的顺序不变。</p></li><li><p><code>resize()</code>方法的全部代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K, V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K, V&gt;[] oldTab = table;</div><div class="line">    int oldCapacity = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThreshold = threshold;</div><div class="line">    int newCapacity, newThreshold = 0;</div><div class="line">    if (oldCapacity &gt; 0) &#123;</div><div class="line">        if (oldCapacity &gt;= MAXIMUM_CAPACITY) &#123;//扩容前的数组大小如果已经达到最大(2^30)了</div><div class="line">            threshold = Integer.MAX_VALUE;//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</div><div class="line">            return oldTab;</div><div class="line">        &#125; else if ((newCapacity = oldCapacity &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                oldCapacity &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThreshold = oldThreshold &lt;&lt; 1; // 将容量和阈值在原来的基础上扩大2倍</div><div class="line">    &#125; else if (oldThreshold &gt; 0) // initial capacity was placed in threshold</div><div class="line">        newCapacity = oldThreshold;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCapacity = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThreshold = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThreshold == 0) &#123;</div><div class="line">        float ft = (float) newCapacity * loadFactor;</div><div class="line">        newThreshold = (newCapacity &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ?</div><div class="line">                (int) ft : Integer.MAX_VALUE);//修改阈值</div><div class="line">    &#125;</div><div class="line">    threshold = newThreshold;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</div><div class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCapacity];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCapacity; ++j) &#123;//遍历原来的哈希表数组</div><div class="line">            Node&lt;K, V&gt; current;</div><div class="line">            if ((current = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;//清空</div><div class="line">                if (current.next == null)//如果当前节点只有一个节点</div><div class="line">                    newTab[current.hash &amp; (newCapacity - 1)] = current;</div><div class="line">                else if (current instanceof TreeNode)//如果当前节点是红黑树</div><div class="line">                    ((TreeNode&lt;K, V&gt;) current).split(this, newTab, j, oldCapacity);</div><div class="line">                else &#123; // 当前是链表 ，保留顺序preserve order</div><div class="line">                    Node&lt;K, V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K, V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K, V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = current.next;</div><div class="line">                        if ((current.hash &amp; oldCapacity) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = current;</div><div class="line">                            else</div><div class="line">                                loTail.next = current;</div><div class="line">                            loTail = current;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = current;</div><div class="line">                            else</div><div class="line">                                hiTail.next = current;</div><div class="line">                            hiTail = current;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((current = next) != null);</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCapacity] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h3 id="并发的rehash过程"><a href="#并发的rehash过程" class="headerlink" title="并发的rehash过程"></a>并发的rehash过程</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，因为在并发的多线程使用场景中使用HashMap可能造成<strong>数据丢失</strong>。</p><ol><li><p>多线程测试HashMap的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(2, 0.75f);</div><div class="line">    AtomicInteger counter = new AtomicInteger(0);</div><div class="line">    map.put(5, &quot;C&quot;);</div><div class="line">    Runnable r1 = () -&gt; &#123;</div><div class="line">        map.put(7, &quot;B&quot;);</div><div class="line">        counter.incrementAndGet();</div><div class="line">    &#125;;</div><div class="line">    Runnable r2 = () -&gt; &#123;</div><div class="line">        map.put(3, &quot;A&quot;);</div><div class="line">        map.put(8, &quot;A&quot;);</div><div class="line">        counter.incrementAndGet();</div><div class="line">    &#125;;</div><div class="line">    new Thread(r1, &quot;thread1&quot;).start();</div><div class="line">    new Thread(r2, &quot;thread2&quot;).start();</div><div class="line">    while (true) &#123;</div><div class="line">        if (counter.get() == 2) &#123;</div><div class="line">            printInfo(map, &quot;&quot;);</div><div class="line">            System.out.println(map.get(7));</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过阻塞<code>thread1</code>的<code>resize()</code>，再让<code>thread2</code>执行，并进行<code>resize()</code>操作之后，最后打印的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">size: 4</div><div class="line">tableLength: 8</div><div class="line">loadFactor: 0.75</div><div class="line">threshold: 6</div><div class="line">modCount: 4</div><div class="line">table:索引 | 元素</div><div class="line">	 0   | [8=A]</div><div class="line">	 1   | null</div><div class="line">	 2   | null</div><div class="line">	 3   | [3=A]</div><div class="line">	 4   | null</div><div class="line">	 5   | null</div><div class="line">	 6   | null</div><div class="line">	 7   | null</div><div class="line"></div><div class="line">null</div></pre></td></tr></table></figure><p>可见table的size为4，表明map经历了4次put过程，而实际上却只有两个元素，其他元素丢失了，那么接下来通过<code>IntellijIdea</code>的多线程断点调试来演示一下元素为什么丢失。</p></li><li><p>初始化一个调试环境</p><p><img src="http://op87q3xru.bkt.clouddn.com/gif/java%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E5%92%8C%E6%96%AD%E7%82%B9%E7%9A%84%E6%8C%82%E8%B5%B7%E6%A8%A1%E5%BC%8F.gif" alt="image"></p></li><li><p>用debug调试模拟多线程切换的流程</p><p><img src="http://op87q3xru.bkt.clouddn.com/gif/java%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug%E8%B0%83%E8%AF%95.gif" alt="image"></p><ol><li>点击debug按钮，这时断点会走到<code>thread1</code>处；</li><li>将<code>HashMap.resize(){next=e.next}</code>处打上断点，并设置挂起模式为thread。</li><li>接着开始执行thread1，这时thread1线程会停到刚才的断点处，相当于挂起thread1。</li><li>切换到thread2，并取消第2步设置的断点，让thread2能够一次性运行结束，并进行resize()过程。</li><li>thread2线程执行结束后，唤醒thread1，让thread1继续执行。</li><li>最后，通过打印的结果可知，数据丢失了。</li></ol></li><li><p>分析</p><p>通过分析<code>resize()</code>的源码可知，每次是让<code>table</code>指向一个<code>newTab</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">······</div><div class="line">threshold = newThr;</div><div class="line">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">table = newTab;</div><div class="line">······</div></pre></td></tr></table></figure><p>接着遍历<code>oldTab</code>，将原有的key-value存到<code>newTab</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line">                if ((e = oldTab[j]) != null) &#123;</div><div class="line">······</div><div class="line"></div><div class="line">if (loTail != null) &#123;</div><div class="line">    loTail.next = null;</div><div class="line">    newTab[j] = loHead;</div><div class="line">&#125;</div><div class="line">if (hiTail != null) &#123;</div><div class="line">    hiTail.next = null;</div><div class="line">    newTab[j + oldCap] = hiHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的<strong>第三步</strong>，<code>thread1</code>执行到<code>next = e.next</code>这挂起，接着唤醒<code>thread2</code>去执行，<code>thread2</code>把[8=A]放进map之后，也会执行resize()操作，这时会将 <code>table</code> 指向一个新的<code>newTab</code>，那么<code>thread1</code>的<code>newTab</code>将会失去引用，所以之前存储的值也就丢失了。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因此，在多线程环境中，使用<code>ConcurrentHashMap</code>替换<code>HashMap</code>，或者使用<code>Collections.synchronizedMap</code>将<code>HashMap</code>包装起来。</p><h2 id="JDK8和JDK7的HashMap性能对比"><a href="#JDK8和JDK7的HashMap性能对比" class="headerlink" title="JDK8和JDK7的HashMap性能对比"></a>JDK8和JDK7的HashMap性能对比</h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。</p><h3 id="Hash比较均匀的情况"><a href="#Hash比较均匀的情况" class="headerlink" title="Hash比较均匀的情况"></a>Hash比较均匀的情况</h3><ol><li><p>编写一个Key类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"> </div><div class="line">    private final int value;</div><div class="line"> </div><div class="line">    Key(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int compareTo(Key o) &#123;</div><div class="line">        return Integer.compare(this.value, o.value);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        if (this == o) return true;</div><div class="line">        if (o == null || getClass() != o.getClass())</div><div class="line">            return false;</div><div class="line">        Key key = (Key) o;</div><div class="line">        return value == key.value;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同。</p></li><li><p>创建Keys类，用于缓存Key，避免频繁的GC，而影响HashMap实际查找值的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Keys &#123;</div><div class="line"> </div><div class="line">    public static final int MAX_KEY = 10_000_000;</div><div class="line">    private static final Key[] KEYS_CACHE = new Key[MAX_KEY];</div><div class="line"> </div><div class="line">    static &#123;</div><div class="line">        for (int i = 0; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = new Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static Key of(int value) &#123;</div><div class="line">        return KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……、10000000）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void test(int mapSize) &#123;</div><div class="line"> </div><div class="line">       HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">       for (int i = 0; i &lt; mapSize; ++i) &#123;</div><div class="line">           map.put(Keys.of(i), i);</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       long beginTime = System.nanoTime(); //获取纳秒</div><div class="line">       for (int i = 0; i &lt; mapSize; i++) &#123;</div><div class="line">           map.get(Keys.of(i));</div><div class="line">       &#125;</div><div class="line">       long endTime = System.nanoTime();</div><div class="line">       System.out.println(endTime - beginTime);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   public static void main(String[] args) &#123;</div><div class="line">       for(int i=10;i&lt;= 1000 0000;i*= 10)&#123;</div><div class="line">           test(i);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li><li><p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响，结果如下：</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="image"></p><h3 id="hash极不均匀的情况"><a href="#hash极不均匀的情况" class="headerlink" title="hash极不均匀的情况"></a>hash极不均匀的情况</h3></li><li><p>假设我们有一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"> </div><div class="line">    //...</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>仍然执行main方法，得出的结果如下表所示</p><p><img src="http://op87q3xru.bkt.clouddn.com/image/java/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="image"></p><p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，JDK1.8的HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li></ol></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"># java</a> <a href="/tags/HashMap/" rel="tag"># HashMap</a> <a href="/tags/红黑树/" rel="tag"># 红黑树</a> <a href="/tags/散列表/" rel="tag"># 散列表</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/repository/android-incremental-update-server-articles.html" rel="next" title="Android增量更新：服务器篇"><i class="fa fa-chevron-left"></i> Android增量更新：服务器篇</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/repository/classic-sort.html" rel="prev" title="8大经典排序算法总结">8大经典排序算法总结 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png" alt="落枫寒"><p class="site-author-name" itemprop="name">落枫寒</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特性"><span class="nav-number">1.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类继承关系图"><span class="nav-number">1.2.</span> <span class="nav-text">类继承关系图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部实现"><span class="nav-number">2.</span> <span class="nav-text">内部实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几个重要的属性"><span class="nav-number">2.1.</span> <span class="nav-text">几个重要的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储结构"><span class="nav-number">2.2.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心方法分析"><span class="nav-number">2.3.</span> <span class="nav-text">核心方法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据键值计算哈希桶数组的索引"><span class="nav-number">2.3.1.</span> <span class="nav-text">根据键值计算哈希桶数组的索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put方法"><span class="nav-number">2.3.2.</span> <span class="nav-text">put方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容机制"><span class="nav-number">2.3.3.</span> <span class="nav-text">扩容机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全性"><span class="nav-number">3.</span> <span class="nav-text">线程安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发的rehash过程"><span class="nav-number">3.1.</span> <span class="nav-text">并发的rehash过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方案"><span class="nav-number">3.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK8和JDK7的HashMap性能对比"><span class="nav-number">4.</span> <span class="nav-text">JDK8和JDK7的HashMap性能对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash比较均匀的情况"><span class="nav-number">4.1.</span> <span class="nav-text">Hash比较均匀的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash极不均匀的情况"><span class="nav-number">4.2.</span> <span class="nav-text">hash极不均匀的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="author" itemprop="copyrightHolder"><a href="http://www.vibrancy.cn">落枫寒</a>&nbsp;版权所有</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html><!-- rebuild by neat -->