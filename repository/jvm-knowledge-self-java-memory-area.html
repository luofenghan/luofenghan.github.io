<!-- build time:Wed Jul 05 2017 13:17:17 GMT+0800 (马来西亚半岛标准时间) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="java,jvm,运行时数据区,"><link rel="alternate" href="/atom.xml" title="唯有日月不灭" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="主要介绍了Java虚拟机内存的各个区域，及其作用、服务对象以及其中可能产生的问题。"><meta name="keywords" content="java,jvm,运行时数据区"><meta property="og:type" content="article"><meta property="og:title" content="JVM知识自查表——Java内存区域"><meta property="og:url" content="http://www.vibrancy.cn/repository/jvm-knowledge-self-java-memory-area.html"><meta property="og:site_name" content="唯有日月不灭"><meta property="og:description" content="主要介绍了Java虚拟机内存的各个区域，及其作用、服务对象以及其中可能产生的问题。"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvmJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E6%A0%88%E5%B8%A7%E7%9A%84%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84.svg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png"><meta property="og:updated_time" content="2017-06-17T11:14:08.748Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM知识自查表——Java内存区域"><meta name="twitter:description" content="主要介绍了Java虚拟机内存的各个区域，及其作用、服务对象以及其中可能产生的问题。"><meta name="twitter:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvmJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.vibrancy.cn/repository/jvm-knowledge-self-java-memory-area.html"><title>JVM知识自查表——Java内存区域 | 唯有日月不灭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">唯有日月不灭</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://www.vibrancy.cn/repository/jvm-knowledge-self-java-memory-area.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="落枫寒"><meta itemprop="description" content=""><meta itemprop="image" content="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="唯有日月不灭"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM知识自查表——Java内存区域</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-17T17:36:44+08:00">2017-06-17 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span></span><div class="post-description">主要介绍了Java虚拟机内存的各个区域，及其作用、服务对象以及其中可能产生的问题。</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="运行时数据区有哪些"><a href="#运行时数据区有哪些" class="headerlink" title="运行时数据区有哪些"></a>运行时数据区有哪些</h2><p>运行时数据区主要分为所有<strong>线程共享</strong>的数据区和<strong>线程隔离</strong>的数据区。</p><ol><li>线程共享的数据区主要包括<strong>方法区</strong>和<strong>Java堆</strong>；</li><li>线程隔离的数据区主要包括<strong>虚拟机栈</strong>、<strong>程序计数器</strong>和<strong>本地方法栈</strong>。</li></ol><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvmJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="image"></p><h2 id="什么是程序计数器以及他的用途"><a href="#什么是程序计数器以及他的用途" class="headerlink" title="什么是程序计数器以及他的用途"></a>什么是程序计数器以及他的用途</h2><p>程序计数器是一块较小的内存空间，它的用于<strong>当前线程</strong>执行字节码的<strong>信号指示器</strong>。字节码指示器通过<strong>改变</strong>这个计数器的值来选取下一个需要执行的字节码指令。</p><p>由于Java虚拟机的多线程是通过<strong>线程轮流切换</strong>并分配<strong>CPU执行时间</strong>来的方式来实现的，在一个时间片内，一个处理器只会执行一个线程指令。因此，为了在线程切换后能够恢复到正确的执行位置，每个线程都需要独立的程序计数器，互补影响，独立存储（这也是为什么程序计数器数据区是线程隔离的原因）。</p><h2 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h2><p>Java的虚拟机栈也是线程私有的，它的生命周期与线程相同。它描述的是Java方法执行的内存模型：每个方法执行的时候都会创建一个<strong>栈帧</strong>，每个方法从调用到执行完成的过程，就对应一个<strong>栈帧</strong>在虚拟机栈里面从<strong>入栈到出栈</strong>的过程。</p><p>Java虚拟机规范对虚拟机栈定义了两种异常情况</p><ol><li><strong>StackOverflowError</strong>：如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的最大深度，将抛出该异常。</li><li><strong>OutOfMemoryError</strong>：一般虚拟机可以动态扩展，如果扩展后也无法申请到足够内存时将抛出该异常。</li></ol><h2 id="什么是栈帧"><a href="#什么是栈帧" class="headerlink" title="什么是栈帧"></a>什么是栈帧</h2><p><strong>栈帧</strong>是用于支持虚拟机进行<strong>方法调用</strong>和<strong>方法执行</strong>的数据结构，它是虚拟机运行时数据区<strong>虚拟机栈</strong>的栈元素。栈帧中存储了方法的<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>和<strong>方法返回地址</strong>等信息。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/%E6%A0%88%E5%B8%A7%E7%9A%84%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84.svg" alt="image"></p><p>一个线程的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来讲，在活动线程中，<strong>只有栈顶的栈帧是有效的</strong>，称为“<strong>当前栈帧</strong>”，当前栈帧所关联的方法称为<strong>当前方法</strong>。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p><p>在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于虚拟机的具体实现。</p><h2 id="什么是局部变量表"><a href="#什么是局部变量表" class="headerlink" title="什么是局部变量表"></a>什么是局部变量表</h2><p>局部变量表是一组<strong>变量值存储空间</strong>，用于存放<strong>方法参数</strong>和方法内部定义的<strong>局部变量</strong>。</p><p>局部变量表所需要的<strong>空间大小</strong>会在程序编译期就完全确定下来，在方法的<strong>Code属性的max_locals数据项</strong>中存储了该方法所以需要分配的最大局部变量表的容量。局部变量表的容量以<strong>变量槽</strong>为最小单位，一般一个slot的长度为32位。对于64位的数据类型，虚拟机会以高位在前的方式为其分配<strong>两个连续的slot空间</strong>。由于局部变量表是建立在线程堆栈上，是线程私有的数据，无论读写两个连续的slot是否是原子操作，都<strong>不会引起数据安全问题</strong>。</p><h2 id="如何访问局部变量表"><a href="#如何访问局部变量表" class="headerlink" title="如何访问局部变量表"></a>如何访问局部变量表</h2><p>虚拟机通过<strong>索引定位的方式</strong>。因为变量在局部变量表中都是按照顺序来排列的，当参数表分配完毕后，再根据方法内部定义的局部变量顺序和作用域分配其余slot。如果是实例方法，那么在局部变量表中第0位索引的slot默认是方法所属对象的this引用。</p><h2 id="讲讲局部变量表的slot可重用特性"><a href="#讲讲局部变量表的slot可重用特性" class="headerlink" title="讲讲局部变量表的slot可重用特性"></a>讲讲局部变量表的slot可重用特性</h2><p>在方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码的PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的slot可以交由其他变量使用。</p><ol><li><p>如果执行GC时，变量还在作用域之内，那么无论如何都不会回收的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">        System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">垃圾收集结果：</div><div class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 66141K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 75% used [0x0000000081c00000,0x0000000085c97450,0x0000000087180000)</div><div class="line"> Metaspace       used 3175K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li><li><p>如果执行GC时，在变量的作用域之外，从代码逻辑上讲，placeholder已经不可能再被访问，但实际结果来看，这64MB的内存并没有被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">    &#125;</div><div class="line">    System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">垃圾收集结果：</div><div class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 66141K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 75% used [0x0000000081c00000,0x0000000085c97450,0x0000000087180000)</div><div class="line"> Metaspace       used 3175K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li><li><p>在变量的作用域之外，初始化另一个局部变量，此时执行GC，将会回收内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</div><div class="line">    System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">运行结果:</div><div class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 605K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c97440,0x0000000087180000)</div><div class="line"> Metaspace       used 3175K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li></ol><p>在第一次修改后，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保存着对他的关联。</p><h2 id="什么是操作数栈"><a href="#什么是操作数栈" class="headerlink" title="什么是操作数栈"></a>什么是操作数栈</h2><p>当一个方法刚刚开始执行的时候，这个方法的<strong>操作数栈是空的</strong>。在方法执行的过程中，会有各种字节码指令向操作数栈中<strong>写入和提取内容</strong>，也就是入栈和出栈操作。</p><p>操作数栈的最大深度也是在编译期就确定下来，记录到Code属性的max_stacks数据项中。</p><p>操作数栈的每一个元素可以是任意的Java数据类型。另外，操作数栈的<strong>元素类型</strong>必须与字节码的指令序列<strong>要求的类型</strong>严格匹配。</p><h2 id="什么是动态连接"><a href="#什么是动态连接" class="headerlink" title="什么是动态连接"></a>什么是动态连接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属<strong>方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态连接。</p><h2 id="什么是方法返回地址"><a href="#什么是方法返回地址" class="headerlink" title="什么是方法返回地址"></a>什么是方法返回地址</h2><p>当一个方法被执行后，有两种方式退出这个方法。</p><ol><li>执行引擎遇到任意一个<strong>方法返回的字节码指令</strong>，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>正常完成出口</strong>。</li><li>当方法执行遇到了异常，并且这个异常没有在方法体内得到处理，没有在本方法内的异常表中搜索到匹配的异常处理器，就会导致方法退出，这种退出的方式称为<strong>异常完成出口</strong>。</li></ol><p>当方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过<strong>异常处理器表</strong>决定，栈帧中一般不会保存这部分消息。</p><p>方法退出的过程实际上等同于把<strong>当前栈帧出栈</strong>，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用者指令后面的一条指令。</p><h2 id="什么是Java堆"><a href="#什么是Java堆" class="headerlink" title="什么是Java堆"></a>什么是Java堆</h2><p>Java堆是Java虚拟机所管理的内存中最大的一块，也是被所有线程共享的一块区域，在虚拟机启动时创建。此内存存在的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p><p>Java堆也是垃圾收集器管理的主要区域，因此很多时候也被称作“<strong>GC堆</strong>”（Garbage Collected Heap），Java堆会划分成很多区域</p><ul><li><p>从<strong>内存回收</strong>的角度来看</p><p>由于现在收集器基本采用的是<strong>分代收集算法</strong>，所以Java堆还可以细分为<strong>新生代</strong>和<strong>老年代</strong>，新生代还分有<code>Eden</code>、<code>FromSurvivor</code>和<code>ToSurvivor</code>空间。</p></li><li><p>从<strong>内存分配</strong>的角度来看，线程共享的Java堆会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p></li></ul><p>无论如何划分区域，都与存储内容无关，无论哪个区域，存储的都是对象实例，进一步划分是为了更好的回收内存，或者更快的分配内存。</p><p>另外，Java堆可以处于<strong>物理上不连续</strong>的内存空间中，只要<strong>逻辑上是连续</strong>的即可。在实现时，既可以实现固定大小的，也可以是扩展的。不过主流虚拟机都是按照<strong>可扩展</strong>来实现的（通过\(-Xmx\)和\(-Xms\)来控制）。如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出<strong>OutOfMemeoryError</strong>异常。</p><h2 id="什么是方法区"><a href="#什么是方法区" class="headerlink" title="什么是方法区"></a>什么是方法区</h2><p>方法区和Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p><p>Java虚拟机规范对这个区域的管理非常宽松，除了<strong>不需要连续的内存</strong>和可以选择<strong>固定大小或可扩展</strong>外，还可以选择<strong>不实现垃圾收集</strong>。不实现垃圾收集，并非数据进入方法区就如“永久代”的名字一样永久存在了，对这个区域的==内存回收目标==主要是针对<strong>常量池的回收</strong>和对<strong>类型的卸载</strong>。</p><p><strong>运行时常量池</strong>（Runtime Constant Pool）是方法区的一部分。Class文件中也有常量池（Constant Pool），Class文件中的<strong>常量池</strong>用于存放编译器生成的各种<strong>字面量</strong>、<strong>符号引用</strong>和<strong>翻译出来的直接引用</strong>，这部分内容将在==类加载后==存放到<strong>方法区的运行时常量池</strong>中。<strong>运行时常量池</strong>的相对于Class文件常量池的另一个重要特征就是<strong>具备动态性</strong>，在运行期间也能将<strong>新的常量</strong>放入池中，例如调用String类的\(intern()\)方法。当常量池无法申请到内存时会抛出\(OutOfMemeoryError\)异常。</p><h2 id="什么是直接内存"><a href="#什么是直接内存" class="headerlink" title="什么是直接内存"></a>什么是直接内存</h2><p>在JDK1.4中新加入的NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的\(DirectByteBuffer\)对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免在Java堆和Native堆中来回复制数据。</p><p>这部分内存也会导致\(OutOfMemoryError\)异常出现，虽然不会受到Java堆大小的限制，但是，既然是内存，则肯定会受到<strong>本机总内存的大小</strong>和<strong>处理器寻址空间</strong>的限制。</p><h2 id="如何去访问对象"><a href="#如何去访问对象" class="headerlink" title="如何去访问对象"></a>如何去访问对象</h2><p>对象访问在Java语言中无处不在，即使是最简单的访问，也会涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系。例如如下代码：<code>Object obj = new Object();</code></p><ul><li><strong>Object obj</strong>：这部分语义会反映到<strong>虚拟机栈的局部变量表</strong>中，作为一个reference类型数据存在。</li><li><strong>new Object()</strong>：这部分语义会反映到<strong>Java堆</strong>中，形成一块存储了Object类型所有实例数据值（对象中各个实例字段的数据）的<strong>结构化内存</strong>。另外，在Java堆中还必须包含能查找到此<strong>对象类型数据</strong>（如对象类型、父类、实现的接口、方法等）的<strong>地址信息</strong>，这些<strong>类型数据存储到方法区</strong>中。</li></ul><p>Java虚拟机规范规定了<strong>虚拟机栈的局部变量表</strong>中的reference类型为一个指向对象的引用，并没有定义这个引用应该通过<strong>哪种方式</strong>去定位，以及通过哪种方式去访问到Java堆中的对象的<strong>具体位置</strong>。不同的虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：</p><ul><li><p>使用句柄访问方式</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="image"></p><p>Java堆中将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了<strong>对象实例数据</strong>和<strong>类型数据</strong>各自的具体地址信息。</p><p><strong>使用句柄访问的优点</strong>：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中实例数据指针，而reference本身不许要被改变。</p></li><li><p>使用直接指针访问方式</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="image"></p><p>Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是<strong>对象的地址</strong>。</p><p><strong>使用直接指针访问方式的优点</strong>：速度更快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这种开销积少成多也是一项非常可观的成本。</p></li></ul><h2 id="内存分配参数解释"><a href="#内存分配参数解释" class="headerlink" title="内存分配参数解释"></a>内存分配参数解释</h2><table><thead><tr><th>参数名</th><th>用途</th></tr></thead><tbody><tr><td>-Xms</td><td>设置初始堆内存</td></tr><tr><td>-Xmx</td><td>设置最大可用内存，如果最大可用内存和初始内存相同，可以避免每次垃圾回收后重新分配内存</td></tr><tr><td>-Xss</td><td>设置每个线程的堆栈容量大小，理论上减少这个值能生成更多的线程</td></tr><tr><td>-Xoss</td><td>设置本地方法栈的大小</td></tr><tr><td>-XX:PermSize</td><td>设置方法区初始内存大小</td></tr><tr><td>-XX:MaxPermSize</td><td>设置方法区最大内存大小</td></tr><tr><td>-XX:MaxDirectMemorySize=10M</td><td>设置最大直接内存大小</td></tr></tbody></table><h2 id="如何实现Java堆溢出"><a href="#如何实现Java堆溢出" class="headerlink" title="如何实现Java堆溢出"></a>如何实现Java堆溢出</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证<strong>GC Roots到对象之间有可达路径</strong>来避免垃圾回收机制清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> Object());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">Dumping heap to java_pid12160.hprof ...</div><div class="line">Exception in thread &quot;main&quot; Heap dump file created [28125483 bytes in 0.211 secs]</div><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</div><div class="line">	at java.util.ArrayList.grow(ArrayList.java:261)</div><div class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</div><div class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</div><div class="line">	at java.util.ArrayList.add(ArrayList.java:458)</div><div class="line">	at com.cwc.test.jvm.test.HeapOOM.main(HeapOOM.java:14)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div></pre></td></tr></table></figure><h2 id="如何实现虚拟机栈和本地方法栈溢出"><a href="#如何实现虚拟机栈和本地方法栈溢出" class="headerlink" title="如何实现虚拟机栈和本地方法栈溢出"></a>如何实现虚拟机栈和本地方法栈溢出</h2><p>在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，\(-Xoss\)参数虽然存在，但实际上是无效的，栈容量只由\(-Xss\)参数设定。</p><ul><li><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出\(StackOverflowError\)异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss128k</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stackLength++;</div><div class="line">        stackLeak();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JavaVMStackSOF sof = <span class="keyword">new</span> JavaVMStackSOF();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            sof.stackLeak();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            System.out.println(<span class="string">"stack length:"</span> + sof.stackLength);</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  运行结果：</div><div class="line">  stack length:978</div><div class="line">  Exception in thread &quot;main&quot; java.lang.StackOverflowError</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10)</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">at com.cwc.test.jvm.test.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)</div><div class="line">···</div><div class="line">  	at com.cwc.test.jvm.test.JavaVMStackSOF.main(JavaVMStackSOF.java:18)</div><div class="line">  	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">  	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">  	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">  	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">  	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div></pre></td></tr></table></figure><p>结果表明：在<strong>单个线程</strong>下，无论是由于栈帧太大，还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是\(StackOverflowError\)异常。</p></li><li><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出\(OutOfMemoryError\)异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss2M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doNotStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    doNotStop();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</div><div class="line">        oom.stackLeakByThread();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<strong>多线程环境</strong>下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。因为，操作系统分配给每个进程的内存是有限制的，虚拟机提供参数来控制<strong>Java堆</strong>和<strong>方法区</strong>的这两部分内存的最大值。</p><p>假如剩余内存有2GB，减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存小，可以忽略。如果虚拟机进程本身耗费的内存在计算在内，剩下的内存就由<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>“瓜分”了。++每个线程分配到的栈容量越大，可以建立的线程数量自然就越少++，建立线程时就越容易把剩下的内存耗尽。</p><p>因此，如果是建立多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过<strong>减少最大堆</strong>和<strong>减少栈容量</strong>来换取更多的线程。</p></li></ul><h2 id="如何实现运行时常量池溢出"><a href="#如何实现运行时常量池溢出" class="headerlink" title="如何实现运行时常量池溢出"></a>如何实现运行时常量池溢出</h2><p>如果要向运行时常量池添加内容，最简单的方法就是使用\(String.intern()\)这个Native方法。由于运行时常量池分配在方法区内，我们可以通过\(-XX:permSize\)和\(-XX:MaxPermSize\)限制方法区的大小，从而间接限制其中的常量池容量。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        String s = <span class="string">"abc"</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            s += s;</div><div class="line">            list.add(s.intern());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space  </div><div class="line">    at java.lang.String.intern(Native Method)  </div><div class="line">    at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)</div></pre></td></tr></table></figure><p>从运行结果可看出，运行时常量池溢出，在\(OutOfMemoryError\)后面的提示信息“PermGen Space”，说明运行时常量池处于方法区。</p><h2 id="怎样实现方法区溢出"><a href="#怎样实现方法区溢出" class="headerlink" title="怎样实现方法区溢出"></a>怎样实现方法区溢出</h2><p>方法区用于存放Class的相关信息，如<strong>类名、访问修饰符、常量池、字段描述、方法描述</strong>等。对于这个区域的测试，基本思路是运行时<strong>产生大量的类</strong>去填满方法区，直到溢出。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">            enhancer.setSuperclass(OOMObject.class);</div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">            enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; methodProxy.invokeSuper(o, args));</div><div class="line">            enhancer.create();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾回收器回收掉，判定条件非常苛刻。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。在大量JSP或动态产生JSP文件的应用（JSP第一次运行会被编译为Java类）、基于OSGI的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）。</p><h2 id="怎样实现本机直接内存溢出"><a href="#怎样实现本机直接内存溢出" class="headerlink" title="怎样实现本机直接内存溢出"></a>怎样实现本机直接内存溢出</h2><p>DirectMemory容量可以通过\(-XX:MaxDirectMemorySize\)指定，如果不指定，则默认与Java堆的最大值(-Xmx指定)一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</div><div class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</div><div class="line"></div><div class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">            unsafe.allocateMemory(_1MB);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"># java</a> <a href="/tags/jvm/" rel="tag"># jvm</a> <a href="/tags/运行时数据区/" rel="tag"># 运行时数据区</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/repository/multi-thread-knowledge-self-concurrent-basic-theory.html" rel="next" title="多线程知识自查表——并发基础理论"><i class="fa fa-chevron-left"></i> 多线程知识自查表——并发基础理论</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/repository/jvm-knowledge-self-gc.html" rel="prev" title="JVM知识自查表——垃圾收集">JVM知识自查表——垃圾收集 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png" alt="落枫寒"><p class="site-author-name" itemprop="name">落枫寒</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">22</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时数据区有哪些"><span class="nav-number">1.</span> <span class="nav-text">运行时数据区有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是程序计数器以及他的用途"><span class="nav-number">2.</span> <span class="nav-text">什么是程序计数器以及他的用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是虚拟机栈"><span class="nav-number">3.</span> <span class="nav-text">什么是虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是栈帧"><span class="nav-number">4.</span> <span class="nav-text">什么是栈帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是局部变量表"><span class="nav-number">5.</span> <span class="nav-text">什么是局部变量表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何访问局部变量表"><span class="nav-number">6.</span> <span class="nav-text">如何访问局部变量表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#讲讲局部变量表的slot可重用特性"><span class="nav-number">7.</span> <span class="nav-text">讲讲局部变量表的slot可重用特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是操作数栈"><span class="nav-number">8.</span> <span class="nav-text">什么是操作数栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是动态连接"><span class="nav-number">9.</span> <span class="nav-text">什么是动态连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是方法返回地址"><span class="nav-number">10.</span> <span class="nav-text">什么是方法返回地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Java堆"><span class="nav-number">11.</span> <span class="nav-text">什么是Java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是方法区"><span class="nav-number">12.</span> <span class="nav-text">什么是方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是直接内存"><span class="nav-number">13.</span> <span class="nav-text">什么是直接内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何去访问对象"><span class="nav-number">14.</span> <span class="nav-text">如何去访问对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配参数解释"><span class="nav-number">15.</span> <span class="nav-text">内存分配参数解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现Java堆溢出"><span class="nav-number">16.</span> <span class="nav-text">如何实现Java堆溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现虚拟机栈和本地方法栈溢出"><span class="nav-number">17.</span> <span class="nav-text">如何实现虚拟机栈和本地方法栈溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现运行时常量池溢出"><span class="nav-number">18.</span> <span class="nav-text">如何实现运行时常量池溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎样实现方法区溢出"><span class="nav-number">19.</span> <span class="nav-text">怎样实现方法区溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎样实现本机直接内存溢出"><span class="nav-number">20.</span> <span class="nav-text">怎样实现本机直接内存溢出</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="author" itemprop="copyrightHolder"><a href="http://www.vibrancy.cn">落枫寒</a>&nbsp;版权所有</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html><!-- rebuild by neat -->