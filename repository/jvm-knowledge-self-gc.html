<!-- build time:Wed Jul 05 2017 13:17:17 GMT+0800 (马来西亚半岛标准时间) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="java,jvm,垃圾回收算法,垃圾收集器,"><link rel="alternate" href="/atom.xml" title="唯有日月不灭" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="主要介绍了Java虚拟机的垃圾回收算法和垃圾回收器。"><meta name="keywords" content="java,jvm,垃圾回收算法,垃圾收集器"><meta property="og:type" content="article"><meta property="og:title" content="JVM知识自查表——垃圾收集"><meta property="og:url" content="http://www.vibrancy.cn/repository/jvm-knowledge-self-gc.html"><meta property="og:site_name" content="唯有日月不灭"><meta property="og:description" content="主要介绍了Java虚拟机的垃圾回收算法和垃圾回收器。"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.jpg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvmSerial%E6%94%B6%E9%9B%86%E5%99%A8.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvmParNew%E6%94%B6%E9%9B%86%E5%99%A8.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm/Parallel%20Scavenge%20+%20old%20%E5%8A%9F%E8%BF%87%E8%BF%87%E7%A8%8B.png"><meta property="og:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><meta property="og:updated_time" content="2017-06-17T10:56:29.897Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM知识自查表——垃圾收集"><meta name="twitter:description" content="主要介绍了Java虚拟机的垃圾回收算法和垃圾回收器。"><meta name="twitter:image" content="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.vibrancy.cn/repository/jvm-knowledge-self-gc.html"><title>JVM知识自查表——垃圾收集 | 唯有日月不灭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">唯有日月不灭</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://www.vibrancy.cn/repository/jvm-knowledge-self-gc.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="落枫寒"><meta itemprop="description" content=""><meta itemprop="image" content="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="唯有日月不灭"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM知识自查表——垃圾收集</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-17T18:37:26+08:00">2017-06-17 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span></span><div class="post-description">主要介绍了Java虚拟机的垃圾回收算法和垃圾回收器。</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="垃圾收集器主要针对哪些区域进行内存回收"><a href="#垃圾收集器主要针对哪些区域进行内存回收" class="headerlink" title="垃圾收集器主要针对哪些区域进行内存回收"></a>垃圾收集器主要针对哪些区域进行内存回收</h2><p><strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>三个区域随线程而生，随线程而灭；</p><p>虚拟机栈中的<strong>栈帧</strong>随着方法的进入和退出有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性。</p><p><strong>java堆</strong>和<strong>方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在<strong>程序运行期间才能知道会创建那些对象</strong>，这部分内存的分配和回收都是动态的，垃圾收集所关注的是这部分内存。</p><h2 id="有哪些判断对象是否存活的算法"><a href="#有哪些判断对象是否存活的算法" class="headerlink" title="有哪些判断对象是否存活的算法"></a>有哪些判断对象是否存活的算法</h2><h3 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>Java中并没有选用引用计数器算法来管理内存，其中最主要的原因是很难解决对象之间的相互循环引用的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * JVM Args: -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _MB];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ReferenceCountingGC oA = <span class="keyword">new</span> ReferenceCountingGC();</div><div class="line">        ReferenceCountingGC oB = <span class="keyword">new</span> ReferenceCountingGC();</div><div class="line"></div><div class="line">        oA.instance = oB;</div><div class="line">        oB.instance = oA;</div><div class="line"></div><div class="line">        oA = <span class="keyword">null</span>;</div><div class="line">        oB = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        System.gc();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">2017-05-20T12:51:57.191+0800: 0.217: [GC (System.gc()) [PSYoungGen: 6758K-&gt;712K(38400K)] 6758K-&gt;720K(125952K), 0.0176237 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] </div><div class="line">2017-05-20T12:51:57.206+0800: 0.219: [Full GC (System.gc()) [PSYoungGen: 712K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;591K(87552K)] 720K-&gt;591K(125952K), [Metaspace: 3014K-&gt;3014K(1056768K)], 0.0081622 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] </div><div class="line">Heap</div><div class="line"> PSYoungGen      total 38400K, used 998K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</div><div class="line">  eden space 33280K, 3% used [0x00000000d5f00000,0x00000000d5ff9b70,0x00000000d7f80000)</div><div class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</div><div class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</div><div class="line"> ParOldGen       total 87552K, used 591K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</div><div class="line">  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c93ff0,0x0000000087180000)</div><div class="line"> Metaspace       used 3037K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 330K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>当把\(oA\)和\(oB\)对两个对象的引用置空时，这两个对象已经不可能再被访问，但是这两个对象内部还互相引用着对方，导致他们的引用计数器不为0，于是引用计数器算法无法通知计数器回收他们。</p><p>但是通过运行结果\(6758K-&gt;720K\)可知，虚拟机并没有因为这两个对象互相引用就不回收他们，从侧面说明了虚拟机并<strong>不是通过引用计数算法</strong>来判断对象是否存活的。</p><h3 id="根搜索算法（GC-Roots-Tracing）"><a href="#根搜索算法（GC-Roots-Tracing）" class="headerlink" title="根搜索算法（GC Roots Tracing）"></a>根搜索算法（GC Roots Tracing）</h3><p>通过定义一系列名为\(GC\ Roots\)对象作为起点，从起点向下搜索，搜索所走过的路径称为<strong>引用链</strong>。当一个对象到\(GC\ Roots\)没有任何引用链相连时，则证明此对象是不可用的。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.jpg" alt="image"></p><p>如上图所示，对象\(object5,object6,object7\)虽然有关联，但是他们到\(GC\ Roots\)是不可达的，所以他们将会被判定为可回收的对象。</p><p>在Java中，可被作为\(GC\ Roots\)对象包括以下几种：</p><ul><li>虚拟机栈（栈帧中的<strong>局部变量表</strong>）中的引用的对象；</li><li>本地方法栈中<strong>JNI</strong>的引用的对象；</li><li>方法区中的<strong>类静态属性</strong>引用的对象；</li><li>方法区中的<strong>常量</strong>引用的对象。</li></ul><h2 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h2><p>Java对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>四种，这四种引用强度<strong>依次逐渐减弱</strong>。</p><ul><li><strong>强引用</strong>：指在程序代码之中普遍存在的，类似\(Object\ obj = new\ Object()\)这类引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。</li><li><strong>软引用</strong>：用来描述一些还有用，但是非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中，并进行第二次回收。如果这次回收之后没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用</strong>：用来描述非必须的对象，被弱引用关联的对象只能生存到<strong>下一次垃圾收集发生之前</strong>，不论内存是否足够，都会回收掉弱引用关联的对象。</li><li><strong>虚引用</strong>：最弱的一种引用，无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的<strong>唯一目的</strong>就是希望能在这个对象被回收时收到一个系统通知。</li></ul><h2 id="finalize-终结方法"><a href="#finalize-终结方法" class="headerlink" title="finalize()终结方法"></a>finalize()终结方法</h2><p>根搜索算法中的不可达对象，至少要经历两次标记过程，才会真正宣告死亡。如某个果对象在进行根搜索后发现没有与\(GC\ Roots\)相连接的引用链，那它将会被第一次标记并且进行一次筛选。</p><p>筛选的条件是此对象是否有必要执行\(finalize()\)方法，如果该方法<strong>已执行过</strong>或<strong>没有覆盖</strong>，则虚拟机将这两种情况视为“没有必要执行”。</p><ul><li>如果没有必要执行，那么进行回收；</li><li>如果有必要执行，那么该对象被放置在一个名为\(F-Queue\)的队列中，并在稍后由一条有虚拟机自动建立、低优先级的\(Finalizer\)线程去执行。\(finalize()\)方法是对象逃脱死亡的最后一次机会，稍后GC将对\(F-Queue\)中的对象进行第二次小规模的标记，如果对象在\(finalize()\)方法中重新被引用，那么在第二次标记时它将被移除“<strong>即将回收的集合</strong>”；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"yes. i am still alive :)"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">super</span>.finalize();</div><div class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</div><div class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        System.gc();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">500</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        System.gc();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">500</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">finalize method executed!</div><div class="line">yes. i am still alive :)</div><div class="line">no, i am dead :(</div></pre></td></tr></table></figure><p>根据执行结果可知，任何对象的\(finalize()\)方法都只会被系统自动调用一次，如果对象面临下一次回收，它的\(finalize()\)方法不会被再次执行。</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>Java虚拟机规范中提到过可以不要求虚拟机在<strong>方法区</strong>或<strong>堆的永久代</strong>实现垃圾收集，因为在此区域进行垃圾收集的“<strong>性价比</strong>”一般比较低；</p><p>在堆中，对新生代进行一次垃圾收集一般可以回收\(70\%-90\%\)的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代的垃圾收集主要分为两部分内容：</p><ul><li><strong>废弃常量</strong>：是指在常量池中的常量不被任何地方引用，那么这个常量将被系统移除常量池。</li><li><p><strong>无用的类</strong>：判定一个类是否无用条件相对苛刻，需要满足以下三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的ClassLoader已经被回收；</li><li><p>该类对应的\(java.lang.Class\)对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>当一个类满足以上三个条件之后，虚拟机可以对其进行回收，但不像对象一样，不使用了就必然回收。是否对类进行回收，HotSpot虚拟机提供了\(-Xnoclassgc\)参数进行控制，还可以使用\(-verbose:class\)以及\(-XX:+TraceClassLoading\)、\(-XX:+TraceClassUnLoading\)查看类的加载和卸载信息。</p><p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景，都需要虚拟机具备<strong>类卸载功能</strong>，以保证永久代不会溢出。</p></li></ul></li></ul><h2 id="有哪些垃圾收集算法，原理及优缺点"><a href="#有哪些垃圾收集算法，原理及优缺点" class="headerlink" title="有哪些垃圾收集算法，原理及优缺点"></a>有哪些垃圾收集算法，原理及优缺点</h2><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><ol><li><p>算法思想：</p><p>首先<strong>标记</strong>处所有需要回收的对象，在标记完成后<strong>统一回收</strong>掉所有被标记的对象。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p></li><li><p>缺点</p><ul><li><strong>效率问题</strong>：标记和清除的过程效率不高；</li><li><strong>空间问题</strong>：标记清除后产生大量<strong>不连续的内存碎片</strong>。空间碎片太多，会导致程序以后运行过程中需要分配较大对象时无法找到足够的连续内存空间而不得不提前触发另一次垃圾收集动作。</li></ul></li></ol><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><ol><li><p>算法思想</p><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完后，就将<strong>还存活着的对象</strong>复制到另一块上去，然后再把已使用过的内存空间一次清理掉。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p></li><li><p>优点</p><p>内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效；</p></li><li><p>缺点</p><ul><li>将内存缩小为原来的一般，代价太高；</li><li>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率会变低。</li></ul></li><li><p>算法改进</p><p>新生代的对象98%都是朝生夕死的，所以并不需要按照\(1:1\)的比例来划分内存空间，而是将内存分为一块较大的\(Eden\)空间和两块较小的\(Survivor\)空间，每次使用\(Eden\)和其中的一块\(Survivor\)空间。当回收时，将\(Eden\)和\(Survivor\)上还存活的对象一次性拷贝到另外一块\(Survivor\)空间上，最后清理\(Eden\)和刚使用的\(Survivor\)空间。</p><p>HotSpot虚拟机默认\(Eden\)和\(Survivor\)的大小比例是\(8:1\)，也就是说，新生代可用空间为整个新生代容量的\(90\%\)，只有\(10\%\)的空间是浪费的。但是也没办法保证每次回收都只有不多于\(10\%\)的对象存活，当\(Survivor\)空间不够用时，需要依赖其他内存（老年代）进行分配担保。</p></li></ol><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>主要用于<strong>老年代</strong>，标记操作和“标记-清除”算法一致，但后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向<strong>一端移动</strong>，并更新引用其对象的指针。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="image"></p><h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h3><p>当前商业虚拟机的垃圾收集都采用“<strong>分代收集</strong>”算法，根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样可以根据各个年代的特点采用<strong>最适当的收集算法</strong>。</p><ul><li>在新生代：每次垃圾收集都有大量的对象死去，只有少量的存活，那么就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</li><li>在老年代：因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“<strong>标记-清理</strong>”或“<strong>标记-整理</strong>”算法来进行回收。</li></ul><h2 id="有哪些垃圾收集器，以及各自的特点"><a href="#有哪些垃圾收集器，以及各自的特点" class="headerlink" title="有哪些垃圾收集器，以及各自的特点"></a>有哪些垃圾收集器，以及各自的特点</h2><p>下图展示了7种不同分代的收集器，如果两个收集器之间存在连线，说明他们可以搭配使用。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><h3 id="Serial收集器（串行收集器）"><a href="#Serial收集器（串行收集器）" class="headerlink" title="Serial收集器（串行收集器）"></a>Serial收集器（串行收集器）</h3><p>Serial收集器是一个单线程收集器，这里说单线程并不是说只会使用一个CPU或一条收集线程去完成垃圾收集工作，而是说他在垃圾收集的时候，必须<strong>暂停其他所有的工作线程</strong>，直到收集结束。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvmSerial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>不过，Serial收集器依然是虚拟机运行在<strong>Client模式</strong>下的默认新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于<strong>没有线程交互的开销</strong>，专心做垃圾收集自然可以获得最高的<strong>单线程收集效率</strong>。</p><h3 id="ParNew收集器（并行新生代收集器）"><a href="#ParNew收集器（并行新生代收集器）" class="headerlink" title="ParNew收集器（并行新生代收集器）"></a>ParNew收集器（并行新生代收集器）</h3><p>ParNew收集器是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial完全一样。</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvmParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>ParNew收集器是运行在Server模式下的虚拟机中的<strong>首选新生代收集器</strong>。另外，它还能与CMS收集器（Concurrent Mark Sweep）配合工作，<strong>CMS收集器</strong>是HoSpot虚拟机中第一款真正意义上的==并发==收集器，实现了垃圾收集线程与用户线程同时工作。</p><h3 id="Parallel-Scavenge收集器（并行扫描式收集器）"><a href="#Parallel-Scavenge收集器（并行扫描式收集器）" class="headerlink" title="Parallel Scavenge收集器（并行扫描式收集器）"></a>Parallel Scavenge收集器（并行扫描式收集器）</h3><p>Parallel Scavenge收集器也是一个新生代收集器，是使用<strong>复制算法</strong>的收集器，又是<strong>并行的多线程</strong>收集器。</p><p>Parallel Scavenge收集器的特点是他<strong>关注点</strong>与其他收集器不同：</p><ul><li>\(CMS\)收集器关注点尽可能缩短垃圾收集器时用户线程的停顿时间；停顿时间越短，就越适合与用户交互的程序，良好的响应速度能够提升用户体验；</li><li>\(Parallel\ Scavenge\)收集器的目标则是达到一个可控制的<strong>吞吐量</strong>。所谓吞吐量就是CPU用于<strong>运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值，即\(thruput=\tfrac{T(code\ run)}{T(code\ run)+T(gc)}\)。如果虚拟机总运行时间为100分钟，其中垃圾收集花掉1分钟，那么吞吐量就是\(99\%\)。高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li></ul><p>Parallel Scavenge收集器提供的调节参数：</p><ul><li><strong>-XX:MaxGCPauseMills</strong>：控制最大垃圾收集停顿时间；</li><li><strong>-XX:GCTimeRatio</strong>：直接设置吞吐量大小。</li><li><strong>-XX:+UseAdaptiveSizePolicy</strong>：这是一个开关参数，当打开时，就不需要手工指定新生代的大小(-Xmn)、Eden与Suvivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供共最适合的停顿时间或最大吞吐量，这种方式称为<strong>GC自适应的调节策略</strong>。</li></ul><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用“<strong>标记-整理</strong>”算法，主要使用在Client模式下的虚拟机。</p><p>如果在Server模式下，Serial Old有两个用途：</p><ul><li>在jdk1.5之前版本中与Parallel Scvenge收集器搭配使用；</li><li>作为CMS收集器的后备 预案，在并发收集发生Concurrent Mode Failure的时候使用。</li></ul><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和“<strong>标记-整理</strong>”算法。</p><p>在<strong>吞吐量</strong>以及<strong>CPU资源敏感</strong>的场合，都可以优先考虑\(Parallel\ Scavenge+Parallel Old\)收集器。Parallel Old收集器的工作过程如图所示：</p><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/Parallel%20Scavenge%20+%20old%20%E5%8A%9F%E8%BF%87%E8%BF%87%E7%A8%8B.png" alt="image"></p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。CMS收集器非常适合基于B/S系统的服务器上，系统停顿时间更短，给用户带来较好的体验。</p><ol><li><p>CMS收集器是基于“<strong>标记-清除</strong>”算法实现的，它的运作过程分为4个步骤：</p><ul><li>初始标记（CMS initial mark）<ul><li>需要“Stop The World”</li><li>标记一下GC Roots能直接关联到的对象，速度很快。</li></ul></li><li>并发标记（CMS concurrent mark）<ul><li>耗时长</li><li>进行GCRoots Tracing的过程；</li></ul></li><li>重新标记（CMS remark）<ul><li>需要“Stop The World”，但比初始标记停止时间短。</li><li>为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</li></ul></li><li><p>并发清除（CMS concurrent sweep）</p><ul><li>耗时长</li></ul><p><img src="http://op87q3xru.bkt.clouddn.com/java/images/jvm/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image"></p></li></ul></li><li>CMS的缺点<ul><li>CMS收集器对CPU资源非常敏感<ul><li>在并发阶段，虽然不会导致用于线程停顿，但会因为占用了一部分线程（CPU资源）而导致应用程序变慢，总吞吐量降低。</li><li>CMS默认启动的回收线程数是\((CPU+3)/4\)。当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过\(25\%\)的CPU资源。但当CPU不足4个时，那么CMS对用于程序的影响可能变得很大。</li></ul></li><li>CMS收集器无法处理浮动垃圾<ul><li>因为收集线程和用户线程并发执行，伴随着程序的执行自然还会有新的垃圾不断产生，CMS无法在本次收集中处理掉他们。</li><li>CMS不能像其他收集器那样等到老年代几乎完全被填满再进行收集，需要预留一<strong>部分空间</strong>提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了\(68\%\)的空间后就会被激活。这是一个保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数\(-XX:CMSInitiatingOccupancyFraction\)的值来提高触发百分比，以便降低内存回收次数获取更好的性能。</li><li>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次\(Concurrent\ Mode\ Failure\)失败，这时候虚拟机将启动后备源：临时启用\(Serial\ Old\)收集器，重新进行老年代的垃圾收集，这样停顿的时间就长了。所以说，参数\(-XX:CMSInitiatingOccupancyFraction\)设置的太高将会很容易导致大量的\(Concurrent\ Mode\ Failure\)失败，性能反而下降。</li></ul></li><li>会产生大量的空间碎片<ul><li>因为CMS收集器是基于“<strong>标记-清除</strong>”算法，收集结束后会产生大量的空间碎片。空间碎片过多时，将会给<strong>大对象分配</strong>带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是<strong>无法找到足够大的连续空间</strong>来分配当前对象，不得不提前触发一次Full GC。</li><li>为了解决CMS产生碎片的问题，CMS收集器提供了参数\(-XX:+UseCMSCompactAlFullCollection\)，用于启用在Full GC完后，额外进行一个碎片整理过程。不过内存整理是无法并发的，空间碎片问题没有了，但是停顿时间变长了。因此，可以使用另一个参数\(-XX:CMSFullGCsBeforeCompaction\)，用于设置在执行了多少次不压缩的Full GC后，跟着来一次带压缩的。</li></ul></li></ul></li></ol><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器是基于“<strong>标记-整理</strong>”算法实现的收集器，也就是说不会产生空间碎片；</p><p>可以非常<strong>精确的控制停顿</strong>，既能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，达到了实时Java的来及收集器特征。</p><p>G1可以实现基本<strong>不牺牲吞吐量的前提</strong>下完成低停顿的内存回收，这是因为它能够极力地<strong>避免全区域的垃圾收集</strong>，之前的收集器进行收集的范围都是整个新生代或老年代。</p><p>而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立取余，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分以及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率</strong>。</p><h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td>虚拟机运行在Client模式下的默认值。使用\(Serial+Serial\ Old\)的收集器组合。</td></tr><tr><td>UseParNewGC</td><td>使用\(ParNew+Serial\ Old\)的收集器组合。</td></tr><tr><td>UseConcMarkSweepGC</td><td>使用\(ParNew+CMS+Serial\ Old\)的收集器组合。\(Serial\ Old\)作为CMS收集器出现\(Concurrent\ Mode\ Failure\)失败后的后备收集器使用。</td></tr><tr><td>UseParallelGC</td><td>虚拟机运行在Server模式下的默认值。使用\(Parallel\ Scavenge+Serial\ Old\)的收集器组合。</td></tr><tr><td>UseParallelOldGC</td><td>使用\(Parallel\ Scavenge+Parallel\ Old\)的收集器组合</td></tr><tr><td>SurvivorRatio</td><td>新生代中的Eden区域与Survivor区域的容量比值，默认为8，代表\(Eden:Survivor=8:1\)。</td></tr><tr><td>PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，大于这个参数的对象将直接在老年代分配。仅在使用Serial和ParNew时生效</td></tr><tr><td>MaxTenuringThreshold</td><td>晋升到老年代的对象年龄。每个对象在坚持过一次\(Minor\ GC\)后，年龄就+1，当超过这个值，就进入老年代。</td></tr><tr><td>UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄。</td></tr><tr><td>HandlePromotionFailure</td><td>是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况。</td></tr><tr><td>ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数</td></tr><tr><td>GCTimeRatio</td><td>GC时间占总时间的比率，默认为99，即允许\(1\%\)的GC时间。仅在使用\(Parallel\ Scavenge\)收集时生效</td></tr><tr><td>MaxGCPauseMills</td><td>设置GC的最大停顿时间，仅在使用\(Parallel\ Scavenge\)收集器时生效</td></tr><tr><td>CMSInitiatingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少次后触发垃圾收集，默认值为\(68\%\)，仅在使用CMS收集器时生效</td></tr><tr><td>UseCMDCompactAlFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用CMS收集器时生效</td></tr><tr><td>CMSFullGCsBeforeCompactions</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效。</td></tr></tbody></table><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><p>Java技术体系中提倡的自动内存管理最终可以归结为自动化解决两个问题：<strong>给对象分配内存</strong>以及<strong>回收分配给对象的内存</strong>。</p><p>对象的内存分配，往大的方向上讲，就是在<strong>堆</strong>上分配，对象主要分配在<strong>新生代的Eden区</strong>上，少数情况下也可能直接分配在<strong>老年代</strong>。分配的规则并不是百分之百固定，其细节取决于当前使用的是哪一种<strong>垃圾收集器组合</strong>，以及虚拟机中与内存相关的<strong>参数的设置</strong>。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次\(Minor\ GC\)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* JVM Args: -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</div><div class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        testAllocation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">[GC (Allocation Failure) [PSYoungGen: 7459K-&gt;712K(9216K)] 7459K-&gt;6864K(19456K), 0.0041970 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </div><div class="line">[Full GC (Ergonomics) [PSYoungGen: 712K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6739K(10240K)] 6864K-&gt;6739K(19456K), [Metaspace: 3080K-&gt;3080K(1056768K)], 0.0089859 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </div><div class="line">Heap</div><div class="line"> PSYoungGen      total 9216K, used 2212K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">  eden space 8192K, 27% used [0x00000000ff600000,0x00000000ff8290f0,0x00000000ffe00000)</div><div class="line">  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</div><div class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</div><div class="line"> ParOldGen       total 10240K, used 6739K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  object space 10240K, 65% used [0x00000000fec00000,0x00000000ff294d98,0x00000000ff600000)</div><div class="line"> Metaspace       used 3104K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 337K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>虚拟机参数设置解析：</p><ul><li><strong>-Xms20M</strong>：设置Java堆的大小为20M；</li><li><strong>-Xmx20M</strong>：Java堆不可扩展；</li><li><strong>-Xmn10M</strong>：Java堆中新生代的大小为10M，剩余10M分配给老年代；</li><li><strong>-XX:SurvivorRatio=8</strong>：决定了新生代中Eden与一个Survivor区的空间比例为\(8:1\)。</li><li><strong>-XX:+PrintGCDetails</strong>：虚拟机在垃圾收集时进行日志打印，并且在进程退出时输出当前内存各区域的分配情况。</li></ul><p>执行\(testAllocation()\)中分配\(allocation4\)对象的语句时会发生一次\(Minor\ GC\)，当GC完成后，内存总量则几乎没有减少，因为\(allocation1,2,3\)三个对象都是存活的，虚拟机没有找到可回收的对象。</p><p>GC发生 的原因是给allocation4分配内存的时候，发现Eden已经占用了6MB，剩余空间不足以分配allication4分配的内存时，因此发生了GC。</p><p>GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓大对象是指需要<strong>大量连续内存空间</strong>的Java对象，最典型的大对象是那种很长的<strong>字符串及数组</strong>。对于虚拟机来说，大对象是一个坏消息，尤其是短命的大对象。经常出现大对象容易导致内存还有不少空间的时候就<strong>提前触发垃圾收集以获取足够的连续空间</strong>来安置他们。</p><p>虚拟机提供一个\(-XX:PretenureSizeThreshold\)参数来控制，令大于这个设置值的对象直接在老年代分配。避免在Eden区及两个Survior区之间发生大量的内存拷贝，因为新生代采用复制算法收集内存。另外，<code>PretenureSizeThreshold</code>参数只对Serial 和ParNew两款收集器有效，Parallel Scavenge不认识这个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * -XX:+UseParNewGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:PretenureSizeThreshold=2097152</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PretenureSizeThresholdTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release</div><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 1315K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  16% used [0x00000000fec00000, 0x00000000fed48e40, 0x00000000ff400000)</div><div class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)</div><div class="line"> Metaspace       used 2927K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 320K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>可见运行结果，Eden空间几乎没有使用，而老年代10MB空间被使用了40%，也就是说4MB空间的allocation对象直接就分配在老年代中。</p><h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>虚拟机采用了分代收集的思想来管理内存，通过给每个对象定义一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将别移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区每熬过一次MinorGC，年龄就加1岁，当年龄超过\(-XX:MaxTenuringThreshold\)设置的值时，就会被晋升到老年代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</div><div class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</div><div class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</div><div class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">    allocation3 = <span class="keyword">null</span>;</div><div class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>设置\(-XX:MaxTenuringThreshold=1\)</p><p>allocation1对象需要256KB的内存空间，Survivor空间可以容纳。在第二次GC发生后，allocation1进入了老年代，新生代使用的GC内存后变成0KB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 4260K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0290f0, 0x00000000ff400000)</div><div class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 4959K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  48% used [0x00000000ff600000, 0x00000000ffad7cb8, 0x00000000ffad7e00, 0x0000000100000000)</div><div class="line"> Metaspace       used 3006K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 327K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li><li><p>设置\(-XX:MaxTenuringThreshold=15\)</p><p>第二次GC发生后，allocation1对象则还留在新生代Survivor空间，这时候新生代仍然有404KB的空间被占用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 4587K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff021ed8, 0x00000000ff400000)</div><div class="line">  from space 1024K,  34% used [0x00000000ff400000, 0x00000000ff458f20, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 4967K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  48% used [0x00000000ff600000, 0x00000000ffad9cb8, 0x00000000ffad9e00, 0x0000000100000000)</div><div class="line"> Metaspace       used 3075K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 334K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure></li></ul><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>其实为了更好的适应不同程序的内存状态，虚拟机并不总是要求对象的年龄必须达到\(MaxTenuringThreshold\)才能晋升老年代，如果在Survivor空间中<strong>相同年龄的对象大小</strong>总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</div><div class="line">    <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</div><div class="line">    <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</div><div class="line">    <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">    allocation4 = <span class="keyword">null</span>;</div><div class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">// GC</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line"> par new generation   total 9216K, used 4531K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</div><div class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff021f80, 0x00000000ff400000)</div><div class="line">  from space 1024K,  29% used [0x00000000ff400000, 0x00000000ff44ad78, 0x00000000ff500000)</div><div class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</div><div class="line"> tenured generation   total 10240K, used 5234K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</div><div class="line">   the space 10240K,  51% used [0x00000000ff600000, 0x00000000ffb1c948, 0x00000000ffb1ca00, 0x0000000100000000)</div><div class="line"> Metaspace       used 3060K, capacity 4494K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 333K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p></p><p>allocation1，allocation2对象都直接进入了老年代，没有等到15岁的临界接线。因为这两个对象加起来已经达到512KB，并且他们是同年的，满足同年对象达到Survivor空间一般的规则。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次<strong>晋升到老年代的平均大小</strong>是否大于老年代的剩余空间：</p><ul><li>如果大于，则改为直接进行一次Full GC。</li><li>如果小于，则查看\(HandlePromotionFailure\)设置是否允许担保失败<ul><li>如果允许，那只会进行Minor GC；</li><li>如果不允许，则要改为进行一次Full GC。</li></ul></li></ul></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"># java</a> <a href="/tags/jvm/" rel="tag"># jvm</a> <a href="/tags/垃圾回收算法/" rel="tag"># 垃圾回收算法</a> <a href="/tags/垃圾收集器/" rel="tag"># 垃圾收集器</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/repository/jvm-knowledge-self-java-memory-area.html" rel="next" title="JVM知识自查表——Java内存区域"><i class="fa fa-chevron-left"></i> JVM知识自查表——Java内存区域</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/repository/jvm-knowledge-self-class-loading.html" rel="prev" title="JVM知识自查表——类加载">JVM知识自查表——类加载 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png" alt="落枫寒"><p class="site-author-name" itemprop="name">落枫寒</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">22</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器主要针对哪些区域进行内存回收"><span class="nav-number">1.</span> <span class="nav-text">垃圾收集器主要针对哪些区域进行内存回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有哪些判断对象是否存活的算法"><span class="nav-number">2.</span> <span class="nav-text">有哪些判断对象是否存活的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数算法（Reference-Counting）"><span class="nav-number">2.1.</span> <span class="nav-text">引用计数算法（Reference Counting）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根搜索算法（GC-Roots-Tracing）"><span class="nav-number">2.2.</span> <span class="nav-text">根搜索算法（GC Roots Tracing）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的四种引用"><span class="nav-number">3.</span> <span class="nav-text">Java中的四种引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finalize-终结方法"><span class="nav-number">4.</span> <span class="nav-text">finalize()终结方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区的垃圾回收"><span class="nav-number">5.</span> <span class="nav-text">方法区的垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有哪些垃圾收集算法，原理及优缺点"><span class="nav-number">6.</span> <span class="nav-text">有哪些垃圾收集算法，原理及优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法（Mark-Sweep）"><span class="nav-number">6.1.</span> <span class="nav-text">标记-清除算法（Mark-Sweep）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法（Copying）"><span class="nav-number">6.2.</span> <span class="nav-text">复制算法（Copying）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法（Mark-Compact）"><span class="nav-number">6.3.</span> <span class="nav-text">标记-整理算法（Mark-Compact）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法（Generational-Collection）"><span class="nav-number">6.4.</span> <span class="nav-text">分代收集算法（Generational Collection）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有哪些垃圾收集器，以及各自的特点"><span class="nav-number">7.</span> <span class="nav-text">有哪些垃圾收集器，以及各自的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial收集器（串行收集器）"><span class="nav-number">7.1.</span> <span class="nav-text">Serial收集器（串行收集器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew收集器（并行新生代收集器）"><span class="nav-number">7.2.</span> <span class="nav-text">ParNew收集器（并行新生代收集器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge收集器（并行扫描式收集器）"><span class="nav-number">7.3.</span> <span class="nav-text">Parallel Scavenge收集器（并行扫描式收集器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old收集器"><span class="nav-number">7.4.</span> <span class="nav-text">Serial Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old收集器"><span class="nav-number">7.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器"><span class="nav-number">7.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1收集器"><span class="nav-number">7.7.</span> <span class="nav-text">G1收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器参数总结"><span class="nav-number">8.</span> <span class="nav-text">垃圾收集器参数总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配和回收策略"><span class="nav-number">9.</span> <span class="nav-text">内存分配和回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象优先在Eden分配"><span class="nav-number">9.1.</span> <span class="nav-text">对象优先在Eden分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大对象直接进入老年代"><span class="nav-number">9.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#长期存活的对象进入老年代"><span class="nav-number">9.3.</span> <span class="nav-text">长期存活的对象进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态对象年龄判定"><span class="nav-number">9.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间分配担保"><span class="nav-number">9.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="author" itemprop="copyrightHolder"><a href="http://www.vibrancy.cn">落枫寒</a>&nbsp;版权所有</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html><!-- rebuild by neat -->