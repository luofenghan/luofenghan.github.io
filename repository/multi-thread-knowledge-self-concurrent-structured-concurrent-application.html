<!-- build time:Sun Jun 18 2017 17:00:15 GMT+0800 (马来西亚半岛标准时间) --><!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="java,多线程,"><link rel="alternate" href="/atom.xml" title="唯有日月不灭" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="如何利用线程来提高并发应用程序的吞吐量或响应性，如何识别可并行的任务，如何取消或中断任务以及任务框架的一些更高级特性。"><meta name="keywords" content="java,多线程"><meta property="og:type" content="article"><meta property="og:title" content="多线程知识自查表——结构化并发应用程序"><meta property="og:url" content="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-structured-concurrent-application.html"><meta property="og:site_name" content="唯有日月不灭"><meta property="og:description" content="如何利用线程来提高并发应用程序的吞吐量或响应性，如何识别可并行的任务，如何取消或中断任务以及任务框架的一些更高级特性。"><meta property="og:updated_time" content="2017-06-18T08:59:54.239Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="多线程知识自查表——结构化并发应用程序"><meta name="twitter:description" content="如何利用线程来提高并发应用程序的吞吐量或响应性，如何识别可并行的任务，如何取消或中断任务以及任务框架的一些更高级特性。"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-structured-concurrent-application.html"><title>多线程知识自查表——结构化并发应用程序 | 唯有日月不灭</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">唯有日月不灭</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://www.vibrancy.cn/repository/multi-thread-knowledge-self-concurrent-structured-concurrent-application.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="落枫寒"><meta itemprop="description" content=""><meta itemprop="image" content="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="唯有日月不灭"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">多线程知识自查表——结构化并发应用程序</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-18T15:52:48+08:00">2017-06-18 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span></span><div class="post-description">如何利用线程来提高并发应用程序的吞吐量或响应性，如何识别可并行的任务，如何取消或中断任务以及任务框架的一些更高级特性。</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="为什么要创建线程"><a href="#为什么要创建线程" class="headerlink" title="为什么要创建线程"></a>为什么要创建线程</h2><p>例如在Web服务器中，在正常负载情况下，为每个任务分配一个线程，能够提升串行执行条件下的性能。只要请求的到达率不超出服务器的请求处理能力，那么这种方法可以同时带来<strong>更快的响应性</strong>和<strong>更高的吞吐率</strong>。</p><h2 id="为什么不能无限制创建线程"><a href="#为什么不能无限制创建线程" class="headerlink" title="为什么不能无限制创建线程"></a>为什么不能无限制创建线程</h2><ol><li><p>线程的生命周期的开销非常高</p><p>如果请求的到达速率非常高，且请求的处理过程是轻量级的，那么为每个请求创建一个新线程将消耗大量的计算资源。</p></li><li><p>资源消耗</p><p>如果可运行的线程数量<strong>多于可用处理器的数量</strong>，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。</p><p>如果已经有了足够多的线程，使所有CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。</p></li><li><p>稳定性</p><p>在可创建线程的<strong>数量上存在一个限制</strong>，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括<strong>JVM的启动参数</strong>、Thread构造函数中<strong>请求栈的大小</strong>，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出<strong>OutOfMemoryError异常</strong>。</p></li></ol><h2 id="简介Executor接口"><a href="#简介Executor接口" class="headerlink" title="简介Executor接口"></a>简介Executor接口</h2><p>Executor是一个简单的接口，它能够将<strong>任务提交</strong>与<strong>执行策略</strong>解耦开来，同时还支持多种不同类型的执行策略，并用Runnable来表示一个任务。通过将问题分解为多个独立的任务并发执行时，能够获得更高的<strong>CPU利用率</strong>和<strong>响应灵敏度</strong>。</p><p>Executor的实现还提供了生命周期的支持，以及统计信息的收集、应用程序管理机制和性能监视等机制。</p><p>Executor是基于<strong>生产者——消费者模式</strong>，提交任务的操作相当于生产者，执行任务的线程相当于消费者。</p><h2 id="Executor的执行策略"><a href="#Executor的执行策略" class="headerlink" title="Executor的执行策略"></a>Executor的执行策略</h2><p>在执行策略中定义了任务执行的“What”、“Where”、“When”、“How”等方面，包括：</p><ol><li>在什么（What）线程中执行任务？</li><li>任务按照什么（What）顺序执行（FIFO、LIFO、优先级）？</li><li>有多少个（How Many）任务能够并发执行？</li><li>在队列中有多少个（How Many）任务在等待执行？</li><li>如果系统过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？</li><li>在执行一个任务之前或之后，应该进行哪些（What）动作？</li></ol><p>因此，各种执行策略都是一种资源管理工具，最佳策略取决于<strong>可用的计算资源</strong>以及<strong>对服务质量的需求</strong>。</p><p>通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源上竞争而严重影响性能。</p><p>通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。</p><p>因此，当看到如下代码时<code>new Thread(runnable).start();</code>时。如果希望获得一种更灵活的执行策略时，考虑使用Executor来代替Thread。</p><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>线程池，是指管理<strong>一组同构工作</strong>线程的资源池。线程池是与工作队列密切相关的，工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并执行下一个任务。</p><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ol><li>通过<strong>重用现有的线程</strong>而不是创建新线程，可以在处理多个请求时<strong>分摊</strong>在线程创建和销毁过程中产生的<strong>巨大开销</strong>。</li><li>当请求到达时，工作线程已经存在，因此不会由于等待创建线程而延迟任务的执行，从而<strong>提高了响应性</strong>。</li><li>通过适当调整线程池大小，可以创建足够多的线程以便使<strong>处理器保持忙碌状态</strong>，同时还可以<strong>防止</strong>过多线程相互竞争资源而使应用程序<strong>耗尽内存或失败</strong>。</li></ol><h2 id="创建线程池的方法"><a href="#创建线程池的方法" class="headerlink" title="创建线程池的方法"></a>创建线程池的方法</h2><ol><li><strong>newFixedThreadPool</strong>：用于创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池最大数量，这时线程数量不再变化。</li><li><strong>newCachedThreadPool</strong>：用于创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求，那么将<strong>回收空闲的线程</strong>，而当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。</li><li><strong>newSingleThreadExecutor</strong>：是一个单线程的Executor，可创建单个工作者线程来执行任务，如果这个线程异常结束，能够创建另一个线程来替代。并且能够确保任务在队列中的顺序串行执行（例如FIFO、LIFO、优先级）。</li><li><strong>newScheduledThreadPool</strong>：创建一个固定长度的线程池，而且以<strong>延迟或定时</strong>的方式来执行任务，类似于Timer。</li></ol><h2 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h2><p>Executor的实现通常会创建线程来执行任务，而JVM只有在所有（非守护）线程全部终止后才会退出。因此，如果无法正确的关闭Executor那么<strong>JVM将无法结束</strong>。</p><p>由于Executor以异步的方式来执行任务，因此在任何时刻，之前提交任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他任务可能在队列中等待执行。因此，当关闭程序时，可能采用最<strong>平缓的</strong>关闭方式（完成所有已经启动的任务，并且不再接受新任务），也可能采用<strong>最粗暴</strong>的关闭形式（直接关掉机房的电源），以及其他各种可能的形式。</p><p>为了解决执行服务的生命周期问题，Executor扩展了<strong>ExecutorService接口</strong>，添加了生命周期管理的方法:</p><ul><li><strong>shutdown()方法</strong>用于执行平缓关闭的过程，不再继续接受新的任务，同时等待已经提交的任务执行完成——包括那些还未执行的任务。</li><li><strong>shutdownNow()方法</strong>将执行粗暴的关闭过程：尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</li></ul><p>在ExecutorService关闭后提交的任务将由“<strong>拒绝执行处理器</strong>”来处理，它将抛弃任务。或使得execute方法抛出一个未检查的RejectedExecutionException。等所有任务都执行完后，ExecutorService将进入<strong>终止状态</strong>。</p><p>可以调用<code>awaitTermination()</code>来等待ExecutorService到达终止状态，或者通过调用<code>isTerminated()</code>来轮询ExecutorService是否已经终止。通常在调用<code>shutdown()</code>后会立即调用<code>awaitTermination()</code>，从而产生同步关闭ExecutorService的效果。</p><h2 id="使用Timer实现延迟任务或周期任务的缺点"><a href="#使用Timer实现延迟任务或周期任务的缺点" class="headerlink" title="使用Timer实现延迟任务或周期任务的缺点"></a>使用Timer实现延迟任务或周期任务的缺点</h2><p>Timer类负责管理延迟任务以及周期任务，Timer在执行所有定时任务时只会创建一个线程，如果某个任务的执行时间过长，那么将破坏其他的TimeTask的定时精确性。</p><p>另一个问题，因为Timer线程不会捕获异常，那么当TimerTask抛出未检查的异常时将终止定时线程。Timer也不会恢复线程的执行，而是错误的认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度。</p><p>线程池能够弥补这个缺陷，因此应该考虑使用<strong>ScheduledThreadPoolExecutor</strong>的构造函数或者<strong>newScheduledThreadPool工厂方法</strong>来创建该类的对象，可以提供多个线程来执行<strong>延时任务</strong>和<strong>周期任务</strong>。</p><h2 id="谈谈对Callable与Future的理解"><a href="#谈谈对Callable与Future的理解" class="headerlink" title="谈谈对Callable与Future的理解"></a>谈谈对Callable与Future的理解</h2><p>Executor使用Runnable作为<strong>基本任务</strong>表示形式，但Runnable有一个很大的局限性，不能返回一个值或者抛出一个受检查的异常。而Callable是一个中更好的抽象，能够返回一个值，并可能抛出一个异常。</p><p>Runnable和Callable描述的都是抽象的计算任务，这些任务都是有范围的，都有一个明确的起点，并且最终会结束。</p><p>Future表示一个<strong>任务的生命周期</strong>，并提供相应的方法来判断是否<strong>已经完成</strong>或<strong>取消</strong>，以及<strong>获取任务的结果</strong>和<strong>取消任务</strong>等。可以通过许多种方法来创建一个Future来描述任务，ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的<strong>执行结果或取消任务</strong>。</p><p>Future.get()的行为<strong>取决于任务的状态</strong>（尚未开始、正在运行、已完成）</p><ul><li>如果任务已经完成，那么get会立即返回结果或抛出一个异常。</li><li>如果任务没有完成，那么get将阻塞并直到任务完成。</li><li>如果任务抛出异常，那么get将该异常封装为ExecutionException并重新抛出；</li><li>如果任务被取消，那么get将抛出CancellationException。</li><li>如果get抛出了ExecutionException，那么可以通过getCause来获得被封装的初始异常。</li></ul><p>另外，get方法拥有“<strong>状态依赖</strong>”的内在特性，因而调用者不需要知道任务的状态，此外在任务提交和获得结果中包含的安全发布属性也确保了这个方法是线程安全的.</p><h2 id="什么是任务取消，以及有哪些操作会取消任务"><a href="#什么是任务取消，以及有哪些操作会取消任务" class="headerlink" title="什么是任务取消，以及有哪些操作会取消任务"></a>什么是任务取消，以及有哪些操作会取消任务</h2><p>如果外部代码能在某个正常完成之前将其置入“完成”状态，那么这个操作就可以称为<strong>可取消的</strong>（Cancellable）,而取消一个操作的原因很多：</p><ol><li>用户请求取消；</li><li>有时间限制的操作；</li><li>应用程序事件；</li><li>错误；</li><li>关闭。</li></ol><h2 id="线程池中哪个阶段的任务可以取消"><a href="#线程池中哪个阶段的任务可以取消" class="headerlink" title="线程池中哪个阶段的任务可以取消"></a>线程池中哪个阶段的任务可以取消</h2><p>Executor执行的任务有4个生命周期阶段：创建、提交、开始和完成。Executor框架中，<strong>已提交但尚未开始</strong>的任务可以取消，但对于那些已经开始执行的任务，只有当他们能响应中断时，才能取消。已完成的任务不用取消。</p><h2 id="什么是任务取消策略"><a href="#什么是任务取消策略" class="headerlink" title="什么是任务取消策略"></a>什么是任务取消策略</h2><p>一个可取消的任务必须有<strong>取消策略</strong>（Cancellation Policy），在这个策略中将详细地定义取消操作的“How”、“When”和“What”，即</p><ul><li>其他代码<strong>如何</strong>（How）请求取消该任务；</li><li>任务在<strong>何时</strong>（When）检查是否已经请求了取消；</li><li>在响应取消请求时应该执行<strong>哪些</strong>（What）操作。</li></ul><h2 id="什么是线程中断，以及用途"><a href="#什么是线程中断，以及用途" class="headerlink" title="什么是线程中断，以及用途"></a>什么是线程中断，以及用途</h2><p>为某个任务设置<strong>已请求取消</strong>的标志，当任务下次检测到该标志后，从而使任务能够顺利的退出。然而，如果任务调用了一个<strong>阻塞方法</strong>，例如<code>BlockingQueue.put</code>，那么任务可能永远不会检查取消标志，因此永远不会结束。</p><p>Thread提供了一些<strong>中断线程</strong>以及<strong>查询线程中断状态</strong>的方法，每个线程都有一个boolean类型的中断状态。当需要中断线程时，调用<code>interrupt()</code>将这个线程的<strong>中断状态</strong>设置为true。然而，调用<code>interrupt()</code>并不意味着<strong>立即停止</strong>目标线程正在进行的工作，而只是传递了<strong>请求中断的消息</strong>，然后由线程在下一个合适的时刻中断自己。当他们收到中断请求后者在开始执行时发现某个已经被设置好的中断状态时，将抛出一个<strong>异常</strong>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 中断目标线程</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查询目标线程的中断状态</div><div class="line">     */    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清除线程的中断状态，并返回它之前的值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">iterrupted</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>阻塞库方法，例如<code>sleep()</code>、<code>wait()</code>和<code>join()</code>等，都会检查线程何时中断，并且在发现中断后<strong>提前返回</strong>。他们在响应中断时执行的操作：清除中断状态，抛出InterruptedException，<strong>表示阻塞操作由于中断而提前结束</strong>。</p><p>在使用静态的<code>interrupted()</code>时应该小心，因为它既可以得到上一次线程的中断标志值，又可以同时清除线程的中断标志。如果在调用interrupted过程中返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出InterruptedException，或者再次调用interrupt来恢复中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line">    </div><div class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</div><div class="line">        interrupt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当到达队列容量时，queue会阻塞，put内部会调用<code>LockSupport.park()</code>用来阻塞线程。当其他线程调用此线程的<code>interrupt()</code>方法时，会设置一个中断标志。当<code>LockSupport.part()</code>检测到这个标志时，会抛出InterruptedException，并清除线程的中断状态。因此，在InterruptedException的catch块，调用<code>Thread.currentThread().isInterrupted()</code>会返回false，因此可以在这里再次调用<code>Thread.currentThread().interrupt()</code>恢复中断状态。</p><h2 id="如何正确的处理InterruptedException"><a href="#如何正确的处理InterruptedException" class="headerlink" title="如何正确的处理InterruptedException"></a>如何正确的处理InterruptedException</h2><ol><li><strong>传递异常</strong>：在执行某个特定任务的<strong>清除操作之后</strong>，从而使你的方法也成为可中断的阻塞方法。</li><li><p><strong>恢复中断状态</strong>，从而使调用栈中的上层代码能够对其进行处理。</p><p>因此，只有实现了线程中断策略的代码才可以屏蔽中断请求，在常规的任务和库代码中都不应该屏蔽中断请求。</p><p>但是对于一些<strong>不支持取消</strong>但仍可以调用可中断阻塞方法的操作，他们必须在<em>循环中调用这些方法，并在发现中断后重新尝试</em>。在这种情况下，他们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获InterruptedException时恢复状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">return</span> queue.take();</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        <span class="keyword">if</span>(interrupted)&#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果<strong>过早的</strong>设置中断状态，可能引起<strong>无限循环</strong>，因为大多数可中断的阻塞方法都会在入口处检查中断状态，并且当发现该状态已被设置时会立即抛出InterruptedException。</p></li><li><p>如果代码<strong>不会调用可中断的阻塞方法</strong>，那么仍然可通过任务代码中轮询当前线程的中断状态来响应中断。要选择合适的轮询频率，就需要在效率和响应性之间进行权衡。如果响应性要求较高，那么不应该调用哪些执行时间较长并且不响应中断的方法。</p></li></ol><h2 id="如何处理非正常的线程终止"><a href="#如何处理非正常的线程终止" class="headerlink" title="如何处理非正常的线程终止"></a>如何处理非正常的线程终止</h2><p>导致线程提前死亡的原因是RuntimeException，由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此他们通常不会捕获。他们不会在调用栈中逐层传递，而是默认地在控制台中输出栈追踪信息，并终止线程。</p><ol><li><p>主动解决未检查异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void run()&#123;</div><div class="line">    Throwable thrown = null;</div><div class="line">    try&#123;</div><div class="line">        while(!isInterrupted())&#123;</div><div class="line">            runTask(getTaskFromWorkQueue());</div><div class="line">        &#125;</div><div class="line">    &#125; catch(Throwable e) &#123;</div><div class="line">        threadExited(this, thrown);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用UncaughtExceptionHandler</p><p>Thread API中提供了UncaughtExceptionHandler，能够检测出某个线程由于未捕获的异常而终结的情况。</p><p>当一个线程由于未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler异常处理器。如果没有提供任何异常处理器时，通过默认的异常处理器，将栈追踪信息输出到System.err中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GlobalUEHLogger implements Thread.UncaughtExceptionHandler &#123;</div><div class="line">    @Override</div><div class="line">    public void uncaughtException(Thread t, Throwable e) &#123;</div><div class="line">        Logger logger = Logger.getAnonymousLogger();</div><div class="line">        logger.log(Level.WARNING, &quot;Thread terminated with exception: &quot; + t.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在运行时间较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。</p><p>只有通过<strong>execute提交</strong>的任务，才能将它抛出的异常交给未捕获异常处理器，而通过<strong>submit提交的任务</strong>，无论是抛出的未检查异常还是已检查异常，都将被认为是任务返回状态的一部分。如果一个由submit提交的任务由于抛出异常而结束，那么这个异常将别Future.get封装在ExecutionException中重新抛出。</p></li></ol><h2 id="什么是关闭钩子"><a href="#什么是关闭钩子" class="headerlink" title="什么是关闭钩子"></a>什么是关闭钩子</h2><p>关闭钩子是指通过<code>Runtime.addShutdownHook()</code>注册的但尚未开始的线程。</p><ol><li><p>用途</p><ul><li>关闭钩子能够实现服务或应用程序的清理工作，例如删除临时文件夹，或清除无法由操作系统自动清除的资源。</li></ul></li><li><p>特点</p><ul><li>JVM不能保证关闭钩子的调用顺序，在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。</li><li>当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true，那么JVM将运行终结器，然后再停止。</li><li>关闭钩子应该是线程安全的，在访问共享数据时必须使用同步机制，并且小心地避免死锁。因此，关闭钩子不应该依赖那些可能被应用程序或其他关闭钩子关闭的服务，实现这种功能的方式是<strong>对所有服务使用同一个关闭钩子</strong>，并且在该关闭钩子中执行一系列的关闭操作。确保了关闭操作在单个线程中串行执行，从而避免了在关闭操作之间出现竞态条件或者死锁等问题。</li><li>关闭钩子应该<strong>尽快退出</strong>，因为会延迟JVM的结束时间。</li></ul></li></ol><h2 id="普通进程与守护线程之间的差异"><a href="#普通进程与守护线程之间的差异" class="headerlink" title="普通进程与守护线程之间的差异"></a>普通进程与守护线程之间的差异</h2><p>普通进程与守护线程之间的差异仅在于当<strong>线程退出时发生的操作</strong>。</p><p>当一个线程退出时，JVM或检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。</p><p>因此，应该尽可能少使用守护线程，如果在守护线程中执行可能包含IO操作的任务，那么将是一种危险行为。守护线程最好用于执行内部任务，例如周期性地从内存的缓存中移除逾期的数据。</p><h2 id="异构任务并行中存在哪些局限性"><a href="#异构任务并行中存在哪些局限性" class="headerlink" title="异构任务并行中存在哪些局限性"></a>异构任务并行中存在哪些局限性</h2><ol><li>很难找出任务之间细粒度的并行性，异构任务的并发带来的好处将减少；</li><li>各个<strong>任务的大小</strong>可能完全不同，那么任务执行的最长时间取决于任务最大的那个，可能从中获得的并发性十分有限；</li><li>需要一定的<strong>任务协调开销</strong>，为了使任务分解能够提高性能，这种开销不能高于并行实现的性能提升；</li></ol><p>因此，只有当大量<strong>相互独立且同构的任务</strong>可以并发进行处理，才能体现出将程序的工作负责分配到多个任务中带来的真正性能提升。</p><h2 id="CompletionService的作用"><a href="#CompletionService的作用" class="headerlink" title="CompletionService的作用"></a>CompletionService的作用</h2><p>如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后遍历get方法，从而通过轮询判断任务是否完成。这种方法虽然可行，但是繁琐。</p><p>CompletionService将Executor和BlockingQueue的功能融合到了一块，可以将Callable任务提交给Executor执行，然后使用类似于队列操作的take和poll等方法，从BlockingQueue获得已完成的结果，而这些结果会在完成时将被封装为Future。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Renderer</span><span class="params">(ExecutorService executor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span></span>&#123;</div><div class="line">        List&lt;ImageInfo&gt; imageInfos =scanForImageInfo(source);</div><div class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">final</span> ImageInfo imageInfo:imageInfos)&#123;</div><div class="line">            completionService.submit(imageInfo::downloadImage);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        renderText(source);</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">           <span class="keyword">for</span>(ImageInfo info:imageInfos)&#123;</div><div class="line">               Future&lt;ImageData&gt; imageDataFuture = completionService.take();</div><div class="line">               ImageData imageData = imageDataFuture.get();</div><div class="line">               renderImage(imageData);</div><div class="line">           &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个Executor的ExecutorCompletionService。因此，ExecutorCompletionService相当于一组计算的句柄，代表了一组计算的分类，这与单个Future作为单个句柄是非常类似的。</p><p>另外，通过<strong>记录</strong>提交给CompletionService的任务数量，并计算已经获得的<strong>已完成的结果</strong>的数量，即使使用一个共享的Executor，也能知道已经获得了所有任务结果的时间。</p><h2 id="如何为任务设置时限"><a href="#如何为任务设置时限" class="headerlink" title="如何为任务设置时限"></a>如何为任务设置时限</h2><p>如果某个任务没有在指定时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。<code>Future.get</code>支持这种需求：当结果可用时，它将立即返回，如果在指定的时间内没有计算出结果，那么将抛出TimeoutException。</p><p>在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">long</span> endNanos = System.nanoTime() + <span class="number">2000</span>;</div><div class="line">    Future&lt;Ad&gt; f = executor.submit(<span class="keyword">new</span> FetchAdTask());</div><div class="line">    Page page = renderPageBody();</div><div class="line">    Ad ad;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</div><div class="line">        ad = f.get(timeLeft,TimeUnit.NANOSECONDS);</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</div><div class="line">        ad = DEFAULT_AD;</div><div class="line">        f.cancel(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    page.addAd(ad);</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="如何提交向线程池中提交一组计算任务"><a href="#如何提交向线程池中提交一组计算任务" class="headerlink" title="如何提交向线程池中提交一组计算任务"></a>如何提交向线程池中提交一组计算任务</h2><blockquote><p><strong>预订时间</strong>方法可以很容易扩展到任意数量的任务上。考虑这样一个门户网站：用户输入旅行的日期和其他要求，门户网站获取并显示来自多条航线、旅店或汽车租赁公司的报价。在获取不同公司报价的过程中，可能会调用Web服务、访问数据库、执行一个EDI事务或其他机制。在这种情况下，不宜让页面的响应时间受制于最慢的响应时间，而应该只显示在指定时间内收到的信息。</p><p>从一个公司获得报价的过程与其他公司获得报价的过程无关，因此可以将获取报价的过程当成一个任务，从而使获得报价的过程能够并发执行。</p></blockquote><p>可以通过ExecutorService的<code>invokeAll()</code>方法，用于将多个任务提交到一个ExecutorService并获得结果。invokeAll方法的参数为一组任务，返回一组Future。当所有的任务都执行完毕时，或者调用线程被中断，又或者超过指定时限时，invokeAll将返回。当超过指定时限时，任何还未完成的任务都将会取消。当invokeAll返回后，每个任务要么正常地完成，要么被取消，而客户端可以调用get或isCancelled来判断究竟是什么情况。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TravelQuoteService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ExecutorService executor;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany travelCompany;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QuoteTask</span><span class="params">(TravelCompany travelCompany, TravelInfo travelInfo)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.travelCompany = travelCompany;</div><div class="line">            <span class="keyword">this</span>.travelInfo = travelInfo;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> travelCompany.solicitQuote(travelInfo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuote</span><span class="params">(TravelInfo travelInfo,</span></span></div><div class="line">                                                  Set&lt;TravelCompany&gt; companies,</div><div class="line">                                                  Comparator&lt;TravelQuote&gt; ranking,</div><div class="line">                                                  <span class="keyword">long</span> time,</div><div class="line">                                                  TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (TravelCompany company : companies) &#123;</div><div class="line">            tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo));</div><div class="line">        &#125;</div><div class="line">        List&lt;Future&lt;TravelQuote&gt;&gt; futures = executor.invokeAll(tasks, time, unit);</div><div class="line"></div><div class="line">        List&lt;TravelQuote&gt; quotes = <span class="keyword">new</span> ArrayList&lt;&gt;(tasks.size());</div><div class="line">        Iterator&lt;QuoteTask&gt; iter = tasks.iterator();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Future&lt;TravelQuote&gt; future : futures) &#123;</div><div class="line"></div><div class="line">            QuoteTask task = iter.next();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                quotes.add(future.get());</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                quotes.add(task.getFailureQuote(e.getCause()));</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                quotes.add(task.getTimeoutQuote(e));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        quotes.sort(ranking);</div><div class="line">        <span class="keyword">return</span> quotes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="有些哪些类型的任务需要明确地指定执行策略"><a href="#有些哪些类型的任务需要明确地指定执行策略" class="headerlink" title="有些哪些类型的任务需要明确地指定执行策略"></a>有些哪些类型的任务需要明确地指定执行策略</h2><p>Executor框架可以将任务的<strong>提交</strong>与任务的<strong>执行策略</strong>解耦开来。虽然Executor框架为制定和修改执行策略都提供了相当大的灵活性，但并非所有的任务都能适用所有的执行策略，因此，有些类型的任务需要明确地指定执行策略：</p><ol><li><strong>依赖性任务</strong>：大多数行为正确的任务都是独立的，他们不依赖于其他任务的执行时序、执行结果和其他效果。如果提交给线程池的任务需要依赖其他的任务，那么就隐含地给执行策略带来了约束，此时必须小心地维持这些执行策略以避免产生活跃性问题。</li><li><strong>使用线程封闭机制的任务</strong>：单线程的Executor能够确保任务不会并发执行，对象可以封闭在任务线程中，使得在线程中执行的任务在访问对象时不需要同步，即使这些线程不是线程安全的也没问题。这种情形下，在任务与执行策略之间形成了隐式的耦合——任务要求其执行所在的Executor是单线程的。</li><li><strong>对响应时间敏感的任务</strong>：如果将一个运行时间较长的任务提交到单线程的Executor中，或者将多个运行时间较长的任务提交到一个只包含少量线程的线程池中，那么将降低由该Executor管理的服务的响应性。</li><li><strong>使用ThreadLocal的任务</strong>：在线程池的线程中不应该使用ThreadLocal在任务之间传递值。</li></ol><p>只有当任务都是<strong>同类型</strong>的并且<strong>相互独立</strong>时，线程池的性能才能达到最佳。</p><ul><li>如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程很大，否则将可能造成<strong>拥塞</strong>。</li><li>如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成<strong>死锁</strong>。</li></ul><h2 id="什么是线程饥饿死锁"><a href="#什么是线程饥饿死锁" class="headerlink" title="什么是线程饥饿死锁"></a>什么是线程饥饿死锁</h2><p>只要线程池中的任务需要<strong>无限期地等待</strong>一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程<strong>饥饿死锁</strong>。</p><p>因此，每当提交了一个有依赖的Executor任务时，要清楚地知道可能会出现线程<strong>饥饿死锁</strong>，因此需要在代码或配置Executor的配置文件中记录线程池的大小或配置限制。</p><p>如果任务阻塞的时间过长，那即使不出现死锁，线程池的响应性也会变得糟糕。执行时间过长的任务不仅会造成线程池阻塞，甚至还会增加执行时间较短任务的服务时间。</p><h2 id="如何设置线程池的大小"><a href="#如何设置线程池的大小" class="headerlink" title="如何设置线程池的大小"></a>如何设置线程池的大小</h2><p>只要线程池中的任务需要<strong>无限期地等待</strong>一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程<strong>饥饿死锁</strong>。</p><p>因此，每当提交了一个有依赖的Executor任务时，要清楚地知道可能会出现线程<strong>饥饿死锁</strong>，因此需要在代码或配置Executor的配置文件中记录线程池的大小或配置限制。</p><p>如果任务阻塞的时间过长，那即使不出现死锁，线程池的响应性也会变得糟糕。执行时间过长的任务不仅会造成线程池阻塞，甚至还会增加执行时间较短任务的服务时间。</p><h2 id="如何设置线程池的大小-1"><a href="#如何设置线程池的大小-1" class="headerlink" title="如何设置线程池的大小"></a>如何设置线程池的大小</h2><p>线程池的理想大小取决于<strong>被提交任务的类型</strong>以及<strong>所部署系统的特性</strong>。</p><p>设置线程池的大小需要避免“过大”和“过小”这两种极端情况。</p><ul><li>如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。</li><li>如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐率。</li></ul><p>因此，要想正确地设置线程池的大小，必须分析<strong>计算环境</strong>、<strong>资源预算</strong>和<strong>任务的特性</strong>。在部署的系统中有都少个CPU？多大的内存？任务是计算密集型、I/O密集型还是二者皆可？他们是否需要像JDBC连接这样的稀缺资源？如果需要执行不同类别的任务，并且他们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程可以根据各自的工作负载来调整。</p><p>要是处理器达到期望的使用率，线程池的最优大小等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">N_&#123;threads&#125;=N_&#123;cpu&#125;*U_&#123;cpu&#125;*(1+\frac&#123;W&#125;&#123;C&#125;)</div></pre></td></tr></table></figure><ul><li><code>$N_{cpu}$</code>：表示处理器数量，可以通过<code>Runtime.getRuntime().avaliableProcessors()</code>获得。</li><li><code>$U_{cpu}$</code>：CPU的使用率，<code>$0\leqslant U_{cpu}\leqslant 1$</code></li><li><code>$\frac{W}{C}$</code>：等待时间与计算时间的比值</li></ul><p>另外，CPU周期并不是唯一影响线程池大小的资源，还包括<strong>内存、文件句柄、套接字句柄和数据库连接</strong>等。通过计算<strong>每个任务对该资源</strong>的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果解释线程池大小的上限。</p><h2 id="线程池队列的用途"><a href="#线程池队列的用途" class="headerlink" title="线程池队列的用途"></a>线程池队列的用途</h2><p>如果无限制的创建线程，那么将可能耗尽内存资源，因此可以通过采用固定大小的线程池来解决这个问题。在高负载的情况下，应用程序仍可能耗尽资源：</p><ul><li>如果<strong>请求的到达速率超过了线程池的处理速率</strong>，那么新到来的请求将累计起来。这些请求会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源，当然也比使用线程表示的开销低很多。</li><li>即使请求的平均<strong>到达速率很平稳</strong>，但还是会有请求突增的情况。尽管任务队列有助于缓解任务的突增问题，如果任务持续高速地到来，<strong>响应性能也将随着任务队列的增长而变得越来越糟</strong>。</li></ul><p><code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>在默认情况下使用一个无界的<code>LinkedBlockingQueue</code>。如果所有工作者线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续地快速到达，并且超过了线程池处理他们的速度，那么队列将无限制的增加。</p><p>一种更稳妥的资源管理策略是使用<strong>有界队列</strong>，例如<code>ArrayBlockingQueue</code>、有界的<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>。有界队列有助于避免资源被耗尽，那么当队列填满后，新的任务该怎么办？可以根据饱和策略来进行处理。一般的，如果线程池较小而队列较大，那么有助于减少内存的使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价是会限制吞吐量。</p><p><code>ArrayBlockingQueue</code>或<code>LinkedBlockingQueue</code>是基于FIFO队列的，任务的执行顺序与他们的到达顺序相同。如果想进一步控制任务的执行顺序，可以使用<code>PriorityBlockingQueue</code>，这个队列可以根据优先级来安排任务。</p><p>对于<strong>非常大的线程池或者无界线程池</strong>，可以通过使用<code>SynchronousQueue</code>来避免排队，以及<strong>直接将任务从生产者移交给工作者线程</strong>。<code>SynchronousQueue</code>不是一个真正的队列，而是一种在线程之间进行移交的机制。如果要将一个元素放入<code>SynchronousQueue</code>中，必须有另一个线程正在等待接受这个元素。如果没有线程等待，并且线程池的<strong>当前大小小于最大值</strong>，那么<code>ThreadPoolExecutor</code>将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，只有当线程池是无界的或者可以拒绝任务时，<code>SynchronousQueue</code>才有实际的价值。在<code>newCachedThreadPool</code>工厂方法中就是用了<code>SynchronousQueue</code>。</p><h2 id="如何选择线程池"><a href="#如何选择线程池" class="headerlink" title="如何选择线程池"></a>如何选择线程池</h2><ul><li><code>newCachedThreadPool</code>工厂方法是一种很好的默认选择，它能够提供比固定大小的线程池更好的排队性能；</li><li>当需要限制当前任务的数量以满足资源管理器需求时，那么可以选择固定大小的线程池，例如在接受网络请求的服务器程序中，如果不进行限制，那么很容易导致过载问题。</li><li>只有当任务<strong>相互独立</strong>，为线程池设置界限才合理；如果任务之间存在<strong>依赖性</strong>，那么有界的线程池或队列就可能导致线程<strong>饥饿死锁</strong>问题，那么此时应该使用无界的线程池。</li><li>对于提交任务并等待其结果的任务来说，还有一种配置方法。就是使用有界的线程池，并使用<code>SynchronousQueue</code>作为工作队列，以及<strong>调用者运行</strong>饱和策略。</li></ul><h2 id="什么是线程池的饱和策略"><a href="#什么是线程池的饱和策略" class="headerlink" title="什么是线程池的饱和策略"></a>什么是线程池的饱和策略</h2><p>当有界队列被填满后，饱和策略将发挥作用。<code>ThreadPoolExecutor</code>的饱和策略可以通过调用<code>setRejectedExecutionHandler</code>来修改。如果某个任务被提交到一个已关闭的Executor，也会用到饱和策略。JDK提供了几种不同的<code>RejectedExecutionHandler</code>的饱和策略实现：</p><ol><li><strong>AbortPolicy（中止）</strong>：<ul><li>该策略是<strong>默认的</strong>饱和策略；</li><li>会抛出未检查的<code>RejectedExecutionException</code>，调用者可以捕获这个异常，然后根据需求编写自己的处理代码；</li></ul></li><li><strong>DiscardPolicy（抛弃）</strong>：<ul><li>当提交的任务无法保存到队列中等待执行时，Discard策略会悄悄抛弃该任务。</li></ul></li><li><strong>DiscardOldestPolicy（抛弃最旧）</strong>：<ul><li>会抛弃下一个将被执行的任务，然后尝试重新提交的新任务。</li><li>如果工作队列是一个优先队列，那么<strong>抛弃最旧的</strong>策略，会抛弃优先级最高的任务，因此最好不要将<strong>抛弃最旧的</strong>饱和策略和优先级队列放在一起使用。</li></ul></li><li><strong>CallerRunsPolicy（调用者运行）</strong>：<ul><li>该策略既不会抛弃任务，也不会抛出异常，而是当线程池中的所有线程都被占用后，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行，从而降低新任务的流量。</li><li>由于执行任务需要一定的时间，因此主线程至少在一定的时间内不能提交任何任务，从而使得工作者线程有时间来处理正在执行的任务。</li><li>另一方面，在这期间，主线程不会调用accept，那么到达的请求将被保存在TCP层的队列中而不是在应用程序的队列中。</li><li>如果持续过载，那么TCP层将最终发现他的请求队列被填满，因此同样会开始抛弃请求。</li><li>当服务器过载时，这种过载情况会逐渐向外蔓延开来——从<strong>线程池</strong>到<strong>工作队列</strong>到<strong>应用程序</strong>再到<strong>TCP层</strong>，最终到达<strong>客户端</strong>，导致服务器在高负载的情况下实现一种平缓的性能降低。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor <span class="title">newThreadPoolOfFixedWithCallerPolicy</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">200</span>,</div><div class="line">            <span class="number">200</span>,</div><div class="line">            <span class="number">0L</span>,</div><div class="line">            TimeUnit.MILLISECONDS,</div><div class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>));</div><div class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</div><div class="line">    <span class="keyword">return</span> executor;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过，当工作队列被填满后，并没有预定的饱和策略来阻塞execute。因此，可以通过信号量Semaphore来限制任务的到达速率，就可以实现该功能。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedExecutor</span><span class="params">(Executor executor, <span class="keyword">int</span> bound)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">        <span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(bound);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitTask</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        semaphore.acquire();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            executor.execute(command::run);</div><div class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">            semaphore.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="什么是线程工厂"><a href="#什么是线程工厂" class="headerlink" title="什么是线程工厂"></a>什么是线程工厂</h2><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含任何特殊的配置信息。</p><p>因此，通过指定一个线程工厂方法，可以定制线程的配置信息。例如，可以定制一个用于日志打印的线程工厂，在线程被创建或者终止时把调试信息写入日志。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggerThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.poolName = poolName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoggerThread(r, poolName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"logable thread"</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> debugLifecycle = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger CREATED = <span class="keyword">new</span> AtomicInteger();</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger ALIVE = <span class="keyword">new</span> AtomicInteger();</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = Logger.getAnonymousLogger();</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoggerThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>(r, DEFAULT_NAME);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoggerThread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(target, name + <span class="string">"-"</span> + CREATED.incrementAndGet());</div><div class="line">            setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</div><div class="line">                    LOG.log(Level.SEVERE, <span class="string">"UNCAUGHT in thread "</span> + t.getName(), e);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">boolean</span> debug = debugLifecycle;</div><div class="line">            <span class="keyword">if</span> (debug) &#123;</div><div class="line">                LOG.log(Level.FINE, <span class="string">"Created "</span> + getName());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ALIVE.incrementAndGet();</div><div class="line">                <span class="keyword">super</span>.run();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                ALIVE.decrementAndGet();</div><div class="line">                <span class="keyword">if</span> (debug) &#123;</div><div class="line">                    LOG.log(Level.FINE, <span class="string">"Exiting "</span> + getName());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsCreated</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> CREATED.get();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> ALIVE.get();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDebug</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> debugLifecycle;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> debug)</span> </span>&#123;</div><div class="line">            debugLifecycle = debug;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>另外，如果在应用程序中需要利用安全策略来控制对某些特殊代码库的访问权限，那么可以通过Executor中的<code>PrivilegedThreadFactory</code>工厂来定制自己的线程工厂。</p><h2 id="unconfigurableExecutorService用途"><a href="#unconfigurableExecutorService用途" class="headerlink" title="unconfigurableExecutorService用途"></a>unconfigurableExecutorService用途</h2><p>在调用完ThreadPoolExecutor的构造函数后，仍然可以通过设置函数来修改大多数传递给它的构造函数参数（例如，线程池的大小、最大大小、存活时间等）。</p><p>在Executors中包含一个<code>unconfigurableExecutorService</code>工厂方法，该方法能够对一个现有的<code>ExecutorService</code>进行包装，使其只暴露出<code>ExecutorService</code>的方法，因此不能对它进行配置，从而保证原有线程池工厂的执行语义，因此可以使用这项技术保证自己的Executor执行策略不被修改。</p><h2 id="如何扩展ThreadPoolExecutor"><a href="#如何扩展ThreadPoolExecutor" class="headerlink" title="如何扩展ThreadPoolExecutor"></a>如何扩展ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是可扩展的，提供了几个可以在子类化中改写的方法：<code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>，这些方法可以从来扩展<code>ThreadPoolExecutor</code>的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = Logger.getLogger(TimingThreadPool.class.getSimpleName());</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger numTask = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong totalTime = <span class="keyword">new</span> AtomicLong();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimingThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</div><div class="line">        log.fine(String.format(<span class="string">"Thread %s: start %s"</span>, t, r));</div><div class="line">        startTime.set(System.nanoTime());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">            <span class="keyword">long</span> taskTime = endTime - startTime.get();</div><div class="line">            numTask.incrementAndGet();</div><div class="line">            totalTime.addAndGet(taskTime);</div><div class="line">            log.fine(String.format(<span class="string">"Thread %s: end %s, time=%dns"</span>, t, r, taskTime));</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">super</span>.afterExecute(r, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            log.info(String.format(<span class="string">"Terminated: avg time=%dns"</span>, totalTime.get() / numTask.get()));</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">super</span>.terminated();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何实现递归算法的并行化"><a href="#如何实现递归算法的并行化" class="headerlink" title="如何实现递归算法的并行化"></a>如何实现递归算法的并行化</h2><p>如果循环中的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成再继续进行，那么就可以使用Executor将串行循环转化为并行循环。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInParallel</span><span class="params">(Executor exec, List&lt;Element&gt; elements)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(Element e: elements)&#123;</div><div class="line">        exec.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                process(e);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>processInParallel</code>能够更快的返回，不会等待这些任务全部完成。如果需要提交一个任务集并等待他们全部完成，那么可以使用<code>ExecutorService.invokeAll()</code>，并且在所有任务执行完成后，使用<code>CompletionService.take()</code>获取结果。</p><p>在一些递归设计中同样采用循环并行化的方法，一种简单的情况是：<strong>在每个迭代操作中都不需要来自于后续递归迭代的结果</strong>。例如，等待通过并行方式计算的结果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sequentialRecursive</span><span class="params">(List&lt;Node&gt; nodes, Collection&lt;T&gt; results)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(Node&lt;T&gt; n : nodes)&#123;</div><div class="line">        results.add(n.compute());</div><div class="line">        sequentialRecursive(n.getChildren(), results);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelRecursive</span><span class="params">(<span class="keyword">final</span> Executor exec, List&lt;Node&lt;T&gt;&gt; nodes, <span class="keyword">final</span> Collection&lt;T&gt; results)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(Node&lt;T&gt; n : nodes)&#123;</div><div class="line">        exec.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                results.add(n.compute());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        parallelRecursive(exec, n.getChildren(), results);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getParallelResults</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span></span>&#123;</div><div class="line">    ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">    Queue&lt;T&gt; resultQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</div><div class="line">    parallelRecursive(exec, nodes, resultQueue);</div><div class="line">    exec.shutdown();</div><div class="line">    exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</div><div class="line">    <span class="keyword">return</span> resultQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"># java</a> <a href="/tags/多线程/" rel="tag"># 多线程</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/repository/jvm-knowledge-self-class-loading.html" rel="next" title="JVM知识自查表——类加载"><i class="fa fa-chevron-left"></i> JVM知识自查表——类加载</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://op87q3xru.bkt.clouddn.com/self/image/avatar.png" alt="落枫寒"><p class="site-author-name" itemprop="name">落枫寒</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">10</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要创建线程"><span class="nav-number">1.</span> <span class="nav-text">为什么要创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么不能无限制创建线程"><span class="nav-number">2.</span> <span class="nav-text">为什么不能无限制创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简介Executor接口"><span class="nav-number">3.</span> <span class="nav-text">简介Executor接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor的执行策略"><span class="nav-number">4.</span> <span class="nav-text">Executor的执行策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程池"><span class="nav-number">5.</span> <span class="nav-text">什么是线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的优点"><span class="nav-number">6.</span> <span class="nav-text">线程池的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建线程池的方法"><span class="nav-number">7.</span> <span class="nav-text">创建线程池的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor的生命周期"><span class="nav-number">8.</span> <span class="nav-text">Executor的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Timer实现延迟任务或周期任务的缺点"><span class="nav-number">9.</span> <span class="nav-text">使用Timer实现延迟任务或周期任务的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈对Callable与Future的理解"><span class="nav-number">10.</span> <span class="nav-text">谈谈对Callable与Future的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是任务取消，以及有哪些操作会取消任务"><span class="nav-number">11.</span> <span class="nav-text">什么是任务取消，以及有哪些操作会取消任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池中哪个阶段的任务可以取消"><span class="nav-number">12.</span> <span class="nav-text">线程池中哪个阶段的任务可以取消</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是任务取消策略"><span class="nav-number">13.</span> <span class="nav-text">什么是任务取消策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程中断，以及用途"><span class="nav-number">14.</span> <span class="nav-text">什么是线程中断，以及用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何正确的处理InterruptedException"><span class="nav-number">15.</span> <span class="nav-text">如何正确的处理InterruptedException</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何处理非正常的线程终止"><span class="nav-number">16.</span> <span class="nav-text">如何处理非正常的线程终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是关闭钩子"><span class="nav-number">17.</span> <span class="nav-text">什么是关闭钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#普通进程与守护线程之间的差异"><span class="nav-number">18.</span> <span class="nav-text">普通进程与守护线程之间的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异构任务并行中存在哪些局限性"><span class="nav-number">19.</span> <span class="nav-text">异构任务并行中存在哪些局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CompletionService的作用"><span class="nav-number">20.</span> <span class="nav-text">CompletionService的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何为任务设置时限"><span class="nav-number">21.</span> <span class="nav-text">如何为任务设置时限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何提交向线程池中提交一组计算任务"><span class="nav-number">22.</span> <span class="nav-text">如何提交向线程池中提交一组计算任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有些哪些类型的任务需要明确地指定执行策略"><span class="nav-number">23.</span> <span class="nav-text">有些哪些类型的任务需要明确地指定执行策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程饥饿死锁"><span class="nav-number">24.</span> <span class="nav-text">什么是线程饥饿死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何设置线程池的大小"><span class="nav-number">25.</span> <span class="nav-text">如何设置线程池的大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何设置线程池的大小-1"><span class="nav-number">26.</span> <span class="nav-text">如何设置线程池的大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池队列的用途"><span class="nav-number">27.</span> <span class="nav-text">线程池队列的用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何选择线程池"><span class="nav-number">28.</span> <span class="nav-text">如何选择线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程池的饱和策略"><span class="nav-number">29.</span> <span class="nav-text">什么是线程池的饱和策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程工厂"><span class="nav-number">30.</span> <span class="nav-text">什么是线程工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unconfigurableExecutorService用途"><span class="nav-number">31.</span> <span class="nav-text">unconfigurableExecutorService用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何扩展ThreadPoolExecutor"><span class="nav-number">32.</span> <span class="nav-text">如何扩展ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现递归算法的并行化"><span class="nav-number">33.</span> <span class="nav-text">如何实现递归算法的并行化</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="author" itemprop="copyrightHolder"><a href="http://www.vibrancy.cn">落枫寒</a>&nbsp;版权所有</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script></body></html><!-- rebuild by neat -->